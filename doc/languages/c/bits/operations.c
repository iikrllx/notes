/*

Кратко:

check_bit  -> ((x & (1 << pos)) != 0)
set_bit    -> (x | (1 << pos))
unset_bit  -> (x & ~(1 << pos))
switch_bit -> (x ^ (1 << pos))

2 << 1 (умножение, из 2 сделали 4)
4 >> 1 (деление, из 4 сделали 2)

Почему именно 1 << (позиция)
Происходит умножение битов на другие биты, тем самым
обнаруживаются только 1 или 0

Например в 1000, во всех итерациях вернет 0, потому что
1000 & 0001 = 0000 (вернет 0)
а вот 1000 & 1000 (вернет != 0, значит бит равен 1)

*/


// получаем 7
#define CHAR_LEN (sizeof(char) * CHAR_BIT - 1)


int unset_bit(char value, int pos)
{
  // сброс бита
  // задать 0 бит на позиции
  return (value & ~(1 << pos));
}


int switch_bit(char value, int pos)
{
  // замена бита
  // изменить бит на противоположный поможет ИСКЛ.ИЛИ
  return (value ^ (1 << pos));
}


int set_bit(char value, int pos)
{
  // установка бита
  // здесь используется сложение,
  // потому что нужно получить 1, а для этого актуально ИЛИ
  return (value | (1 << pos));
}


int check_bit(char value, int pos)
{
  // с помощью & происходит сравнение чисел
  return ((value & (1 << pos)) != 0);
}


int main(void)
{
  char n = 3;
  int len;


  /*
    Проверка битов на 1 / 0
    Итог будет таким: 0 0 0 0 0 0 1 1
    Означает что в первых двух позициях числа 3, стоят биты false (1)
    В остальных же позициях стоят биты 0 (true) */
  for (len = CHAR_LEN; len >= 0; len--)
    printf("%d ", check_bit(n, len));
  printf("\n\n");



  // задать бит 1 на необходимую позицию
  for (len = CHAR_LEN; len >= 0; len--)
    printf("%d ", set_bit(n, len));
  printf("\n\n");



  /*
    Задать бит 0 на необходимую позицию - сброс бита

    Установка 0 бита в n позиции, для этого нужно умножить число на такое,
    у которого все биты равны единице, кроме бита под номером n
    Например:
    3 & ~(1 << 2))
    001 << 2 = 100 затем идет инверсия: 011
    011 & 011 = 011 (3) Здесь бит в 2 позиции без изменений, стоит в 0
    Если вдуматься выражение: ~(1 << 2) является маской

    Например чтобы изменить бит с 1 на 0 у числа 3 в первой позиции нужно:
    3 & ~(1 << 0);
    Число 001 под инверсией станет 110
    Затем 011 умножим на 110, получается 010
    То есть в первой позиции мы поставили туда 0 */
  for (len = CHAR_LEN; len >= 0; len--)
    printf("%d ", unset_bit(n, len));
  printf("\n\n");



  // подсчет 1 / 0 в числе
  int bc_0 = 0, bc_1 = 0, rval;

  for (len = CHAR_LEN; len >= 0; len--) {
    rval = check_bit(n, len);
    (rval == 0) ? bc_0++ : bc_1++;
  }

  printf("zero byte (%ld) / one byte (%ld)\n", bc_0, bc_1);
  printf("\n");



  // изменить бит на противоположный
  for (len = CHAR_LEN; len >= 0; len--)
    printf("%d ", switch_bit(n, len));
  printf("\n\n");

  return 0;
}

/*
Можно положить сдвиг в макрос, например:
#define SHIFT_BIT(pos) (1 << pos)
x ^= SHIFT_BIT(i);

И вывод тоже можно сделать в макросе:
#define PRINT_BITS(x, pos) (printf("%d", ((x & (1 << pos)) != 0))
*/
