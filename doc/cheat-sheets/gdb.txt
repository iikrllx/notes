gdb - Gnu Debugger.

Интерфейс в gdb (debug режима) называется call stack (стек функций).
Работает по принципу push / pop, кладет на вершину и снимает с вершины.
В call stack обычно видны, вызовы функций, локальные переменные, параметры, аргументы и т.д.

$ cat /proc/sys/kernel/yama/ptrace_scope
$ 0

Если не удалось отредактировать, тогда /etc/sysctl.d
найти kernel.yama.ptrace_scope=3

$ gcc -g3 file.c         компиляция с добавочной отладочной информацией
$ gdb -p 1010            отладочный режим процесса
$ tui                    графическая отладка
$ break main             останова функции main (контрольная точка)
$ break 10               останова с 10 строки
$ delete 1               удалить останову 1
$ delete                 удалить все остановы
$ continue               продолжить с последней точки остановы
$ run                    выполнение программы
$ print variable         вывод иниц переменной
$ print/d variable       спецификатор
$ next                   переход по строкам
$ step                   проход вместе с функциями
$ advance func_name      пропустить функцию (когда мы в ней находимся)
$ frame                  просмотр кадра
$ f 1                    переключиться на кадр
$ info break             информация об останове
$ info macro <const>     информация о препроцессоре
$ info frame             информация о кадре
$ info args              посмотреть аргументы
$ info locals            посмотреть локальные переменные
$ info proc              информация о процессе
$ info source            информация о исходнике
$ up / down              переключение по кадрам (стеку)
$ print sizeof(i)        размер занимаемый переменной памяти - 4 байта
$ print my_var=123       изменить значение переменной
$ set var i = "Hello"    присвоить уже иниц переменной значение
$ ptype i                показывает тип данных переменной
$ ptype main             тоже самое с функцией
$ set $j = (int)10       создание временной переменной
$ print $j + index       инкремент с уже существующей переменной
$ list                   вывод исходного кода текста программы
$ list 14,20             по строкам
$ list name_of_func      вывод функции
$ until 30               бывает такое что нужно скипнуть долгий цикл
$ detach                 отцепиться от процесса, но остаться в gdb
$ finish                 завершить функцию и вывести return статус
$ print *arr@size        сделать вывод всего массива, в size должна хранится
$ print *arr@2           тоже как вариант
$ ctrl + x + a           менят окна между обычным окном gdb и окном tui

Если нам нужно находиться в отладке непрерывно, при этом сохранив все остановы
$ shell gcc -g3 file.c
$ r                      загрузка новых данных

Когда происходит отладка какого-то процесса gdb -p <pid>
То можно использовать такие трюки как shell ls -l /proc/<pid>/fd
Или например закрыть файловый дескриптор call (int)close(fd)

$ help x
$ print /t 3             выводит в bin 11
$ print /x 255           выводит в hex 0x000000ff
$ print /o 255           выводит в octal 0377
$ print /d 0XFF          выводит в dec 255
$ print 0b11111111       выводит в dec

Как пропустить кол-во итераций
$ b <line in body for loop>
$ c <n>                  n кол-во итераций для пропуска

Посмотреть окружение программы
$ show environment

Если при отладке процесс стоит в ожидании (например wait)
Можно спровоцировать его на действия и сделать останову в нужном месте
Например:
$ b imap_fetch_more_int
$ c
Будет ждать ...

В thunderbird нажать "Получить"
Бац, стек переместился в imap_fetch_more_int
