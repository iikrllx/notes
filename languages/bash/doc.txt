Темы:
* Почему Bash ?
* Код состояния
* Как выполняется команда в Bash
* Что означает #!/bin/bash
* Куда класть скрипты
* Сколько хранится символов в TAB
* Что такое трассировка и как она используется
* Клавиша CNTRL и ^
* CTRL + R in bash
* Проверка - 'test' -> man test
* Позиционные и специальные параметры
* Переменные
* Какие опции бывают
* Bash Prompt
* Оболочка по умолчанию
* exec и tee
* echo перенаправление вывода
* Удаленное исполнение скрипта
* Как удалить ненужную директорию из списка PATH
* Как создать чистую переменную PATH
* Структуры данных в Bash и declare
* Обработка сигнала в скрипте
* Разница между arr[@] и arr[*]
* Генерация рандомных чисел
* grep и stderr
* set / unset
* shift
* source
* export
* local
* readonly
* read
* dirname & basename
* gettext
* pushd / popd / dirs
* Блокировка файла
* alias / unalias
* Экранирование
* Кавычки
* /bin/sh


--- Почему Bash ?
Почему именно Bash, а не Ruby или Python? Потому что сценарий на Bash, запустится на любой Linux
системе без каких либо проблем, Python, Go, Ruby не устанавливаются по умолчанию, поэтому у них
могут быть проблемы с переносимостью. На одной системе такая-то версия Python, на другой может быть
совсем всё иначе (окружение). А с Bash всё намного проще (входит в стандарт POSIX = переносимость).


--- Код состояния
Командная оболочка поддерживает переменную, с помощью которой можно определить код завершения
$ ls -l /usr/bin затем спрашивает у оболочки $ echo $? (возвращает 0 (означает успех)),
остальные цифры означают fail.

Команды, функции, скрипты по завершению работы возвращают системе значение, которое называется кодом
завершения (exit status), целое число от 0 до 255.


--- Как выполняется команда в Bash
Список каталогов, в которых Bash будет искать команды, хранится в переменной окружения с именем
PATH. Если вывести echo $PATH выводится список каталогов, которые разделены двоеточием, в этих
каталогах и будет искаться команда написанная нами. Узнать нахождение команды echo можно так:
$ which echo (Bash ищет команды в том порядке, в котором выведены каталоги $PATH)


--- Что означает #!/bin/bash
Строка #!/bin/bash означает (shebang) - командная оболочка определяет, какую программу
запустить для интерпретации сценария. Здесь мы указали интерпретатор bash.

Если путь /bin/bash не найден, а это иногда бывает на других OC
#!/usr/bin/env bash

Лучше использовать данный путь, это помогает в переносимости скриптов
Потому что /usr/bin/env неизменный на всех ОС.

Позволяет запускать команды с использованием среды окружения, определенной в переменной окружения
`PATH`, что обеспечивает гибкость и переносимость скриптов между различными системами. В частности,
/usr/bin/env может использоваться для указания пути к интерпретатору для скрипта, чтобы обеспечить
его выполнение на различных системах, где путь к интерпретатору может отличаться.


--- Куда класть скрипты
Для этого хорошо подходит /usr/local/bin, но в разных ОС Linux по разному. Лучше вывести $ echo $PATH
и проверить директории в которых осуществляется поиск программы, если мы поместим скрипт в каталог,
который выводится при $ echo $PATH мы сможем запускать его везде, если напишем название файла.

Но если мы хотим выводить скрипты из /home/<user>/bin/
Мы можем отредактировать .bashrc написав.
export PATH=~/bin:"$PATH"

Скрипты для личного использования можно хранить в /home/<user>/bin
Скрипты для всех пользователей /usr/local/bin
Скрипты для системного администратора /usr/local/sbin

Все скомпилированные программы и скрипты лучше класть в /usr/local


--- Сколько хранится символов в TAB
Один символ табуляции занимает 8 знакомест, многие программисты меняют это значение на 4 или 2.


--- Что такое трассировка и как она используется
Размещение информативных сообщений в разных точках сценария, для отслеживания протекания выполнения
скрипта называется трассировкой, можно прописать в определенных местах команды echo, а можно в
shebang добавить параметр -x > #!/bin/bash -x

Если надо провести трассировку с помощью проверки команд, то в командном интерпретаторе нужно
указать set -x

Или можно написать bash -x ./script Если нужно отключить: +x


--- Клавиша CTRL и ^
Команды драйверу, через терминал генерируются при помощи сочетания клавиш
CTRL (control - управление) Сигналы драйверу терминала ^C - CTRL + C (прерывание)


--- CTRL + R in bash
Для того чтобы не делать history | grep command
Можно заменить на CTRL + R - ввести аргумент и Bash найдет команду


--- Проверка - 'test' -> man test
-z      пусто
-n      не пусто
-eq     равенство
-ne     неравенство
-e      существует
-f      файл
-d      директория
-r      читабельный
-w      редактируемый
-x      исполняемый
-ge     меньше
-le     больше


--- Позиционные и специальные параметры
Это аргументы командой строки (или аргументы функций), доступ к которым осуществляется по номеру.

Позиционные:
$0              имя скрипта
$1-$2-$3-n      аргументы переданные скрипту
$#              кол-во аргументов (не считая 0)
$*              все позиционные параметры (не считая 0)
$!              показать родителя

Специальные:
$?              код состояния
$$              номер текущего процесса


--- Переменные
Локальные переменные: область видимости.
Переменные окружения: Каждый процесс имеет некоторое окружение, набор переменных, к которым процесс
может обращаться за получением определенной информации. Изменение переменных или добавление новых
переменных окружения заставляет оболочку обновить свои переменные, и все дочерние процессы (и
команды, исполняемые ею) наследуют это окружение. Пространство, выделяемое под переменные
окружения, ограничено. Создание слишком большого кол-ва переменных окружения или одной переменной,
которая занимает слишком большое пространство, может привести к возникновению проблем. Сценарий
может экспортировать переменные только дочернему процессому. Сценарий, запускаемый из командной
строки не может экспортировать переменные "на верх" (родительскому процессу). Собственные
переменные лучше начинать с lowercase, потому что uppercase обычно - переменные окружения.


--- Какие опции бывают
Аргументы подразделяются на две категории: опции / флаги
--help - длинная опция
-h     - флаг / короткая опция


--- Bash Prompt
Bash имеет 4 строки приглашения, каждая из которых может быть по своему настроена, приглашения:
PS1(основное приглашение)
PS2(отображается для многострочных команд)
PS3(редко используется)
PS4(при отладке скриптов показывает уровни вложенности)

Настройка подразумевает изменение значение переменных в файлах
окружения, например в ~/.bashrc

Эскейп-последовательности, например в PS1 есть моменты вроде \u (имя пользователя)


--- Оболочка по умолчанию
Оболочкой по умолчанию для всех новых пользователей системы Linux следует сделать bash так как:
1. пользователи будут взаимодействовать с той же оболочкой, в какой они привыкли создавать сценарии.
2. это стандарт. 3. в bash можно комфортно работать с вводом / выводом.

В других оболочках есть свои неприятные моменты, которые очень ярко выражены, поэтому
лучше использовать bash. Например, csh является плохим инструментов для написания сценариев.

Список оболочек: /etc/shells


--- exec и tee
С помощью exec можно делать замену дескрипторов.

tee читает из своего stdin и пишет в stdout например: $ exec 2> >(tee file.log) здесь два процесса
первый процесс наш исполняемый скрипт, а второй это tee у первого процесса stderr - 2 смотрит в
pipe, у второго процесса stdin - 1 смотрит тоже в этот же pipe то есть весь stderr сценария будет
перенаправляться в tee, который будет записывать это в файл.

часто с tee командами возникает freeze shell
tee останавливает появления приглашения PS1, ожидает EOF
в своем stdin, в качестве обходного пути можно сделать sleep .1

например так:
exec &> >(tee file.txt)
sleep .1

&> и >& одинаковы
2>&1 перенаправляет stderr в stdout
>/dev/null перенаправляет только stdout

$ bash main.sh 2>&1 | tee logs/file.log
$ bash main.sh 2> >(tee logs/stderr.log)

exec &> >(tee file.txt) # 1-2
exec 1> >(tee file.txt) # stdout
exec 2> >(tee file.txt) # stderr

exec 1>&-           # закрывает дескриптор 1
ls 2>&1 > file.txt  # вывести stderr и stdout в файл


--- echo перенаправление вывода
>&1 echo ahello  # выводит в stdout, echo ahello тоже самое
>&2 echo bhello  # выводит в stderr
echo err >&2     # тоже самое

Имеется три способа перенаправить вывод >, >>, |


--- Удаленное исполнение скрипта
$ ssh <user>@<ip> bash -s < script.sh

Осуществляется перенаправления сценария script.sh с машины А
На машину Б через сеть (сокет). bash -s команды считываются из
стандартного ввода.


--- Как удалить ненужную директорию из списка PATH
А никак :) Нет отдельных инструментов для редакторования этой переменной.
Если в PATH переменной ненужный каталог, можно экспортировать PATH по новой.


--- Как создать чистую переменную PATH
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

Если выполняется сценарий, который пишет export в файл ~/.bashrc
и затем необходимо обновить оболочку, необязательно делать exec $SHELL
можно добавить . ~/.bashrc и далее выполнять команды.


--- Структуры данных в Bash
В Bash нет структур данных как например в языке программирования Си.
Есть подобие массивов и ключевое слово declare с помощью которого можно
создавать массивы, переменные (читаемые, нечитаемые) и другие типы.
Раньше использовали typeset (устарело), а сейчас используют declare

declare -a arr=(1 2 3)            # массив
declare -A arr=([0]="A" [1]="B")  # хеш
declare -r var="hello"            # аналог readonly var="hello" (const в Си)
declare -i num=2                  # целое число
declare -f                        # выводит все функции, declare -f func
declare -x var=5                  # аналог export var=5
declare -ir num=2                 # делает readonly число


--- Обработка сигнала в скрипте
Любой сигнал можно обработать с помощью 'trap'

func()
{
  echo "This is SIGINT"
}

trap func SIGINT


--- Разница между arr[@] и arr[*]
Эти операторы отличаются, когда элементы массива имеют двойные кавычки.

version_list=(\
  "2.12.29" "2.12.40" "2.12.42" "2.12.43" "2.12-testing"
  "1.6.0" "1.6.2" "1.6.3" "1.6.4" "1.6.5" "1.6.6" "1.6.7" "1.6.8" "1.6.9" "1.6.10" "1.6-testing"
  "1.7.0" "1.7.1 (Orel)" "1.7.1 (Voronezh)" "1.7.1 (Smolensk)"
  "1.7-testing (Orel)" "1.7-testing (Voronezh)" "1.7-testing (Smolensk)"
)

for v in ${version_list[*]}; do ...
выдаст в столбец:
2.12.29
2.12.40
1.7.1
(Orel)

for v in ${version_list[@]}; do ...
выдаст так же как и выше

а вот for v in "${version_list[@]}"; do ...
2.12.29
2.12.40
1.7.1 (Orel)

А с for v in ${!version_list[*]}; do ...
Оператор ! делает автоматически и выводит всё нормально.


--- Генерация рандомных чисел
RANDOM / SRANDOM переменные, которые автоматически генерируют рандомное число.
$ echo $RANDOM

$ cat /dev/urandom | tr -dc 'a-z0-9' | head -c 8; echo
tr -d означает, что необходимо вычленить из прочитанного 'a-z0-9'
tr -c бинарное преобразовывает в нормальный вид
head -c 8 означает, строка длиной 8 байт

что использовать /dev/random или /dev/urandom ?
для практических целей, лучше использовать /dev/urandom
/dev/random может быть заблокирован.


--- grep и stderr
Утилита grep не работает с стандартным выводом ошибок, например:
$ apt-get update пишет ошибки в stderr, поэтому:
$ apt-get update 2>&1 | grep NO_PUBKEY


--- set / unset
Управляет, задает параметры, выводит shell окружение.
Эти команды можно использовать не только в скриптах, но и в самом терминале.

set -e                        # немедленный выход, если выходное состояние команды ненулевое
                              # если в сценарии есть подобная ситуация:
echo "$list" | grep .tar.gz   # grep не(grep)нулся

set -vx                       # подробная отладка
set                           # выводит всё shell окружение, по порядку
set -a                        # после данной команды, можно создавать переменные и они будут экспортированы
                              # в окружение, если в скрипте задать, то всё будет эскортировано в окружение
set -n                        # читает команды из сценария, но не исполняет их (проверка синтаксиса)

unset не работает для read-only переменных, с помощью unset можно удалить (зачистить)
переменную или функцию (имя)

$ value=2
$ echo $value     # 2
$ unset $value
$ echo $value     # пусто

$ declare -f      # вывести все функции окружения
$ unset -f fname  # удалить функцию из окружения


--- shift
Сдвигает позиционные параметры, параметры сдвигаются на одну позицию влево:
$ bash script.sh a b
$0 будет script.sh
$1 b
'а' аргумент исчез, сдвинулся.


--- source
Выполняет команды из файла в текущую shell оболочку
source ~/.vimrc # загрузит новые данные (после редактирования например)

Хоть в языке Bash нет #include, можно использовать "."
Например, в эмуляторе терминала сделать $ . script.sh
$ echo $var # Будет выведено значение из скрипта script.sh
. и 'source' - идентичны, но точка более перенасима.

Можно написать библиотечный сценарий (с отдельными полезными функциями)
поместить его в один из каталогов PATH и затем, любым другим скриптом, сделать:
. "script.sh"


--- export
Интересный пример:
$ val="Hello"
$ echo $val # успех
$ bash
$ echo $val # пусто

Последний echo ничего не выдаст, потому что создался дочерний процесс bash и в нем нет данной
переменной, которую мы объявили в родительском процессе.

А если мы сделаем:
$ export val="Hello"
$ echo $val # успех
$ bash
$ echo $val # успех

Потому что дочерний процесс наследует окружение родителя.

А вот включение нового каталога в PATH окружение:
$ export PATH=$PATH:/usr/local/bin

Чтобы удалить переменную из списка экспорта нужно сделать:
$ unset VARIABLE

$ export -p            # выводит все экспортируемые переменные
$ export -f func_name  # экспорт функции

func_name()
{
  echo hello
  exit 0
}

$ export -f func_name


--- local
Определяет локальную переменную, ключевое слово local может использоваться только в функциях.

func()
{
  local value=2
  echo $value
}


--- readonly
Делает переменные неизменяемыми.
$ readonly -p          # показывает все readonly в shell окружении
$ readonly var=2       # создает readonly переменную
$ readonly -A var=()   # создает readonly массив


--- read
Считывает одну строку данных из stdin в переменную
$ read my_array[5];    # записывает в массив
$ read -s              # секретный ввод (не выводит содержимое текста)
$ read -u <fd>         # записывает не в stdin, а в любой другой fd

$ read -s -p "Press any key to continue..." -n 1 dummy
Считывает 1 символ (с помощью -n) -p убирает строку приглашения и ставит
на её место строку "Press ..."


--- dirname & basename
$ dirname /usr/local/bin/file.sh  # /usr/local/bin
$ basename /usr/local/bin/file.sh  # file.sh


--- gettext
С помощью gettext происходит трансляция языка в язык пользователя (зависит от переменной LANG)
Необходимо иметь файл с переводом *.po: $ echo $(gettext "# Testing correct Acl RWX mechanism")


--- pushd / popd / dirs
Показывают всю красоту стека и его логику.
$ pushd ~/main
$ pushd ~/main/notes
$ dirs
$ popd


--- Блокировка файла
Можно использовать утилиту flock

# Выбираем дескриптор 200 (допустим) и открываем файл с помощью flock
exec 200>/tmp/mylockfile
flock -n 200 || exit 1
echo "Hello" >> /tmp/mylockfile
flock -u 200

Если другой сценарий будет использовать flock и попытается создать этот же файл
у него сработает exit 1. Если другой процесс попытается сделать изменения с этим файлом,
без использования flock, то все получится. Смысла в этом мало ...

# Чужой процесс
rm /tmp/mylockfile


--- alias / unalias
$ alias       # список всех alias
$ unalias ls  # удалить alias
$ unalias -a  # удалить все alias

Если alias прописаны в .bashrc, можно сделать $ exec $SHELL чтобы вернуть их после unalias.


--- Экранирование
Экранирование в Bash используется для того, чтобы заставить интерпретатор Bash рассматривать
следующий за экранированным символом символ как обычный текст, а не как специальный символ с особым
значением.

$ echo "Символ экранирования: \"

В этом примере символ экранирования "\" перед символом кавычки "\"" указывает Bash
игнорировать специальное значение кавычки и просто вывести ее как обычный текст.

Другой пример экранирования - экранирование пробелов в именах файлов или директорий:
$ cd Documents/My\ Files

В этом примере символ "\" перед пробелом в имени "My Files" указывает Bash на то,
что пробел не является разделителем и является частью имени директории,
и он должен быть обработан как обычный символ.

Например, использование vim поиска, найти /usr/bin/bash
\/usr\/bin/\/bash


--- Кавычки
Желательно использовать двойные кавычки (" ") при обращении к переменным.
Это предотвратит интерпретацию специальных символов, которые могут содержаться в именах переменных,
за исключением $, ` (обратная кавычка) и \ (escape -- обратный слэш). То, что символ $ попал в разряд исключений,
позволяет выполнять обращение к переменным внутри строк, ограниченных двойными кавычками ("$variable"),
т.е. выполнять подстановку значений переменных. Двойные кавычки могут быть использованы для предотвращения
разбиения строки на слова. Если в строке есть символы ' ', `, \, " то лучше использовать двойные кавычки.

Двойные кавычки в Bash следует использовать в следующих случаях:

1. При обращении к переменным, содержащим пробелы или специальные символы. Например, если есть
переменная $my_var, которая содержит значение "hello world", то для безопасного обращения к этой
переменной следует использовать двойные кавычки: echo "$my_var".

2. При использовании переменных внутри строк. Например, если нужно объединить значение переменной с
другой строкой, то это можно сделать так: echo "Value is: $my_var".

3. При передаче аргументов командам. Например, если есть скрипт script.sh, который принимает
аргументы, то передача аргументов с пробелами должна быть в двойных кавычках: ./script.sh "arg1 arg2".

wav_path=/usr/share/sounds/for-deb-builder/prompt.wav
Двойные кавычки необязательны для данной строки, так как она не содержит специальных символов
(пробелы, обратные кавычки, обратный слэш и т. д.). Однако, использование двойных кавычек для такой
строки не вызовет ошибки и может являться хорошей практикой для повышения читаемости кода.

Для регулярных выражений лучше использовать одинарные кавычки ' '


--- /bin/sh
Часто можно заметить, что в проектах используют не /bin/bash, а /bin/sh, почему ? он же старый!

Скрипты, написанные на /bin/sh, обычно используются для максимальной переносимости между различными
Unix-подобными операционными системами. Шелл /bin/sh представляет собой стандартный оболочку
командной строки в Unix-подобных системах, которая должна быть доступна на всех таких системах.

В то время как /bin/bash (Bourne-Again SHell) является расширенной оболочкой командной строки,
которая предоставляет больше функций, чем /bin/sh. Она представляет собой улучшенную версию
стандартной оболочки /bin/sh, что делает ее более мощной и удобной для использования. Когда скрипт
написан на /bin/sh, он чаще всего будет работать на всех Unix-подобных системах, исключая
специфичные возможности, предоставляемые /bin/bash. Но если в скрипте используются уникальные
функции /bin/bash, то он может не работать на системах, где /bin/bash не является стандартной
оболочкой. Поэтому использование /bin/sh в некоторых проектах может быть обусловлено требованием
максимальной переносимости скрипта между различными Unix-подобными системами.
