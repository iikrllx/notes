Темы:
* Стандартная библиотека Си (libc)
* Библиотека glibc
* POSIX
* Состав POSIX
* Заголовочные файлы ANSI
* Заголовочные файлы POSIX
* Функция main
* Ключевое слово void
* Работа с float числами
* Строки
* Кавычки
* Условное выражние
* Циклы
* Базовые типы данных
* Преобразование типов
* Объединение условий
* Эскейп-последовательности
* Директивы пре-процессора #include и #define
* Операторы и операции инкрементирования, декрментирования
* Оператор возведения в степень и '%'
* Указатели
* Статические переменные (внутренняя связь)
* Ключевое слово extern (внешняя связь)
* Генерация случайных чисел
* Массивы
* Структурный тип данных struct
* Выражения
* Ключевое слово typedef
* Ключевое слово const

"В Си ничего не контролируется автоматически, программист должен понимать что делает."
"Программист и алгоритмист разные вещи."


--- Стандартная библиотека Си (libc)
Стандартная библиотека языка Си (известная как libc)
часть стандарта ANSI C (стандарт языка Си) посвещенная заголовочным файлам.

Си делится на ANSI(основные заголовки) и POSIX(дополнительные заголовки).

Имя и характеристика каждой функции указывается в файле, именуемом загаловочном файле.
Но сама реализация этой функции описана в отдельном библиотечном файле.


--- Библиотека glibc
glibc и libc это разные стадии развития GNU C Library (fork) glibc ушла вперед по развитию,
содержит много новых функциональностей, libc это просто стандарт, который проверен временем.
glibc считается стандартной библиотекой Си и оберткой над сусколами. Например, библиотечная
функция getrlimit() исходит от glibc и при отладке можно заметить оберточную функцию getrlimit64().


--- POSIX
POSIX (позикс) - переносимый интерфейс операционных систем - набор стандартов, описывающих
интерфейсы между операционной системой и прикладной программой (API), так же библиотеку языка Си и
набор приложений и их интерфейсов.

Стандарт создан для обеспечения совместимости различных UNIX-подобных операционных систем
и переносимости прикладных программ на уровне исходного кода, но может быть использован и для
не-Unix систем.


--- Состав POSIX
* Основные определения (англ. Base definitions) - список основных определений и
соглашений, используемых в спецификациях, и список заголовочных файлов языка Си,
которые должны быть предоставлены соответствующей стандарту системой.
* Оболочка и утилиты (англ. Shell and utilities) - описание утилит и командной оболочки sh,
стандарты регулярных выражений.
* Системные интерфейсы (англ. System interfaces) - список системных вызовов языка Си.
* Обоснование (англ. Rationale) - объяснение принципов, используемых в стандарте.


--- Заголовочные файлы ANSI
https://ru.wikipedia.org/wiki/Стандартная_библиотека_языка_Си


--- Заголовочные файлы POSIX
В этом стандарте есть много улучшенных моментов и всё что связанно с
read / write / stat / fork и т.д находится здесь. Например:
https://ru.wikipedia.org/wiki/C_POSIX_library
sys/types - различные типы данных
sys/wait  - статус завершения дочерних процессов
sys/stat  - информация о файле
fcntl     - открытие и вывод файлов open
dirent    - открытие и вывод каталогов
unistd    - основные функции и константы POSIX - read, write, close и другие


--- Функция main
Адрес любой функции в Си можно узнать!

Аргумент argc типа integer содержит в себе кол-во аргументов командной строки
переводится как argument count, никогда не принимает отрицательные значения.

`char *argv[]` и `**argv` это одно и тоже.
`char *argv[]` содержит указатели на строки, каждый элемент массива
указывает на аргументы командной строки, переводится как `argument vector`.

Аргументы, это то, с чем обращаются к функции. Параметры, можно рассматривать как
инициализированные локальные переменные.

argv[0] - полное имя запущенной программы
argv[1] - первый аргумент
Через эти параметры передаются входные данные.

По умолчанию `argc` равен 1, а `argv[0]` возвращает имя файла.

Функция `main()` возвращает целочисленное значение, в случае успех это 0 в случае ошибки это другое
иное число и в shell можно будет посмотреть `echo $?` и увидеть этот код, например если `main()`
вернет -1, в shell будет число 255.

Есть еще дополнительный аргумент: `char **envp`
Это массив указателей на переменные среды.

`argv` и `envp` завершаются `0x0` указателем.
Массив строк заканчивается переменной `argv[argc]`, содержащий пустой указатель.

`envp` содержит окружение и `environ`, но `environ` отображает еще и значения, которые реализуются с
помощью `setenv()`, `putenv()` и другие, а envp - нет.

Чтобы работать с `environ` нужно объявить в коде `extern **environ;`

Для работы с `envp`, необходимо объявить:
int main(int argc, char **argv, char **envp)

while (*envp)
	printf("%s\n", *envp++);

Если ничего не передавать программе (аргументы):
>>> print argv[0]
$7 = 0x7fffffffe3c4 "/home/<user>/main/zone/a.out"
>>> print argv[1]
$8 = 0x0
>>> print argv[2]
$9 = 0x7fffffffe3df "SHELL=/bin/bash"

Можно наблюдать, что `argv[2]` равен `envp[0]`, (один и тот же адрес).
Мы вышли за границы, поэтому так, на самом деле они очень близко расположены.
Если argc будет 0, тогда `argv[1]` будет выходить за границы и смотреть на `envp[0]`.


--- Ключевое слово void
Большинство функций возвращает какое-либо значение, но иногда может понадобиться создать функцию,
которая ничего не возвращает. Для этого используется `void`. Означет пустое значение. Так же бывает
указатель на пустое значение(пустой указатель), нужен для того, чтобы функция например принимала
различные типы данных, а затем преобразовывались в нужный тип.

char c = 'c';
void *p = &c; -> print *p -> Attempt to dereference a generic pointer.
void данные разыменовать не получится.

В указатель `void` можно вписать любой тип данных адрес -> `*p = &c`;
А затем уже его явно преобразовать: printf("%c\n", *(char *)p);
`*(char *) void` указатель нужен редко, но есть случаи, когда можно анализировать данные указателя,
чтобы затем преобразовать в нужный тип.


--- Работа с float числами
Нужно 1 разделить на 10 и получить 0.1
int n = 1 / 10;   /* получим целое число 0 */
float n = 1 / 10; /* получим десятичное число, но неверное 0.000000 */
float n = 1.0f / 10.0f; /* получим десятичное верное 0.100000 */
float n = 1.0 / 10.0;   /* получим десятичное верное 0.100000 */
printf("%.1f", n); /* форматируем и выводим 0.1 */


--- Строки
Си низкоуровневый язык и он не имеет подержки строк. Поэтому используют массив символов вместо
строк. То есть строка представляет собой массив символов, последний элемент которого является
нулевым символом таблицы ASCII, обозначенным по '\0'. Целочисленное значение символа - '\0' равно
нулю.  arr[i] != '\0' и arr[i] != '0' -> одно и тоже


--- Кавычки
Отдельные символы заключается в одинарные -> '\n'
Строки в двойные -> "Hello"


--- Условное выражние
(логич_выражение) ? выражение1 : выражение2
Если `логич_выражение` вернуло истину, то все выражение возвращает `выражение1`; если
`логич_выражение` вернуло ложь, то все выражение возвращает `выражение2`.  Такое условное выражение
используется только с простыми конструкциями.


--- Циклы
int counter = 1;
while (counter < 11) {
  printf("%i бутылок висело на стене\n", counter);
  counter++;
}

Цикл `do-while` отличается от цикла `while` тем, что его
тело будет выполнено хотя бы один раз независимо от условия
выполнения цикла.
do {
  puts("Hello");
  puts("Bye");
} while(2 < 1);

С циклами можно использовать `break` и `continue`.
break - прерывает
continue - возвращается к началу цикла

Цикла `for` устроен таким образом:
for (инициализация; условие выполнения цикла; выражение)


--- Базовые типы данных
Имеет два основных типа: целое и символ -> `int`, `char`, в качестве булеона
используется `stdbool.h` (1 - true, 0 - false) в качесте вещественных используют `float`, `double`.

Типы различаются между собой объемом памяти, отводимых под переменную.
Размеры объектов указанных типов зависит от машины.

Например, если под целочисленную переменную выделяется 2 байта = 16 бит
означает только положительный ввод чисел от 0 до 65535. т.к 2 в 16 степени.
А если можно вводить отрицательные числа, то в диапозоне от -32768 до 32767.

В Си символы - это числа, а числа - это символы. В Си нет строкового типа
данных, но есть спецификатор `%s`.

Один байт содержит 256 возможных значений (от 0 до 255)
128 + 64 + 32 + 16 + 8 + 4 + 2 + 1
Например, 255 = 11111111
То есть, в одном байте значений может быть:
от 00000000 до 11111111 в двоичной системе
или это означает от 0 до 255 в десятичной системе

И это не означает, что в 1 байте можно хранить 256 чисел - нет!
Число одно, а значений у него 255.

char          - 1 байт, диапозон чисел -128 / 127
signed char   - 1 байт, диапозон чисел -128 / 127
unsigned char - 1 байт, диапозон чисел 0 / 255 включительно!
                от 00000000 до 11111111

short         - короткое целое, 2 байта, диапозон чисел -32768 / 32767
int           - целое число, 4 байта, -2147483648 / 2147483647
long          - длинное целое, 8 байт, диапозоны очень большие

unsigned      - целое положительное (без отрицательных), 4 байта кол-во положительных увеличено
                важно понимать что все unsigned типы начинаются с 0 и заканчиваются <n>
float         - число с плавающей точкой, 4 байта
double        - с плавающей точкой с двойной точностью, 8 байт

Важно понимать, что базовые типы данных (размеры) зависят от платформы, компиляторов и `int` не
всегда будет равен 4 байт, и `char` не всегда будет равен 8 бит (может и больше) их размер зависет
от реализации, поэтому есть "Типы фиксированной длины" <inttypes.h> / <stdint.h> Например: `uint8_t`
будет вкладывать в себя только 8 бит (строго), не больше, не меньше, `uint32_t` и другие работают по
такой же логики, можно посмотреть здесь: https://en.cppreference.com/w/c/types/integer


--- Преобразование типов
Пример преобразование типа `int` в тип `float`
int a;
float x;
a = 2;

x = ((float) a); // 2.0000000

Существует явное преобразование типов `(int)c`; и неявное преобразование
(происходит автоматические преобразование, если типы не соответствуют друг другу).


--- Объединение условий
if (() && ()) {}
if (() || ()) {}
if(!value)

Приоритет `&&` выше чем у `||`.


--- Эскейп-последовательности
\n - новая строка
\t - табуляция
\r - перевод курсора в первую позицию текущей строки
\b - убирает последний символ
\" - двойная кавычка
\\ - обратный слеш
\0 - пустота, символ с кодом 0 по таблице ASCII


--- Символ % - спецификаторы формата
Строка символов, в которой каждый символ `%` соответствует одному из последующих аргументов,
а информация после `%` указывает на вид. Например `%d` - это выдача аргумента в виде целого
десятичного числа. Каждому спецификатору, соответсвтует кол-во аргументов, в противном случае
напечатано будет не то, что нужно.

Ширина поля можно добавить как (будут добавлены поля отступов):
Так же можно использовать отрицательные числа.
printf("%3d %6d", value);

%d  - десятичное число со знаком
%i  - десятичное число со знаком
%f  - число с плавающей точкой, применяется -> float/double
%g  - тоже самое что и %f только усеченный
%e  - вещественное число
%ld - long + десятичное число со знаком
%lu - long + десятичное число без знака
%hd - вывод типа short
%c  - символ
%%  - символ %
%p  - адрес указателя


--- Директивы пре-процессора #include и #define
#include <stdio.h>

Директива включает файл `stdio.h` на этапе компиляции, он содержит все определения необходимые
программе в процессе работы, обычно все операторы `#include` размещаются в начале программы.

#define имя_макроса последовательность_символов
#define TRUE 1 // именованная константа
printf("%d", TRUE);

Макросы полезны когда когда один и тот же код повторяется много раз и чтобы не дублировать его можно
написать макрос и использовать его везде. Это делается чтобы не заводить отдельную функцию.
В макросах можно даже писать условное выражание с параметрами и обращаться к ней.
#define FOR for(i = 0; i <= n; i++)
#define SCORE(a,b) (a) > (b) ? (a) - (b) : (b) - (a)

Чтобы писать длинные макросы:
#define LIST_FOREACH(curr, list) \
	ListNode *curr = list->first;\
    for (ListNode *_node = list->first; \
         _node != NULL; \
         curr = _node = _node->next)

Вот пример макроса с вызовами функций:
#define END_CLEAR_REFRESH endwin(); clear(); refresh();


--- Операторы и операции инкрементирования, декрментирования
++ увеличивает на единицу (инкремент)
-- уменьшает на единицу   (декремент)

value += 3
value++ прибавит 1
value = value + 1 эквивалентно

Переменная сразу изменится
++nc - префиксный оператор (сначало)

Используется как есть, и только потом увеличивается на единицу
nc++ - постфиксный оператор (потом)

Разницу можно заметить здесь:
printf("%d\n", a++); // 0
printf("%d\n", ++b); // 1
printf("%d - %d", a, b); // 1 - 1

Можно вместо:
if (c == '\n') {
  s[i] = c;
  i++;
}

Написать так:
if (c == '\n')
  s[i++] = c;


--- Оператор возведения в степень и '%'
В Си нет оператора возведения в степень `**`
поэтому приходится писать функции в ручную. Либо использовать
функцию `pow(x, y)` с помощью заголовка `math.h`.

`%` используется для вычета остатка после деления целых чисел.


--- Указатели
Переменная - это область памяти, к которой мы обращаемся за находящимися там данными, используя
идентификатор. При этом у этой области помеченной именем области есть еще и адрес, выраженный числом
и понятный компьютерной системе. Этот адрес можно получить и записать в особую переменную.
Переменную, содержащую адрес области памяти, называют указателем.

Указатель - это переменная, содержащая адрес другой переменной. Память типичной машины представляет
собой массив последовательно пронумерованных или проадресованных ячеек, с которыми можно работать по
отдельности. Например, один байт может хранить значение типа char. Ячейки памяти от программиста
уже скрыты указателями, для удобства.

Указатели говорят где хранится что либо в памяти, это не значение.

Все операции, которые выполняются с переменными, могут выполняться с указателями. Например,
присваивание, разыменование, получение адреса указателя, операции сравнения, приведения типов.

*p = 12;
Разыменование = запись в ячейку.

int *pi     - звучит как указатель на целое число
int *b[10]  - звучит как массив указателей на 10 целых чисел
char *p[10] - указатель на массив элементов, каждый из которых представляет указатель на строку
print p -> p {[0] = 0x555555556004 "a", [1] = 0x555555556006 "b"};

Как получить адрес переменной в памяти - ячейка памяти:
int i = 0;
printf("i=%d, &i=%p \n", i, &i);

Указатели в языке Си, как и другие переменные, являются типизированными.
Чтобя объявить указатель нужно указать символ `*` Например: int *pi; float *pf;

Под указатели всех типов выделяется одинаковый объем памяти, размер
адреса не зависит от типа. Выделяется 8 байт.

Проверка что вернет 8:
int *pi;
printf("%d\n", sizeof(pi));

Если указатель объявлен и не определен, то он будет ссылаться на произвольный участок памяти с
неизвестно каким значением:
int *a; printf("%p", a); // может вернуть nil -> NULL

Если попробовать извлечь значение из памяти с помощью указателя, который никуда не ссылается, то
возникает "ошибка сегментирования".

Унарные операторы: `*`, `&` имеют более высокийи приоритет, чем арифметические операторы, так что:
`++*ip` (увеличивает на единицу то, на что указывает ip. А здесь нужны скобки `(*ip)++`. Потому что
без скобок, будет увеличен сам адрес, а не то что внутри.

Разыменование указателя: `*p` (получение значения из ячейки).

Можно не использовать унарные операторы доступа, если `iq` и `ip` являются указателями: `iq = ip`
(копирует содержимое `ip` в `iq`, чтобы `ip` и `iq` указывали на один и тот же объект.

Массивы и указатели тесно связаны с друг другом. Любой доступ к элементу массива, осуществляемый
операцией индексирования, может быть выполнен с помощью указателя.

Объявление `int a[10];` Определяем массив размера 10. т.е. БЛОК из 10
последовательных объектов с именами a[0], a[1] ...

Адрес не зависим от того на что он указывает (его размер и длина).
Адрес это просто адрес. Если указатель равен `char *p = "Hello";`
Затем происходит смещение адреса `p++` (эта запись означает, что смещение происходит на 1 байт,
так как тип данных `char`, если бы был `int`, адрес смещался на 4 байта.
(print 0x7fffffffdfa0 - 0x7fffffffdf9c -> 4)


--- Статические переменные (внутренняя связь)
Данное слово говорит компоновщику, что данное объявление нельзя использовать в роли глобальной
переменной, а только в роли локальной.

Эти переменные нужны для того чтобы не выставлять наружу ничего лишнего, то есть в других файлах
значения этих переменных будет не доступно. Антоним этого слова является extern (внешняя связь).

Иногда можно заметить что в функции объявляется локальная статическая переменная, а зачем ?
`static int = 0;` локальная статическая переменная

То есть при следующих вызовах данной функции, данная переменная будет работать с тем значением, с
которым работало в последний раз. Вот пример:

void abc()
{
	static int i = 0;
	i++;
	printf("%d\n", i);
}

abc(); // 1
abc(); // 2


--- Ключевое слово extern (внешняя связь)
Данное слово говорит компоновщику, что где-то есть такое-то определение. Объявление глобальной
переменной реализуется с помощью `extern`. `extern` ОБЪЯВЛЯЕТ ПЕРЕМЕННУЮ, НО НЕ ОПРЕДЕЛЯЕТ ЕЁ.
Например в файле 1 `extern int x;` А во втором файле просто `int x;`. `extern` реализует ОБЪЯВЛЕНИЕ,
но не определение он говорит компилятору, что само ОПРЕДЕЛЕНИЕ происходит где-то в другом месте программы.

Когда мы пишем в программе:
int foo(int arg1, char arg2);

Компилятор рассматривает эту строку как:
extern int foo(int arg1, char arg2);

Ибо мы можем вызывать `foo` в любом файле программы.
Потому что это ОБЪЯВЛЕНИЕ ФУНКЦИИ.

Данная программа будет выдавать ошибку, потому что в первой строке идет объявление, но не
определение, а в 4 строке идет присваивание непонятной переменной, ибо мы её не определили.
1:extern int var;
2:int main()
3:{
4:  var = 10;
5:  return 0;
6:}

Если добавить файл `#inlude "headers.h"` в котором будет определен `int var;`,
то всё будет работать без ошибок.

Если определить сразу на месте строкой `extern int var = 0;` а в функции
изменить значение на `var = 10;` то будет работать без ошибок.

int x; // является как объявлением так и определением, потому что
мы запрашиваем у компьютера 2 байта на переменную
int x = 3; // является определением переменной


--- Генерация случайных чисел
Для генерации случайных чисел используется `rand()`
Возвращает от 0 до `RAND_MAX`, которая указана в `stdlib.h`.
Генерирует числа на основе базы, если базу не менять, последовательность
псевдослучайных чисел будет одна и та же.

Для генерации псевдослучайных используется `srand()` ее аргумент и есть значение базы.

Текущее время можно получиить с помощью функии `time()`. Передав `time()` в качестве параметра
`NULL`, мы получим целое число, которое можно передавать `srand()`. Сочетание `srand(time(NULL))`
устанавливает в качестве базы текущее время.

`rand() % 5` вывод от 1 до 4
Допустим `rand()` выдает число 283 остаток от числа 5 это 3,
значит число 3 будет в выводе

`rand() % 5 + 1` от 1 до 5


--- Массивы
Переменная - один ящик.
Массив - несколько пронумерованных ящиков.

Имя массива - это указатель на адрес его первого элемента. Из этого следует что имя массива - это
ничто иное, как указатель.

Если массив автоматический, то будет присвоен различный мусор и при выводе
он будет заметен, случайные числа и т.д. Автоматический это `char arr[5];`.

Если массив проинициализирован при объявлении вот так:
`int arr[] = {2, 3, 4};` То кол-во элементов в квадратных скобках может быть опущено.

Часто массив объявляется без инициализации элементов, тогда кол-во элементов
нужно указать `int arr[5];`.

Длина массива - это общее кол-во байт - суммарный размер массива.
Бывают одномерный массивы и многомерные, а также статические и динамические.

Одномерный массив - 1D array
Двумерный массив  - 2D array

Это одномерный / статический массив:
int arr[5] = {1, 2, 3, 4, 5};

Статический массив - размер массива должен быть известен заранее. А в динамическом массиве
происходит выделение памяти на нужное кол-во элементов и используются функции malloc() и free(),
для выделение и освобождение памяти.

В массиве нет возможности понять заполненные данные от незаполненных.
А sizeof() будет возвращать сумму типов, но не заполненных данных.
Удалить элемент из массива невозможно. Можно перезаписать в 0 или уменьшить индекс.

Две основные операции `push` и `pop`:
`push` добавление элемента в начало и `index++`.
`pop` уменьшить индекс и вернуть текущее состояние.

Массив можно отсортировать в виде убывания или возрастания.


--- Структурный тип данных struct
Структура позволяет объединить взаимосвязанные данные. Объявив структуру мы можем обращаться к
каждому элементу этой структуры. Структуру можно присвоить другой структуре. Структуры можно
передавать в качестве аргумента функции и возвращать структуру назад. Структуры передаются по
значению, как обычные переменные, а не по ссылке, как массив.

Иногда размер значений может быть большим и это может замедлить работу программы, поэтому структуру
лучше передавать по ссылке, использовать либо указатель либо по адресу. Если мы определили структуру
как указатель обращаться к элементам можно как (*new).title либо new -> title (указатель -> структура)

Объявление новый структуры данных происходит так:
struct book {
  char title[50];
  char author[20];
  int pages;
};

// Переменная для обращения к структуре
struct book mybook;
mybook.pages = 2;

// Указатель для обращение к структуре
struct book *p;
p->pages = 2;


--- Выражения
Создаются путем объединения операторов и операндов.
a == b
a и b - это операнды
==    - это оператор


--- Ключевое слово typedef
Это нужно для более понятного обозначения в коде.
Здесь не создается новый тип данных, а обозначается существующий.

typedef int new_int;
new_int = 2;
printf("%d\n", new_int);


--- Ключевое слово const
Значение "только для чтения" данные константы (неизменяемы).

А что такое реальная константа.
Последовательность символов алфавита языка - фиксированное (неизменяемое)
Константы бывают числовые, символьные и строковые.
Числовые: последовательность цифр 0-9 либо 071 либо 0x0 и т.д.
либо 324,8 или символьные константы '\0' '\n' или строковые "Привет мир".

char const *s = "h";
*s = "q"; // Ошибка

const char *q = "o";
*q = "z"; // Ошибка

const char *s = malloc(1024);
strcpy(s, "c"); // Ошибка
