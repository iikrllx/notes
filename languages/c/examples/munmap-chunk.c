int main(void)
{
  char *s = malloc(512 * sizeof(char));
  if (s == NULL)
    abort();

  strcpy(s, "Hello dear world!");

  while (*s != '\0') {
    printf("%c\n", *s);
    s++;
  }

  free(s); // munmap_chunk()
  /* Потому что указатель изменился (его адрес)
     Каждую итерацию идет сдвиг на следующее значение
     Из-за этого адрес меняется, например был 0x5555555592a0
     После инкремента, идет значение 0x5555555592a1 ибо строка
     имеет вид ello dear world! */

  /* Можно было сделать перебор так:
     for (int i = 0; s[i] != '\0'; i++) {}
     И затем free() */

  // Вот еще один пример:
  char *ss = malloc(512 * sizeof(char));
  if (ss == NULL)
    abort();

  strcpy(ss, "Hello dear world!");

  char *p;
  for (p = ss; *p != '\0'; p++) {
    printf("%c\n", *p);
  }

  free(ss);

  /* Указатель 'p' изменяется адрес, а 'ss' нет */

  return 0;
}

/*
Есть один нюанс, если передать указатель в функцию, и там перебрать его,
инкрементируя адрес s++; затем free() сработает без ошибок (из функции main),
потому что у функции его параметры это тоже самое, что и char *p = s;
*/
