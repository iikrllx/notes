/*
Мьютексы позволяют потокам синхронизировать использование общих ресурсов, чтобы,
к примеру, один поток не пытался получить доступ к разделяемой переменной в момент,
когда другой поток изменяет ее значение. Условные переменные дополняют это решение,
позволяя потокам оповещать друг друга о том, что разделяемая переменная (или другой общий ресурс)
изменила свое состояние.

Потоки работают тоже по временным интервалом, которым присваивает планировщик задач.
Временной отрезок, отведенный планировщиком для потока 1, исчерпывается, после
чего начинает выполнение поток 2. Второй поток работает больше, чем 1 поток (допустим).
А затем 1 может работать больше чем 2, это поведение непредскауземо. Такое непредсказуемое
поведение является результатом причудливой работы планировщика ядра. В сложных программах
подобные ошибки возникают редко и их бывает сложно воспроизвести - а значит, сложно найти.

Чтобы избежать проблем, которые возникают при попытке обновления разделяемой переменной из
разных потоков, следует использовать мьютекс (отmutual exclusion - «взаимное исключение»);
это позволит гарантировать, что только один поток имеет доступ к переменной в определенный
промежуток времени. В целом мьютексы можно использовать для обеспечения атомарного доступа
к любым разделяемым ресурсам, но чаще всего они применяются для защиты общих переменных.

Мьютекс имеет два состояния: закрытое (блокированное) и открытое (разблокированное).
*/

static int glob = 0;

static void *threadFunc(void *arg)
{
	int loops = *((int *) arg);
	int loc, j, s;

	for (j = 0; j < loops; j++) {
		loc = glob;
		loc++;
		glob = loc;
	}

	return NULL;
}

int main(int argc, char **argv)
{
	pthread_t t1, t2;
	int loops, s;
	loops = 10000;

	s = pthread_create(&t1, NULL, threadFunc, &loops);
	if (s != 0) abort();

	s = pthread_create(&t2, NULL, threadFunc, &loops);
	if (s != 0) abort();

	s = pthread_join(t1, NULL);
	if (s != 0) abort();

	s = pthread_join(t2, NULL);
	if (s != 0) abort();

	printf("glob = %d\n", glob);
	exit(EXIT_SUCCESS);
}
