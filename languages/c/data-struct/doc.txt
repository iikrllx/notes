Темы:
* Что такое структуры данных
* Массив (буфер)
* Список
* Стек (LIFO)
* Очередь (FIFO)
* Бинарное дерево
* Куча
* Хеш-таблица
* Какую структуру данных выбрать
* Линейные и нелинейные
* Хеширование данных
* Итого - коротко


--- Что такое структуры данных
Это способ эффективного (память, время) хранения и организации данных.
Структура данных используется для уменьшения сложности кода.

Структуры данных бывают:
* Статическая структура данных (размер уже заранее известен)
* Динамическая структура данных (например, связный список, размер структуры не
  фиксирован и может быть изменен во время работы программы - run time)

Статическая структура данных легче обращаться к элементам, динамическая же
наоборот, но зато динамическая структура более гибкая, чем статическая.

Для динамических данных память выделяется и освобождается в процессе выполнения
программы, а если в программе объявлен массив из 100 элементов, то память будет
зарезервированна для всех ста элементов, даже если используется 10,
а для динамической памяти заранее не выделится, только по мере необходимости,
можно ввести переменные - указатели и при выделении памяти записывать адрес этой
памяти в указатели. Много памяти выделяется в пустую, чтобы обойти это,
может понадобиться создать динамический тип данных - стек (наиболее простой).


--- Массив (буфер)
Это линейно упорядоченная совокупность однотипных элементов. Массив определяется
типом элементов (int, double, etc) и длиной. Доступ к элементам осуществляется
по индексу.

Существуют статические массивы (в которых уже известна длина массива на время
компиляции) и динамические (размер которых задается в процессе выполнения
программы, то есть может зависеть от входных данных).

В статическом массиве невозможно добавить еще один элемент, или удалить элемент.
Статический массив привязан к кол-ву элементов.

Динамический массив лучше всего работает при добавлении элемента в конец, а не в
середину. Если нужно в середину, то для этого подойдет более подходящий тип
структуры.

Динамический массив может менять кол-во элементов, делать вставку, удаление,
переносить элементы на соседние места, тем самым увеличивая кол-во. Поскольку
необходимо перемещать каждый объект после точки вставки, то наилучшим случаем
будет добавление элемента к концу массива. Удаление тоже эффективнее делать с
конца. Допустим:

sometype *internalArray;
unsigned int currentLength;
unsigned int maxCapacity;

Чтобы получить длину массива, можно разделить его размер на размер одного из
элементов. Имя массива является указателем на его начальный элемент (с индексом 0)

Новички пишут так:
// Таблица рекордов
int score1 = 0;
int score2 = 0;
int score3 = 0;
int score4 = 0;
int score5 = 0;

Это неплохо, но если понадобится 50 значений, тогда:
// Таблица рекордов
const int NUM_HIGH_SCORES = 50;
int highScore[NUM_HIGH_SCORES] = {0};


--- Список элементов
Пример использования: Передача пакетов по сети.

Связанный список является простейшем типом данных динамической структуры,
состоящей из элементов (узлов). Каждый узел включает в себя данные и указатель
на следующей узел в списке, заканчивается список NULL. Бывают односвязные
списки, двусвязные.

Добавление объекта к списку начинается с создания нового узла. Данные копируются
внутрь узла. Затем находится точка вставки. Указатель нового узла на следующий
объект изменяется так, чтобы указывать на следующий за ним узел. Наконец, узел
перед новым узлом изменяет свой указатель, чтобы указывать на новый узел.

При удалении объекта из связанного списка находится узел перед удаляемым узлом.
Он изменяется таким образом, чтобы указывать на следующий после удалённого
объекта узел. После этого удалённый объект можно безопасно стереть.

Основные операции: ДОБАВЛЕНИЕ, УДАЛЕНИЕ и ПОИСК элемента в списке (обход).


--- Стек (LIFO)
Подобен списку элементов.
Пример использования: Назад/Вперед в браузере, Записи активации вызовов функций.

Базовая структура данных, которая позволяет добавлять или удалять элементы
только в её начале (с вершины). Стопка тарелок, чтобы взять 3 тарелку, нужно
снять первые две тарелки (верхние элементы)

Стек можно реализовать в виде:
* одномерный массив
* связанный список

Основные операции: ДОБАВЛЕНИЕ элемента (push) в конец,
УДАЛЕНИЕ элемента (pop) с конца.


--- Очередь (FIFO)
Подобен списку элементов.
Пример использования: Очередь принтера, Входной поток.

Как и Стек, очередь представляет собой линейную структуру, которая следует
определенному порядку выполнения операций. Покупатели в магазине, есть очередь
из покупателей, а есть касса, которая их обслуживает по мере поступления.

Очередь можно реализовать в виде:
* одномерный массив
* связанный список

Основные операции: ДОБАВЛЯТЬ элементы в конец очереди (enqueue)
и УДАЛЯТЬ первый элемент (dequeue).


--- Бинарное дерево
Пример использования: FHS, Файловая система.

Иерархическая структура данных.
Наивысший элемент называется (root of the tree)
Элементы, которые ниже root, называются "дочерние элементы"
Элемент, который над другим элементом, называется "родительский элемент"
Элементы, которые не имееют дочерних элементов, называются "листья"

Бинарное дерево можно реализовать в виде:
* связанный список

              tree
            --------
                j       <-- root
              /   \
             f     k
            / \     \
           a   h     z   <-- leaves (листья)

Деревья у которых есть только 1 дочерний элемент, по производительности
тоже самое что и связанный список.

      10
      /
    20
     \
     30
      \
      40

Основные операции: СОЗДАНИЕ узла, ДОБАВЛЕНИЕ узла, УДАЛЕНИЕ узла, ПОИСК.


--- Куча
То же самое, что и дерево. Но не обладает его недостатками. При добавлении или
удалении объектов из кучи структура сортирует себя. Кучи бывают двух видов - те,
где значения корневых узлов меньше и те, где значения больше, чем у дочерних.
Массив представляется в виде дерева, находится левый элемент и правый.

Куча можно реализовать в виде:
* одномерный массив

Основные операции: ДОБАВЛЕНИЕ узла (с сортировкой), УДАЛЕНИЕ узла (с сортировкой),
ПОИСК (минимального или максимального значения).


--- Хеш-таблица
Хеш-таблица - это просто массив связанных списков с функцией хеширования.
Называется еще ассоциативный массив. Хеш-функция принимает ключ и возвращает
индекс значения в массиве.

Содержит пары ключ-значение. Она использует хеш-функцию для вычисления индекса в
массиве из блоков данных, чтобы найти желаемое значение. Например, размер
хеш-таблицы 20, высчитывается это так: `key % 20` -> index. Если под данным
индексом что-то есть, значит делается index++ и пишутся данные.
Например: 0 ~, 1 data, 2 ~, 3 ~, 4 ~, 5 data, 6 data, 7 ~, 8 data.

Основные операции: ДОБАВЛЕНИЕ, УДАЛЕНИЕ, ПОИСК.


--- Какую структуру данных выбрать
Обычно нас не волнует порядок, в котором находится набор, мы просто начинаем с
начала и посещаем каждый элемент. В этой очень частой ситуации выбор структуры
данных на самом деле не важен.

Если возникают сомнения, то наилучшим выбором обычно является динамический
массив. Он может разрастаться до любого объёма, при этом он относительно
нейтрален, что позволяет довольно просто заменить его позже на другую структуру
данных. Но иногда структура очень важна.


--- Линейные и нелинейные структуры данных
В линейных структурах элементы расположены как бы «по цепочке», друг за другом
(соседи). Они выстраиваются в последовательность. К линейным структурам можно
отнести: массивы, очереди, стеки, линейные списки.

В нелинейных элементы могут ветвиться, образовывать таблицы или схемы.
Нелинейные структуры, это более сложные отношения между соседями, графы,
деревья, куча, хеш-таблица.


--- Хеширование данных
Хеширование - это преобразование информации с помощью особых математических
формул. Хеш-функций существует очень много, они различаются методами вычислений,
назначением, надежностью и другими параметрами. Коммиты в гите идентифицируются
по хешу. Пароли на сервере хранятся в виде хеша. Хеш-функции могут быть
реализованы простым способом хеширования. А для ИБ эти функции должны быть
криптостойкими.

Например, "my password" -> 83164be3a3d308014e86b52f9ab0996c

Хеширование используется для защиты паролей в тех случаях, когда они хранятся в
базе данных. Вместо хранения исходного пароля в открытом виде в базе данных,
хранится только его хеш-значение.


--- Коротко
Массивы:
  * Более быстрый доступ к элементам по определенному индексу (быстрый доступ)
  * Вставка / удаление обходится дорого и долго
  * Локализация кэша, что дает больше производительности

Массивы очень быстры при произвольном доступе и имеют относительно неплохую
производительность при добавлении и удалении из конца.

Списки:
  * Не так легко получить нужный элемент (нужно пройти весь список - долгий доступ)
    То есть обращение элемента начиная с первого узла
  * Вставка/удаление просто и быстро
  * На обход и изменение указателей уходит больше времени

Связанный список очень хорош при частом добавлении и удалении из середины.

Стек и очередь:
Они очень эффективны, когда нужно работать только с конечными элементами данных,
а серединные элементы не важны.

Дерево:
Обход дерева это долгая операция. Его сложно хранить (занимает много места).
Много узлов = много указателей (запрашивается много страничной памяти).
Дополнительные затраты на хранение множества мелких объектов нарастают очень быстро.

Куча:
Добавление, удаление элементов трудоемко (нужно обходить все дерево + сортировать).
Поиск элемента очень быстро (благодаря кэшу).

Хеш-таблица:
Производительность хеш-таблицы зависит от функции хеширования, размера таблицы и
метода обработки коллизий.
