---
f = fopen(name, "r");
if (!f && name != NULL && name[0] != '/') { ... }

Меня смутило !f, но это означает f == NULL && name != NULL && name[0] != '/'

if (!valid) эквивалентно if (valid == 0)
читается как "если не правильно"


---
sym -> flags (41216)
def_flags (65536)
SYMBOL_CHANGED (1024)
SYMBOL_VALID (128)
SYMBOL_CHOICE (16)

Установка бита
41216 |= 1024
00000000000000001010000100000000
00000000000000000000010000000000
sym->flags |= SYMBOL_CHANGED;
sym->flags будет равен 42240
00000000000000001010010100000000

Зачистка бита
sym->flags &= ~(def_flags|SYMBOL_VALID);
00000000000000001010010100000000
00000000000000001111111101111111
sym->flags будет равно 42240 без изменений

Попытка найти флаг SYMBOL_CHOICE
static inline bool sym_is_choice(struct symbol *sym)
  return sym->flags & SYMBOL_CHOICE ? true : false;

42240 & 16
00000000000000001010010100000000
                           10000

В этом случае, функция sym_is_choice вернет false
потому что флаг найден НЕ БЫЛ, из-за этого условие
ниже не срабатывает, смысл в том, чтобы проверить,
является ли sym выбором (choice)
if (sym_is_choice(sym))
  sym->flags |= def_flags;


---
Хорошая манера определения нового указателя
char *line;
size_t line_asize = 0;

static ssize_t compat_getline(char **lineptr, size_t *n, FILE *stream)
{
  char *line = *lineptr;

}

while (compat_getline(&line, &line_asize, in) != -1) { ... }


---
Почему данное условие проходит?
#define CONFIG_ "CONFIG_"
char *line = "CONFIG_MODULE=y\n";
if (memcmp(line, CONFIG_, strlen(CONFIG_)) == 0)
  puts("good");

strlen(CONFIG_) вернет число 7, соответственно будет
проверено только 7 байтов, а это "CONFIG_" и "CONFIG_"


---
char *line = "CONFIG_MODULES=y\n";
line + strlen("CONFIG_");
Вернет только MODULES=y\n

char *p = strchr(line + strlen("CONFIG_"), '=');
strchr() вернет указатель на строку, где начинается '='
указатель p будет равен "=y\n"

*p++;
означает, что будет переход к следующему символу 'y\n'


---
#define SYMBOL_CONST      0x0001  /* symbol is const */
0x - говорит компилятору, что следующие цифры представляют некое число,
записанное в шестнадцатеричной системе счисления 0x04 / 0x08 и другие
print 0x0001 -> 1


---
if (!strcmp("===", "===")) { "this working" };
Почему данное условие сработает? strcmp() в случае успеха вернет 0
Если написать if (!rval), а rval будет равен 0, тогда условие тоже сработает
Но если написать if (0) { "this is not working "}; это не сработает

if (!(symbol->flags & SYMBOL_CONST))
Если флаг не найден, тогда сделать "что-то", допустим 1010010100000000 & 0001
Флаг не найден, условие сработало.

Сработает
int n = 1; или int n = -2344;
if (n) puts("he");
Если n = 0; не сработает


---
Есть циклы вроде:
for_all_defaults(sym_defconfig_list, prop) {
  ...
}

Так вот for_all_defaults это просто макрос, в условии которого прописано
for (st = sym->prop; st; st = st->next) \
  if (st->type == (tok))

Когда макрос найдет совпадение с tok он остановится, тем самым наш указатель останется
на нужном нам месте и st->next не будет и затем можно будет провести дальнейшие манипуляции
с этим указателем (ведь он нам интересен)


---
int c, state;
while ((c = getchar()) != EOF) {
  if (c == ' ' || c == '\n' || c == '\t')
    state = 1;
  else if (state == 1) {
    state = 0;
    puts("good");
  }
}

Раньше мне казалось, что если выполнится первое условие if, тогда сработает и второе условие else
if, ведь state стал равен 1, но нет, если 'c' будет равен ' ' или '\n' или 't' тогда сработает state
= 1 и всё, программа вернется снова к началу цикла. А вот если в следующей итерации не будет ' '
'\n' '\t' то сработает проверка state == 1, тогда будет puts.


---
int c, ndigit[10];
while ((c = getchar()) != EOF) {
  if (c >= '0' && c <= '9')
    ++ndigit[c - '0'];
}

Если ввести цифру, допустим 5, 'c' будет иметь значение 53 (код символа) и добавлять 53 в массив не
очень правильно, а если сделать c - '0', тогда мы получим значение 5 и в массиве окажется это число.
printf("%d\n", c);       // 53
printf("%d\n", c - '0'); // 5


---
void copy(char to[], char from[])
{
  int i;
  while ((to[i] = from[i]) != '\0')
    i++;
}

Осуществляется запись символов массива from в to


---
if (year % 4 == 0 || year % 400 == 0)
  ...
Если год делится на 4 без остатка или год делится на 400 без остатка
условие сработает, операнд % не применяется к float / double, только к целым.


---
Пример, как работает atoi
int atoi(char s[])
{
  int i, n = 0;
  for (i = 0; s[i] >= '0' && s[i] <= '9'; i++)
    n = 10 * n + (s[i] - '0');
  return n;
}

Из строки "123", получается просто число 123


---
Пример, как работает lower
int lower(int c)
{
  if (c >= 'A' && c <= 'Z')
    return c + 'a' - 'A';
  else
    return c;
}

Допустим функция принимает 'A' (65), не 'a' (97)
65 + 32 = 97 ('a')
97 - 32 = 65 ('A')


---
Ключевое слово goto и обработка ошибки
for (;;) {
  for (;;) {
    if (10 > 0)
      goto error;
  }
}

error:
  puts("wow");


---
int n = -5;
if (n < 0)
  n = -n; // делаем -5 положительным

'n' будет равен '5'

Или -1 * n;


---
Получить последнюю цифру:
int n = 2497;
n = n % 10; // 7


---
Проверка на четность:
if (n % 2 == 0) тогда число четное


---
Умножение:
n = n << 1;


---
Если нужно создать длинное число:
x = 0;
x = 10 * x + new-number;

x = 10 * 0 + 5;
x будет равен 5;
затем:
x = 10 * 5 + 9; // 50 + 9
и так далее


---
Реализация getchar (небуферизированным способом)
int getchar(void)
{
  int c;
  return (read(0, &c, 1) == 1) ? c : EOF;
}


---
Функция может принимать произвольное кол-во аргументов, например
void _main(const char *fmt, ...) { };
Эти аргументы можно будет обработать с помощью va_start / va_arg


---
Есть макросы '_', которые выполняют gettext (перевод на другие языки)
printf(_("capabilities not specified for user\n"));

Выглядит так:
#define _(str) gettext(str)

В проекте можно заметить файлы po/


---
int check()
{
  return 0;
}

if (check())
  puts("good");

Здесь не будет вывода строки "good", но если функция check()
вернет return 1, тогда в выводе будет "good"


---
Пропустить начальные пробелы и затем проверить, что нет пустого символа
char *str = " cap_syslog";

while (isspace((unsigned char)*str))
	str++;

Элегантная проверка на "" (0)
if (!*str)
	return -1;


---
Если передать ~0 тогда получится -1, а -1 в unsigned это 4294967295

void a(int n)
{
	printf("%ld\n", (unsigned)n); /* 4294967295 */
}

a(~0);

Число 4294967295 это просто числовое значение
В бинарном представлении 11111111111111111111111111111111
~ инверсия переставляет все 0 биты в 1, число 0 это 32 нулевых бита
они ставятся все в 1 и получается такое число
$ print /t ~0UL


---
Изменить значение переменной в другой функции
void a(int *b)
{
  *b += 32;
}

int main(void)
{
  int b = 0;
  a(&b);
  printf("%d\n", b); // 32

  return 0;
}


---
Это условие проверяет, является ли файл set bit
if (s.st_mode & S_ISUID)
  puts("yeah");

s.st_mode возвращает значение 33188
а S_ISUID 2048

происходит умножение:
  00000000000000001000000110100100 (33188)
  00000000000000000000100000000000 (2048)

Число 2048 превратится в 0, тем самым:
if (0)
  puts("yeah"); // Условие не сработает

происходит умножение:
  00000000000000001000110110100100 (36260)
  00000000000000000000100000000000 (2048)

if (2048)
  puts("yeah"); // Условие сработает


---
Однобайтная переменная char счетчик, цикл от 0 до 255
С int проблем не будет
unsigned char i = 0;
while (i != 255)
  i++;

цикл будет работать пока переменная i не станет числом 255
когда i станет 255, цикл прекратиться!

или:
unsigned char i;
for (i = 0; i <= 254; i++)
  printf("%d\n", i); // 254
printf("%d\n", i);   // 255

главное не выйти за пределы числа!


---
char *line = "CONFIG_6LOWPAN=m\n";
p = strchr(line + strlen(CONFIG_), '=');

Указатель 'p' будет равен "=m\n"
Первое значение *p равно символу =

Означает, что вместо '=' будет 0 и переход на следующий символ.
*p++ = 0;

p2 = strchr(p, '\n');

Указатель 'p2' будет равен "\n"

Поставит вместо '\n' и уйдет на прошлый символ.
*p-- = 0;

p будет равен 'm' или 'y'


---
int inactive = 1;

if (inactive)
	puts("inactive");

Переменная inactive здесь флаг и ее можно так проверять,
а если нужно проверить, что больше нуля.

int good = 234234;

Так писать не стоит, потому что в переменную good может задаться -10 например.
И условие ниже сработает с отрцитальным значением.
if (good)

Лучше писать так
if (good > 0)


---
$ shred -uz file.txt
optind - индекс последнего значения

char **file;
file = argv + optind;

argv + 2;
file будет равен file.txt

Запись аналогична file = argv[optind];


---
Почему в этом случае нет ошибки ?
warning: function returns address of local variable

Позволяет вернуть локальную переменную.
static char mode[12];

Если объявить как char mode[12];
Тогда будет ошибка.

const char *
a()
{
        static char mode[12];
        strcpy(mode, "hehe");
        return mode;
}

int main(void)
{
        const char *aaa = a();
        return 0;
}


---
Почему возникает ошибка ?
error: storage size of ‘s’ isn’t constant

Массивы работают на этапе компиляции,
а функция strlen возвращает значение.

int len = strlen("string");
static char s[len];

strlen is a function. It's return value cannot be calculated at compile time.


---
Если нам нужно строку "Hello" изменить допустим в tolower, создать указатель 'p'
не получится, потому 'p' является просто char, не const, для этого нужно будет
выделить память и перебрать 's' в 'p', затем уже изменять.

const char *s = "Hello";
char *p = s; // ОШИБКА


---
Строка в число:
char *s = "123";
int n = 0;
n = 10 * n + (s[1] - '0')

s[1] - '0'
означает получить число 2

Число в строку:
int n = 123;
char arr[4];
arr[2] = (n % 10) + '0';
arr[3] = '\0';

(n % 10) + '0'
означает получить символ числа 3

Проверить на целочисленное:
int c = 5;
if (c >= '0' && c <= '9') { ... }

Проверить на alpha:
char c = 'A';
if (c >= 'a' && c <= 'z') { ... }

Возвести в степень:
int n = 2; int x = 6;
for (int i = 1; i < 6; i++)
	n = n << 1;

Пропустить пробелы:
char *s = "  hello";
for (; *s == ' '; s++);

Посчитать длину:
char *s = "Hello";
char *p = s;
for (; (*p); p++);
printf("%d\n", p - s);

Посчитать длину:
char *s = "Hello";
char *p = s;
int length = 0;
for (; (*p); p++, length++);

Про lowercase и uppercase:
'a' 97
'A' 65
'a' - 'A' или 'A' - 'a' будет либо 32 либо -32
Тоже самое и с другими символами 'X' - 'x'

Проверка на uppercase:
if (c >= 'A' && c <= 'Z')

Проверить негативное число:
int num = -5;
int x = num & (1 << (CHAR_BIT * sizeof(num)) - 1);
return (!x) ? -num : num ;

Либо просто if (num > 0)

Нужно сравнивать & число с 1 << 31, потому что происходит отсчет с 0
справа на лево, старший бит будет на 31 позиции числа num.

Можно еще из положительного числа сделать отрицательное так:
int num = 3;
~num + 1; -> -3;
