Темы:
* Что такое LKM
* Вывод информации о модулях (lsmod / modinfo)
* Добавить или удалить модуль (insmod / rmmod)
* Как модули попадают в ядро (kmod)
* Что такое linux-headers
* Что такое встроенные и загружаемые модули
* Функции, которые доступны из модулей
* Драйверы устройств
* block / char, major / minor
* alias
* Системные вызовы
* static
* Процесс в ядре
* Документация
* Что означает, реализовать на всех процессорах ?
* ioctl
* spinlock


--- Что такое LKM
LKM - Loadable kernel module
Файл (.ko), содержащий код, расширяющий возможности ядра ОС. Модули используются чтобы добавить
поддержку нового оборудования или ФС или добавление новых системных вызовов. Без загружаемых модулей
ядра, ОС должны были бы иметь всю возможную функциональность в ядре. Значительная часть кода не
использовалась бы и лишь занимала память. Каждый раз, когда пользователю необходима новая
функциональность, ещё не включенная в базовое ядро, требуется полная перекомпиляция базового ядра и
перезагрузка. А использование подгружаемых модулей значительно упрощает изменение функциональности
ядра и не требует ни полной перекомпиляции, ни перезагрузок.

Модуль ядра - не процесс, он работает в режиме супервизора и в таблице процессов не регистрируется:
это набор подпрограмм для работы с определённым устройством, которые добавляются к возможностям
ядра. При загрузке в память модуль компонуется с ядром, образуя с ним одно целое. При выполнении
системы модуль динамически загружается и становится неотъемлемой частью кода ядра. Этим объясняется
то, что модуль ядра в Linux может быть скомпилирован только под конкретное ядро (обычно по месту
установки), а попытка загрузить такой бинарный модуль с другим ядром приведёт к краху операционной
системы.

Говоря простыми словами:
Модуль - это некий код, который может быть загружен или выгружен ядром по мере необходимости.
Модули расширяют функциональные возможности ядра без необходимости перезагрузки системы.

Код модуля исполняется в пространстве ядра, то есть модуль является частью ядра, значит работает
тоже в адресном пространстве ядра. И если ошибка segfault в обычной программе может с легкостью
быть исправлена, то в модулях такая ошибка может положить всё ядро.

Any hardware device will only work if device driver is loaded.

Модули ядра Linux также используют секции `.text`, `.data`, `.bss`, но `.heap` и `.stack`
относятся к управлению памятью в пользовательском пространстве, а не в пространстве ядра.

- Секция `.text` содержит исполняемый код модуля.
- Секция `.data` содержит инициализированные глобальные и статические переменные.
- Секция `.bss` используется для неинициализированных глобальных и статических переменных,
  которые должны начинаться с нулевого значения.

В контексте модулей ядра управление памятью происходит по-другому, чем в пользовательских
приложениях. Динамическое выделение памяти в ядре осуществляется с помощью функций `kmalloc()`,
`vmalloc()` и других аналогичных функций API ядра. Стек каждого процесса в ядре выделяется ядерным
планировщиком и управляется отдельно, а не через секцию `.stack` как в пользовательском пространстве.

Модули ядра не имеют своего личного пространства памяти, они разделяют память ядра.
Therefore, if your module segfaults, the kernel segfaults.


--- Вывод информации о модулях (lsmod / modinfo)
Команда `lsmod` покажет список загруженных модулей ядра и зависимости между ними.

Модули ядра находятся в `/lib/modules/$(uname -r)`

Показывает описание конкретного модуля:
$ modinfo <mod_name>

Эта команда относится не только к существующим модулям, но и к новым:
`modinfo hello-1.ko` и в выводе можно увидеть сигнатуру версии (vermagic:)
в этой строчке указано, под какое ядро модуль скомпилирован (будет работать),
то есть чтобы модуль работал для другого ядра, нужно пересобрать модуль для
свежего окружения.

`lsmod` читает информацию из `/proc/modules`.
drm 618496 12 nouveau,ttm,drm_kms_helper, Live 0x0000000000000000

* Название модуля
* Размер
* Кол-во загруженных экземпляров модуля
* Список зависимых модулей
* Текущее состояние: Live - загружен / Loading - загружается / Unloading - выгружен
* Память

Кол-во процессов, которые используют модуль можно посмотреть в файле `/proc/devices`.


--- Добавить или удалить модуль (insmod / rmmod)
При добавлении нового модуля может возникнуть ошибка:
invalid module format, скорее всего не хватает `linux-headers` которые должны быть обязательно
установлены для текущей версии ядра.

Команда добавления:
$ insmod file.ko

В случае проблем можно посмотреть `dmesg`, там будет описание, почему не удалось загрузить модуль.

Force удаление модуля
$ rmmod -f <module>

Можно посмотреть используемые файлы модуля:
$ lsof -w | grep "/proc/module-proc-file"
$ lsof -w | grep "/dev/device"


--- Как модули попадают в ядро (kmod)
Когда ядро обнаруживает необходимость в тех или иных функциональных возможностях, еще не загруженных
в память, то демон `kmod` вызывает утилиту `modprobe`, а тот вызывает `insmod`. Посмотреть можно так:
$ systemctl status kmod

Утилиты `modprobe`, `insmod`, `modinfo` и другие, это просто ссылки на `/bin/kmod`, ничем не
отличаются. Всем заправляет `kmod`, можно вызвать `/bin/kmod` и понять, какой утилитой пользоваться.


--- Что такое linux-headers
Это заголовочные файлы, являющиеся частью исходного кода ядра. Они содержат описания внешних
интерфейсов, структур данных и макросов. Эти файлы необходимы для сборки модулей ядра, обеспечивая
актуальность данных для бинарной совместимости.

Пользовательские программы обращаются к `/usr/include` файлам.
Модули ядра обращаются к `/usr/src/linux-headers-$(uname -r)` файлам.


--- Что такое встроенные и загружаемые модули
Встроенные модули - это те, которые встроены в ядро на этапе его сборки.
Загружаемые модули - обычно от сторонних поставщиков, могут существовать
только отдельно и загружаться в память на этапе исполнения.

`lsmod` показывает загружаемые модули, а остальные (встроенные) можно посмотреть:
$ cat /lib/modules/$(uname -r)/modules.builtin

Показывает как встроенные, так и загружаемые:
$ ls /sys/module

Встроенные модули отмечаются как: CONFIG_SCSI=y (встроенная в ядро функциональность),
а загружаемые CONFIG_SCSI=m (отдельные `.ko` файлы, которые запускает `kmod` при необходимости)
Некоторые модули не видны в выводе `lsmod`, но видны в `modinfo` потому что они являются (builtin).
Команда `hwinfo` покажет список драйверов, устройств.


--- Функции, которые доступны из модулей
Программа может вызывать функции, которые не определены в самой программе. На стадии линковки
разрешаются все внешние ссылки, уходящие во внешние библиотеки, например функция `printf` одна из
таких функций, которая определена в библиотеке `libc`.

Модули ядра сильно отличаются от прикладных программ, например используется функция `printk()`, но не
подключали стандартную библиотеку ввода, вывода. Модули так же проходят стадию связывания, но только
с ядром, и могут вызывать только те функции, которые экспортируются ядром. Разрешение ссылок на
внешние символы производится утилитой `insmod`.

`/proc/kallsyms` описывает какие символы были экспортированы ядром. Символы - это функции, переменные
и т.д. Этот список включает в себя адреса каждого символа, что позволяет разработчикам и отладчикам
идентифицировать конкретные функции и переменные в памяти ядра.

Файл `/proc/kallsyms` содержит все символы, о которых известно ядру и которые доступны вашим модулям,
поскольку они совместно используют пространство кода ядра.

адрес символа  тип символа  имя_символа  модуль_символа
ffffffffc04a247c r __kstrtab_usb_otg_state_string       [usb_common]
Если символ принадлежит загружаемому модулю ядра [usb_common], здесь будет указано имя этого модуля.

00000000000199f0 A x86_bios_cpu_apicid

Более подробно: $ man nm
T - для глобальных текстовых символов (.text).
t - для локальных текстовых символов (.text).
A - абсолютный символ (#define P 2).
r - символ в секции только для чтения (константы).
d - символ в секции инициализированных данных (.data).
b - символ в секции неинициализированных данных, например, глобальные переменные (.bss).
D - глобальный инициализированный символ.

Этот файл может быть полезен для разработки ядра, отладки, а также для создания внешних модулей,
которым требуется доступ к определенным функциям ядра. Также он может использоваться в целях
безопасности, например, для поиска потенциально опасных адресов в памяти.

Использовать в собственном коде модуля можно только те имена, которые экскортируются ядром.
Для того, чтобы имя из пространства ядра было доступно для связывания в другом модуле, для
этого имени должны выполняться два условия 1) имя должно иметь глобальную область видимости
2) Имя должно быть явно экспортируемым `EXPORT_SYMBOL` или `EXPORT_SYMBOL_GPL`.

Все имена, известные в ядре, динамически отображаются в файле `/proc/kallsyms`
их малая часть определены как `EXPORT_SYMBOL`, а вот конкретно для модулей
описаны в `/lib/modules/`uname -r`/build/Module.symvers`.

Модуль, который попытается загрузиться без экспортируемого имени получит ошибку потому что он
противоречит правилам целостности ядра, содержит не разрешённый внешний символ - этот символ не
экспортируется ядром для связывания.

`EXPORT_SYMBOL` будет отображать символ для модуля с любой лицензией.
`EXPORT_SYMBOL_GPL` только для модулей с GPL лицензией.


--- Драйверы устройств
Драйвер устройства - разновидность модулей ядра.

Можно заметить в описании драйвера, что это действительно Driver:
$ modinfo <driver>

В системе они находятся:
`/lib/modules/6.1.0-13-amd64/kernel/drivers`
В исходных кодах Linux ядра, это путь `linux/drivers`.

Драйверы устройств являются такими модулями в составе ядра, которые управляют работой периферийных
устройств.

В Unix каждое аппаратное устройство предоставлено псевдофайлом (файлом устройства) в каталоге `/dev`.
Этот файл обеспечивает средства взаимодействия с аппаратурой. Например, драйвер звуковой платы
`es1370.ko` связывает файл устройства `/dev/sound` со звуковой платой `EnsoniqIS1370`.
А пользовательское приложение, например `mp3blaster` может использовать для своей работы
`/dev/sound`, ничего не подозревая о типе установленной звуковой платы.

Модуль ядра и драйвер устройства, это немного разные вещи. Драйвер устройства позволяет ОС
взаимодействовать с аппаратным обеспечением. (может быть как встроенным, так и загружаемым).
А модули ядра могут быть не связанны с аппаратной частью, а просто выполнять какой-то код в
kernelspace.


--- block / char, major / minor
Информацию об устройстве драйвера нужно смотреть в `sysfs`.

Пример:
$ cd /dev
$ ls -al rtc0 # 252, 0
$ cd /sys/dev/char/252:0

$ ls -al # device -> ../../../00:06
$ ls -al ../../../00:06
driver -> ../../../bus/pnp/drivers/rtc_cmos

Используется драйвером `rtc_cmos`

Each device is generally associated with a driver
`sysfs` как раз содержит информацию о связи устройств и драйверов.

Если каталог `/sys/dev/char/major:minor/ имеет device/`,
тогда точно есть связь с модулем `ls -al` и эти устройства хранятся в `/sys/devices`

Пример:
$ ls -la /dev/watchdog # 10, 130
$ cd /sys/dev/char/10:130
$ ls -al # device -> ../../../iTCO_wdt
$ cd ../../../iTCO_wdt # /sys/devices/pci0000:00/0000:00:1f.4/iTCO_wdt
$ ls -al # iTCO_wdt
$ modinfo iTCO_wdt # найден

b (block device)
c (character device)

brw−rw−−−− 1 root disk 3, 1 Jul 5 2000 /dev/hda1

The first number is called the device's major number.
Основной номер устройства, который указывает на драйвер устройства.
Драйвер устройства обычно виден в `/sys/dev/(char/block)/...`.

The second number is the minor number.
Указывает на конкретное устройство, управляемое этим драйвером,
устройство под номер 1, или устройство под номером 58, как здесь:
crw--w---- 1 root tty     4, 58 Dec 31 15:13 tty58
Главный `tty`, например имеет номер 0. Этот номер скорее для разделения одинаковых типов.


--- How Do Modules Get Into The Kernel ?
Демон `kmod` запускает `modprobe`, который принимает на вход название модуля.

У модулей есть `alias`, например модуль `qrtr` в выводе `lsmod` имеет такое название.
У этого модуля есть `alias`, который можно посмотреть `/lib/modules/*/modules.alias`
`net-pf-42` -> `qrtr` это значит, что утилитам `modprobe` можно передавать:

Один и тот же модуль:
$ modinfo qrtr
$ modinfo net-pf-42

Затем `modprobe` просматривает `/lib/modules/*/modules.dep`.
Этот файл описывает модули, которые запраживает загрузку других модулей, перед своей загрузкой.
Описывает зависимости. Данный файл создается: $ depmod -a

Модуль `qtrt-mhi.ko` запраживает загрузку `qrtr.ko` и `mhi.ko`:
kernel/net/qrtr/qrtr-mhi.ko: kernel/net/qrtr/qrtr.ko kernel/drivers/bus/mhi/host/mhi.ko

Затем `modprobe` запускает insmod (направляет его в `/lib/modules/*/`),
который запускает все зависимые модули + нужный модуль.

`insmod` довольно глуп в отношении нахождения модулей, поэтому принимает абсолютные пути
и необходимый порядок модулей.
$ insmod /lib/modules/2.6.11/kernel/fs/fat/fat.ko
$ insmod /lib/modules/2.6.11/kernel/fs/msdos/msdos.ko

`modprobe` более умный, он ориентируется по `modules.dep`, просто передать имя и все.
$ modprobe msdos

Чтобы загружать компилируемые модули в ядро, нужно иметь установленный CONFIG_MODVERSIONS=y


--- Системные вызовы
You can even write modules to replace the kernel's system calls, which we'll do shortly.
Crackers often make use of this sort of thing for backdoors or trojans, but you can write your own
modules to do more benign things, like have the kernel write Tee hee, that tickles! everytime
someone tries to delete a file on your system.


--- static
When writing kernel code, even the smallest module will be linked against the entire kernel, so this
is definitely an issue. The best way to deal with this is to declare all your variables as `static`
and to use a well−defined prefix for your symbols. By convention, all kernel prefixes are lowercase.
If you don't want to declare everything as `static`, another option is to declare a symbol table and
register it with a kernel.

Когда вы объявляете переменную или функцию как `static`, она не будет видна другим модулям ядра,
даже если они попытаются обратиться к ней по имени. Это помогает предотвратить конфликты имен и
уменьшает вероятность непреднамеренного изменения данных из других частей ядра.


--- Процесс в ядре
В ядре существует понятие "ядерных потоков" или "потоков ядра" (kernel threads - kthreads),
так называемые демоны ядра, которые являются легковесными процессами, полностью выполняющимися в
пространстве ядра. Эти потоки используются для выполнения различных фоновых задач в ядре, таких как
управление устройствами, обработка прерываний и другие служебные функции.

Есть еще процессы называемые kworker (kernel worker). Это фоновые (background) процессы ядра,
которые выполняют работу, отложенную или запланированную другими частями ядра. Эти процессы не
связаны напрямую с каким-либо пользовательским приложением, они обрабатывают различные задачи на
уровне системы, такие как управление памятью, вводом-выводом и прерываниями от устройств.


--- Документация
Например, man register_chrdev
Это не системный вызов, а часть API ядра для драйверов устройств, её описание не будет в стандартных
страницах руководства. Вместо этого можно обратиться к документации ядра в интернете или просмотреть
исходный код ядра на машине (если установлены исходные файлы ядра).
$ cd linux/   # посмотреть в исходниках ядра
$ cd /usr/src # посмотреть в заголовках ядра


--- Что означает, реализовать на всех процессорах ?
Например, вызвать на всех процессорах `VMXOFF` инструкцию.
Для этого используется функция ядра: `on_each_cpu()`.

Как понять сколько процессоров, ядер в системе у процессора ?
$ nproc
$ grep ^processor /proc/cpuinfo

4 процессора/ядра, это означает, что есть один физический процессор с четырьмя ядрами.
В современных многоядерных процессорах каждое ядро может обрабатывать отдельные задачи параллельно,
что улучшает общую производительность системы, поскольку они могут выполнять больше операций одновременно.

1. Физический процессор (CPU) - это физический чип, который можно увидеть внутри компьютера.
В большинстве современных настольных и портативных компьютеров обычно есть один или два физических процессора.

2. Ядро процессора - современные процессоры обычно содержат несколько ядер. Каждое ядро может обрабатывать
инструкции независимо от других ядер, что увеличивает общую производительность системы, позволяя одновременно
выполнять больше задач.


--- ioctl
(сокращение от input/output control) - это системный вызов в UNIX-подобных операционных системах,
который предоставляет универсальный способ управления устройствами. Он используется для отправки
команд устройству или драйверу, которые не покрываются стандартными системными вызовами для работы с
файлами.

Команды для `ioctl` разрабатываются создателями драйверов устройств и могут варьироваться от драйвера
к драйверу. Это мощный инструмент, но он также может быть опасным, так как позволяет выполнять
низкоуровневые операции, которые могут повредить данные или аппаратное обеспечение, если они
используются неправильно.

1. Выполнения операций, специфичных для устройства, таких как форматирование или очистка.
2. Запроса информации от устройства, которая не доступна через другие системные вызовы.
3. Установления различных параметров устройства или драйвера.
и многое другое

Например, чтобы на прямую не вызывать событие `cat /dev/chardev` можно написать userspace программу, которая
будет отправлять `ioctl` запросы через устройство драйвера.

В пользовательской программе:
char message[100];
ioctl(fd, IOCTL_GET_MSG, message);

#define IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *)
IOCTL_GET_MSG и подобные, это макросы, которые объявляет пользователь в заголовочном файле.
Там используются `_IOR`, `_IOW`, `_IOWR`.

`_IOR` считывает данные из драйвера устройства. Используется, когда пользовательское приложение хочет
получить информацию от драйвера.

`_IOW` записывает данные в драйвер устройства. Используется, когда пользовательское приложение хочет
отправить информацию драйверу для выполнения некоторый операций.

`_IOWR` и считывает и записывает данные. Этот макрос используется, когда необходимо как передать
данные драйверу, так и получить ответ от него.

struct file_operations Fops = {
        .read = device_read,
        .write = device_write,
        .compat_ioctl = device_ioctl,
        .unlocked_ioctl = device_ioctl,
        .open = device_open,
        .release = device_release,
};

Необходимо иметь два обработчика вызова `ioctl`: `.compat_ioctl` / `.unlocked_ioctl`.


--- spinlock
Работает в пространстве ядра. Это примитив синхронизации, который используется для защиты данных от
одновременного доступа в многопоточной среде. Когда поток пытается получить spinlock, он "вращается"
в цикле, активно ожидая, пока блокировка не будет освобождена, вместо того чтобы уходить в состояние
сна, что позволяет избежать накладных расходов на переключение контекста. Spinlock подходит для
защиты коротких участков кода, где ожидаемое время ожидания блокировки минимально. Spinlock немного
похож на Mutex, но только для kernelspace.
