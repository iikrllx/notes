/*
Побитовые операции позволяют оперировать с битами
В примерах используются 8 битные числа */

int main(void)
{
  /* --- ПРИМЕР 1 - Логическая операция И */
  /* Десятичное число 3 в двоичной системе счисления 00000011 */
  /* Десятичное число 8 в двоичной системе счисления 00001000 */
  char a = 3; /* 00000011 */
  char b = 8; /* 00001000 */
  char c = a & b;

  /*
    Производится умножение &:

    00000011
    00001000
    =
    00000000
  */

  printf("%d\n", c); // Поэтому здесь 0

  /* --- Пример 2 - Логическая операция И */
  char a1 = 31; // 00011111
  char b1 = 17; // 00010001
  // Сравнение     00010001
  char c1 = a1 & b1; // Равен 00010001
  printf("%d\n", c1); // Здесь 17, потому что при переводе 00010001 в десятичное получается 17
  /*
    А перевезти его можно так (цифры в скобочках - это возведение в степень):
    00010001 = 0*2(7) + 0*2(6) + 0*2(5) + 1*2(4) + 0*2(3) + 0*2(2) + 0*2(1) + 1*2(0) = 16 + 1 = 17
  */

  /* --- Пример 3 - Логическая операция ИЛИ */
  char aa = 40; // 00101000
  char bb = 8;  // 00001000
  char r = aa | bb;  // 00101000 = 0 + 32 + 0 + 8 + 0 + 0 + 0 = 40
  printf("%d\n", r); // Здесь 40

  /*
    --- Пример 4 - Логическая операция НЕ
    работает не для отдельного бита, а для всего числа
    Оператор инверсии меняет ложь на истину, а истину на ложь
    Можно заметить что оператор ~ просто прибавляет 1 к числу и делает его отрицательным */

  char na = 65;  // 01000001
  char nb = ~na; // 10111110 первый бит 1, что говорит нам о минусе
  printf("%d\n", nb); // Здесь -66, прибавилась 1, и поставился минус

  /* --- Пример 5 - Исключающее ИЛИ, побитовая операция xor */
  char oa = 12; // 00001100
  char ob = 85; // 01010101
  char oc = oa ^ ob;  // 01011001
  printf("%d\n", oc); // Здесь 89, потому что 01011001 перевели в десятичную

  return 0;
}
