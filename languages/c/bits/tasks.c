int main(void)
{
  /*
    1. Число 2 возвести в степень 6
    При каждой итерации с << число 2 умножается на 2
    010 << 1 = 100 (4)
    100 << 2 = 1000 (8)

    Почему начинается с 1, а не с 0
    Например 2 в 4 степени будет 16, 1 < 4
    Это 2 * 2 * 2 * 2 (3 итерации умножения)

    Чтобы не путаться, лучше в начале написать 2 во 2 степени
    Это один раз умножить 2 * 2
    1 < 2 (одна итерация) */
  int num = 2, pow = 6;
  for (int i = 1; i < pow; i++) {
    num = num << 1;
  }
  printf("%d\n", num);


  /* 2. Вывести двоичное представление целого положительного
        числа, используя битовые операции */
  unsigned int n = 7;
  size_t int_len = sizeof(n) * CHAR_BIT; // 32
  // Здесь хотелось использовать INT_BIT, но такого макроса нет
  // потому что можно длину расчитать с помощью sizeof(int) * CHAR_BIT

  for (int i = int_len - 1; i >= 0; i--)
    printf("%d", (n & (1 << i)) != 0);
  printf("%c", '\n');


  /* 3. Найти кол-во единиц в двоичном представлении целого
        положительного числа */
  unsigned int q = 3;
  size_t bc_1 = 0;
  for (int i = int_len - 1; i >= 0; i--) {
    if ((q & (1 << i) != 0))
      bc_1++;
  }
  printf("1 bytes of %d num - %d\n", q, bc_1);


  /* 4. Найти номер старшего бита в двоичном представлении
        целого положительного числа (младший бит находится по той же логике) */
  unsigned int z = 10;
  printf("%d %d\n", (z & (1 << int_len - 1)) != 0, int_len - 1);


  /* 12. Описать словами результат следующего выражения */
  unsigned char x = 3;
  x & (x - 1); // 011 & 010 = 010 (2)


  /* 13. Описать словами результат следующего выражения */
  printf("%d\n", x & (-x));
  // -3 выглядит как 11111101
  //  3 выглядит как 011

  return 0;
}
