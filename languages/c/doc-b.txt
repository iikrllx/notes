Темы:
* Символ L
* wchar_t и wint_t
* ascii / unicode
* UTF-8
* size_t / ssize_t в цикле и пределы
* Объявление переменных счетчиков
* Null Character (NTBS)
* Символ '\n' в конце строки
* Ошибки с памятью, разбор + valgrind
* Зачем освобождать память free()
* Как работает realloc
* Что такое lvalue / rvalue
* strcpy vs memcpy
* execve("path/to/file", NULL, NULL);
* Комментарии 4 / 2
* Нужно ли присваивать NULL указателю после free ?
* lstat / fstat / stat
* malloc for struct pointer
* dereferencing pointer to incomplete type
* PATH_MAX
* Размер буфера
* Выравнивание
* Heap overflow
* Stack overflow
* malloc и память стека
* Указатель на int
* volatile
* inline


--- Символ L
Данный символ используется для широких строк и чисел (long).

printf("%d", sizeof(L"k"));
Выводит число 8, потому что запрашивается памяти для wchar_t
а не для char. Так называемых широких символов.

printf("%d", sizeof("ц"));
Здесь выводится число 3, потому что символ юникогда запрашивает
2 байта памяти, а не 1, а последний байт это '\0'.

printf("%d", sizeof("k"));
А здесь получим классическую цифру, в 2 байта, потому что один
символ это 1 байт, а '\0' еще один.

Например если определить строку без символа L
wchar_t str = "Hello";
Компилятор начнет ругаться, что присваивание wchar_t осуществляется
через char * и это неправильно.


--- wchar_t и wint_t
Предоставляют широкий тип данных, который шире стандартных.
Находятся в wchar.h


--- ascii / unicode кодировка
Таблицы в которых осуществляется сопоставление символа и кода (цифры) для осуществления кодирования,
чтобы компьютер понимал какой символ ввел пользователь.

ascii определяет 0-127 символов и использует 7-бит, то есть 128 различных комбинаций, а посчитать
это можно так, 2 в 7 степени, получается 128 комбинаций максимум 128 символов, а почему не 8 бит?
потому что 8 бит используется для избежения ошибок в качестве бита четности, но со временем ascii
расширили и появился расширенный ascii, стали использовать 256 символов, 2 в 8 степени задействовали
последний бит.

unicode включает в себя ascii и множество других символов около 1 114 112 кодовых позиций (символов)
это очень много и они не помещаются в 8-битный байт, а требуют больше. Зависит от кодировки UTF-8
(символ может занимать не менее 8 бит) / UTF-16 (16 бит) / UTF-32 (32 бит)


--- UTF-8 кодировка
Формат преобразования юникода, 8 бит. Распространенный формат кодирования символов, позволяющий
более компактно хранить символы юникода, используя переменное кол-во байт (от 1 до 4 байт) и
обеспечивает полную обратную совместимость с 7-битной кодировкой ASCII.


--- size_t / ssize_t в цикле и пределы
Плохая идея использовать тип данных unsigned вместе с циклом, например так:
for (size_t i = 10; i >= 0; i--) в итоге мы получим бесконечный цикл, который
выходит за пределы, тоже самое с for (unsigned char i = 10; i >= 0; i--)
Из 0 вычитается 1 и получается выход за пределы числа, лучше писать так:
for (unsigned char i = 10; i >= 1; i--)

Если писать так, то бесконечного цикла не будет, но i будет равен -1
for (ssize_t i = 10; i >= 0; i--)

size_t может быть любым из:
unsigned short / unsigned long / unsigned char / unsigned int и другие

ssize_t может быть любым из:
signed short / signed long / signed char / signed int и другие

В выводе этого примера будет: 1
unsigned char i;
for (i = 1; i >= 1; i--)
  printf("%d\n", i); // вывод будет

И переменная i будет равна числу 0

Когда мы пишем i >= 0, это означает, что когда число i будет равно 0
сработает i--, то есть из 0 вычтется 1, получится i будет равен 255 (выйдет за предел),
бесконечный цикл, эта ошибка называется "unsigned integer overflow" (переполнение числа).
У нас в условии программы написанно - ВНИМАТЕЛЬНО (i >= 0).

Think about unsigned char as a Byte: 0 -> 0b00000000 1 -> 0b00000001 ... 255 -> 0b11111111
Then the next number is 0 because you can't have a 9th bit. So after 0b11111111 it's 0b00000000.
That's why it is an infinite loop, it will never reach 256 and will always stay between 0 and 255.


--- Объявление переменных счетчиков
Если объявить int a, b, c = 0;
Тогда a и b будут равны мусору, а c будет равен 0.

Лучше объявлять так:
int a = 0, b = 0, c = 0;

или:
int a, b, c;
a = b = c = 0;

или:
int a = 0;
int b = 0;
int c = 0;


--- Null Character (NTBS)
Массив символов длиной 3
char buf[3] = "cpm";

Это неправильное объявление, так как если в нашей программе будет вызов strcpy или подобной функции,
которая добавляет в конец '\0' (null character) Компилятор выдаст ошибку:
Writing 4 bytes into a region of size 3 overflows the destination?

char buf[0];
strcpy(buf, "");
Тоже выдаст ошибку, так как необходимо прописать buf[1];
и под buf[0] и buf[1] будет символ '\0', в целочисленном 0

Поэтому buf[4]; strcpy(buf, "cpm");
0 - c (1 байт)
1 - p (2 байта)
2 - m (3 байта)
3 - 0 (4 байта)
4 - garbage

Константа нулевого указателя — это целочисленное константное выражение со значением 0 или (только в
Си) такое же выражение, но приведённое к типу void* print NULL -> (void *) 0x0

Массивы символов могут содержать '\0' или не содержать, если массив содержит байт NULL, то этот
массив является строкой символов (NTBS), если же нет, то это массив символов.

char vowel[] = {‘a’, ‘e’, ‘i’, ‘o’, ‘u’};         // character array
char vowel[] = {‘a’, ‘e’, ‘i’, ‘o’, ‘u’, ‘\0’};   // character string
char *str = "Hello World";                        // string literal with no visible NULL character

Проверка на NULL указатель:
if (p == NULL) or if (!p) // проверка на ноль

символ -> код
'\0' -> 0
'0' -> 48

В массиве символов не нужно писать '\0', это просто пустое значение от которого нет толку,
это простой 1 байт данных, а для строки символов, следует в конце обозначать '\0'.

В строке char str[100] = "hello\n";
символ '\0' добавляется автоматически, будет ИНИЦИАЛИЗИРОВАНО 7 элементов, а остальные 93 будут
забиты нулями или мусором, то есть будут неинициализированные, strlen в таком случае вернет
число 6, потому что она возвращает кол-во элементов до символа '\0' (terminating zero)

В данной строке тоже автоматически добавляется NULL
char *str = "hello\n"

Если мы хотим определить массив символов (не строку) можно:
char str[6] = "hello\n"; // это будет верным

Данный массив будет хранить 1 байт данных, это не значит что писать можно buf[0] = {'h'}; обращение
к элементу 'h' происходит через индекс 0, а длина у массива символов равна 1 это нужно различать и
помнить: char buf[1] = {'h'};

char buf[сколько байт нужно хранить?] = ...


--- Символ '\n' и EOF в конце строки
Многие функции, например gets принимают строки и в конце строки (если есть \n) меняют его
на NULL character - '\0', так же происходит с символов EOF, который равен -1, в целочисленном плане.

Чтобы убрать данный символ можно:
buffer[total_size - 1] = '\0';


--- Ошибки с памятью, разбор + valgrind
* munmap_chunk: invalid pointer
Адрес указателя был изменен, например:

char *s = malloc(20 * sizeof(char));
strcpy(s, "Hello");

while (*s != '\0') {
  printf("%c\n", *s);
  s++;
}

free(s); // munmap_chunk()

* free(): double free detected in tcache 2
Возникает при освобождении одного и того же указателя

char *p = malloc(20 * sizeof(char));
strcpy(p, "hello\n");

char *new;
new = realloc(p, 30);

p = new;

free(p); // освобождение и 'p' и 'new'
free(new); // здесь освобождение уже не требуется, это было сделано в строке выше

* Invalid write of size 1
Выделили буфер размером 2 байт, программа пытается писать 3 байт в данный буфер,
тем самым valgrind вернет эту ошибку, туда нельзя писать, мы не выделили память
для этого.

It first tells you the size of the written data, which is 1 bytes, and corresponds
to the size of a character. Then the line at 0x400553: main (test.c:7)
tells you at which line your error occured.

==18332== Invalid write of size 1
==18332==    at 0x400553: main (test.c:7)
==18332==  Address 0x521004a is 0 bytes after a block of size 10 alloc\'d
==18332==    at 0x4C2EB6B: malloc (vg_replace_malloc.c:299)
==18332==    by 0x400538: main (test.c:3)

Здесь говорится, что после 10 байтов, есть 0 байт (лимит достигнут), но мы пытаемся
записать 11 байт.

* Invalid read
int i;
int *ptr = NULL;
i = *ptr;

Не может прочитать 4 байта, потому что i имеет пустое значение
Invalid read of size 4

По адресу: функция (файл, строка)
at 0x109130: main (file.c:17)

* Fishy values
Например malloc было передано -1, либо иной другой функции,
передано невозможное значение.

* Conditional jump or move depends on uninitialised value(s)
Нужно вместо malloc() использовать calloc()

* Still reachable
Означает локальные переменные, это не ошибка
int main(void)
{
  static *char = malloc(16);
  return 0;
}

Еще один яркий пример, например наша программа запрашивает память в главной функции main() затем в
main() есть вызов другой функции, программа переходит дальше по стеку и в этой функции есть условие
(которое если сработает - сделает exit()), тем самым наша программа не дошла до вызовов free()
функции main() тем самым, она освободилась автоматически. Просто valgrind об этом сообщил.


--- Зачем освобождать память free()
В отличие от обычных массивов, которые исчезают при выходе из функции, выделенная память имеет
постоянный характер (пока не будет освобождена программистом), если не освобождать память, программа
будет кушать всё больше и больше памяти компьютера, пока не достигнет конец памяти, если
рассматривать простые программы, которые запрашивают пару байтов, это не страшно, а что если
программа запрашивает 1гб ? free() должен быть обязательно (особенно в циклах). Память, которая
освобождена не может использоваться повторно (!!!)

Нужно ли делать free перед завершением ?
You don't need to free memory before program termination. Terminating the program in any way causes
all memory to be deallocated automatically. Когда программа закончит работу, она автоматически
освобождает всю память.


--- Как работает realloc
Выделяет новый объем памяти, копирует значение старой памяти в новую, освобождает старую память
и возвращает указатель на новую память. Новый размер realloc может быть больше или меньше.
Запрос новой памяти (с новым размером) -> Копирование содержимого старой в новую -> Освобождение старой.
oldp = malloc(oldsize);
newp = realloc(oldp, newsize);

либо:
oldp = realloc(oldp, newsize);


--- Что такое lvalue / rvalue
lvalue представляет объект, который занимает идентифицируемое место
в памяти (имеет адрес)

rvalue это выражение, которое не представляет собой объект, которое занимает
идентифицируемое место в памяти.

* Пример ошибки с lvalue:
int foo() { return 2; }
int main()
{
  foo() = 2;
  return 0;
}

Оператор присваивания ожидает lvalue слева, а 'var' как раз является lvalue
int var;
var = 4;

4 = var; (НЕ ВЕРНО)
(var + 1) = 4; (НЕ ВЕРНО)

Ни константа 4, ни выражение var + 1 не являются lvalue
(что автоматически их делает rvalue). Они не lvalue, потому что оба
являются временным результатом выражений, которые не имеют определённого
места в памяти (то есть они могут находится в каких-нибудь временных
регистрах на время вычислений). Таким образом, присваивание в данном
случае не несёт в себе никакого семантического смысла.

Здесь 'a' не является lvalue, 'const' не является lvalue
const int a = 10;
a = 15; (НЕ ВЕРНО, не можем присвоить, значит это не lvalue)

* Пример ошибки с rvalue:
int& foo()
{
  return 2;
}

int a = 1; // lvalue
int b = 2; // lvalue
int c = a + b; // в качестве результата возвращается rvalue

Здесь 'a' и 'b' конвертируются в rvalue, оператор '+' требует rvalue
Можно ли преобразовать rvalue в lvalue ? НЕТ!

p + 1 rvalue, однако *(p + 1) уже lvalue


--- strcpy vs memcpy
memcpy копирует точное кол-во байт, а strcpy проходит по строке пока не встретит 0 записывая тем
самым в dest, memcpy идеально подходит для зашифрованных дайных, бинарных, не символов, а strcpy для
строк, memcpy копирует данные (не символы) из источника в место, а strcpy символы.


--- execve("path/to/file", NULL, NULL);
Если вызвать программу в которой будет обработка argv[0], например для progname можно будет словить
Segfault или чего другого. В такой программе argc будет равен 1, а argv[0] ""


--- Комментарии 4 / 2
Делается для экономии места (комментарии)

4 child (for child)
2 user (to user)


--- Нужно ли присваивать NULL указателю после free ?
free(p);
free(p);

Возникнет ошибка: free(): double free detected in tcache 2
Если написать:

free(p);
p = NULL;

Ошибка повторного освобождения не случится (или повтороного использования).
Для этого и пишется p = NULL;


--- lstat / fstat / stat
Является ли файл символической ссылкой или нет. Жесткая ссылка будет иметь одинаковый inode,
и атрибута l не будет, а символическая ссылка будет иметь атрибут l, но разные inode.

Процесс имеет fd символической ссылки и имя файла (не абсолютное).
Можно взять pid процесса и прочитать ls -l /proc/<PID>/fd
И получить имя файла fd (с помощью readlink).
Если имя файла отличается - это и есть признак симлинка (либо переименование файла).

Проблема lstat что он получает абсолютный путь в роли аргумента
и с fd выкручиться придется через readlink, либо никак.

int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);

Только lstat скажет про l атрибут, например:
if (!S_ISLNK(st.st_mode))


--- malloc for struct pointer
Чтобы правильно выделить память для указателя необходимо подсчитать
кол-во элементов структуры.

Есть структура:
struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
}

Формула аналогичная с получением длинны массива:
members_number = sizeof(struct __user_cap_data_struct) / sizeof(__u32);

sizeof(struct __user_cap_data_struct) вернет число 12
потому что __u32 + __u32 + __u32 -> 4 + 4 + 4
12 / 4 = 3 (кол-во элементов)

Затем нужно полученное число умножить на:
data = malloc(members_number * (sizeof(struct __user_cap_data_struct) + sizeof(__u32)))

3 * (12 + 4)
12 + 4 - суммарное значение struct вместе с __u32
а 3 - кол-во элементов


--- dereferencing pointer to incomplete type
error: dereferencing pointer to incomplete type 'struct mailbox_list'
printf("%d\n", mbox->box->list->mail_set->mail_debug);

Означает, что в исходный код нужно добавить заголовочный файл
с описанием mailbox_list


--- PATH_MAX
Размер пути в Linux может превышать размер PATH_MAX. Так же PATH_MAX разный в зависимости от
платформы. Использовать PATH_MAX на свой страх и риск. (а лучше не использовать). Можно написать
свою более умную функцию выделения памяти для буфера путей. Например, выделять конкретно 1024 или
4096, прописать это в коде, а не опираться на PATH_MAX.


--- Размер буфера
char arr[200];
Но при этом будет использоваться около 8 байт, 192 байт просто так скушает процесс (и они не будут
использоваться). Дырки в памяти. Т.е. выделен массив на 100 килобайт, а в реальности туда пишется
несколько десятков или сотен байт. Оставшиеся 99 килобайт по сути дела процесс взял себе, но не
использует. Если помножить на 350 параллельных процессов, то получается 35 лишних мегабайт плюс
дополнительная нагрузка на подсистему памяти, которая обслуживает неиспользуемые страницы памяти.
Растрата ресурсов. Если не знаешь сколько памяти выделять, используй динамическое выделение.


--- Выравнивание
Стратегия расположения данных в оперативной памяти по определенным правилам, способствующих
ускорению доступа к ним. Без выравнивания можно столкнуться с ситуацией, когда процессору придется
использовать две и более инструкции для доступа к данным, расположенным между адресами, кратными
размеру машинного слова. char — особый случай, они занимают ровно одно машинное слово и всегда
требуют одинакового количества инструкций для доступа. Поэтому для них нет предпочтительного
выравнивания.

struct foo1 {
    char *p; /* 8 байт */
    char c; /* 1 байт */
    char pad[7]; /* 7 байт */
    long x; /* 8 байт */
};

Любой экземпляр foo1 будет выравниваться по 8 байтам.
В сумме sizeof выдаст 24 байта.

В 99% случаев вообще об этом не нужно беспокоиться, так как всю работу выполняет компилятор и
аллокатор памяти. Выравнивание нужно, потому что процессору "легче" работать с выравненными данными.
И у каждого компилятора и архитектуры по разному считается/выравнивается sizeof структуры.
Процессору легче работать с цифрами кратными двойке.

Если нужно изучить как работает выравнивание можно:
$ pahole ./a.out

Например:
struct foo1 {
    char c;
    int x;
    char b;
};

0 -> начинается с 0, 1 -> имеет размер 1

char                       c;                    /*     0     1 */

/* XXX 3 bytes hole, try to pack */

int                        x;                    /*     4     4 */
char                       b;                    /*     8     1 */

/* size: 12, cachelines: 1, members: 3 */
/* sum members: 6, holes: 1, sum holes: 3 */
/* padding: 3 */
/* last cacheline: 12 bytes */

Короткое правило: чтобы данные были хорошо упакованы, нужно их записывать в структуре
вместе, по типам, например, сначала идут char, потом int, потом long и т.д.
А не int, char, int, long, не надо так.

struct Person {
  long nq; // 8 байт (на 64-битных системах)
  int x;   // 4 байта
  int y;   // 4 байта
  char n;  // 1 байт
  char oo; // 1 байт
  // 6 байт padding
};

В этой структуре элементы сгруппированы по убыванию их размера, что позволяет избежать лишних
промежутков (padding) между элементами и улучшить выравнивание. Компиляторы Си автоматически
добавляют padding для выравнивания элементов структуры. Знание о том, как правильно располагать
элементы, может помочь оптимизировать использование памяти и улучшить производительность программы.


--- Heap overflow
Возникает если:
* Запросили памяти больше чем есть на самом деле
* Запросили много памяти и не сделали free (в цикле например)

Данные по heap можно посмотреть в /proc/<pid>/*


--- Stack overflow
Если функция вызывается рекурсивно сама по себе бесконечное количество раз, то стек не сможет
хранить большое количество локальных переменных, поэтому произойдет переполнение стека.

int main(void)
{
	main();
}

Если мы объявим большое количество локальных переменных или объявим массив большой размерности или
матрицу, это может привести к переполнению стека.

Данные по stack можно посмотреть в /proc/<pid>/*


--- malloc и память стека
Функция malloc возвращает адрес начала новой (запрашиваемой) области памяти. В этой области памяти
скорее всего лежит разный мусор (использованная память прошлым процессом). calloc возвращает чистую
память забитую нулями, а malloc наоборот.

У процесса может происходить диалог с ОС с помощью системных вызовов.
Системные вызовы еще называются системным прерыванием.
Процесс -> Операционная система -> Железо.

Если запросить около 5MB памяти в массиве - не получится.
char arr[1024 * 1024 * 5];
printf("Hello\n");
= SIGSEGV

Этот пример показывает, что стек это плохое место для хранения больших данных. По-умолчанию размер
стека равен 8 MiB. Лучше запрашивать большой объем памяти в кучи.

Если с помощью malloc или calloc запрашивается памяти больше чем нужно в ПК, тогда операционная
система выделит всю оставшуюся память не выдавая ошибки. Но если запросить еще больше, например
20ГБ, тогда будет ошибка ENOMEM.

В языках Python, Java, C#, PHP и других, есть автоматическая функциональность освобождения памяти. А
Си доверяет программисту и ставит гарантии на то, что программист освободит память с помощью free().
Такая функциональность называется "автоматическое управление памятью - сборщик мусора".

hello.c -> CPU
CPU не понимает языка программирования Си и не сможет выполнить эти инструкции. Что нужно для этого
сделать ? 1. Компилятор. 2. Загрузить программу в память ПК. Компилятор преобразует исполняемый
текст в исполняемый файл (понятный только машине). Затем происходит запуск бинарного файла в
операционной системе (загрузка в память). Операционная система контролирует процесс (загруженный
файл). Если ошибка, то снимает процесс с исполнения. Если бы не ОС, был бы shutdown или что-то
подобное. CPU потребляет только машинный код. Бывают ошибки компиляции, а бывают намного хуже,
когда ошибки появляются в процессе выполнения программы. В машинном коде нет человекопонятных имен,
только адреса.


--- Указатель на int
Так не получится:
int *p = 10;

Лучше писать так:
int *p;
*p = 10;

Чем так (SIGSEGV):
int *p = NULL;
*p = 10;

int *p обычно нужен для адреса какого-то другого числа &arr[0]
Или хранить адрес другой int переменной.


--- volatile
Ключевое слово `volatile` в языке C используется для указания компилятору, что значение переменной
может изменяться в любой момент, и это изменение может произойти извне. Это может быть связано,
например, с аппаратными событиями, прерываниями или другими программами/потоками.

Использование `volatile` гарантирует, что компилятор не будет оптимизировать доступ к этой
переменной, каждый раз при обращении к переменной будет производиться реальное чтение её значения из
памяти, а не использование кэша. Это важно для синхронизации и корректного взаимодействия с
оборудованием или при многопоточном программировании. Это гарантирует, что программа всегда получит
актуальное значение переменной, даже если оно было изменено в обработчике прерывания или другой
параллельной задаче.

Изменение "извне" означает, что значение переменной может быть изменено извне текущего потока
выполнения: это может быть другой поток в многопоточном приложении, прерывание, или даже аппаратное
устройство.

Компилятор не будет оптимизировать, значит, что он не будет перемещать доступ к такой переменной за
пределы циклов или вносить другие изменения, которые могут нарушить правильную работу программы в
многопоточной среде.

// Global variable
volatile int flag = 0;

// Обработчик прерывания / сигнала
void interrupt_handler()
{
	// Устанавливает флаг в обработчике прерывания
	flag = 1;
}

int main(void)
{
	while (flag == 0) {
		// Ожидаем, пока флаг не установится в 1
	}
	// Продолжаем выполнение программы
}

Изменение переменной `flag` извне может произойти несколькими способами, в зависимости от контекста,
в котором она используется. Прерывания, Многопоточность, Сигналы, Общая память и т.д.

Когда объявляется переменная с ключевым словом `volatile`, компилятор генерирует код, который будет
обращаться к памяти при каждом чтении или записи этой переменной. В отличие от этого, обычная
переменная `int q = 2;` может быть оптимизирована, и компилятор может решить не обращаться к памяти
при каждом её использовании после инициализации, если он "понимает", что значение переменной не
изменяется.


--- inline
Это ключевое слово, которое может быть использовано с функциями. Оно предлагает компилятору
попытаться вставить код функции непосредственно в точку вызова, чтобы избежать накладных расходов на
вызов функции (например, передачу аргументов, возврат управления и т.д.).

inline int add(int a, int b)
{
    return a + b;
}

int main(void)
{
    int result = add(3, 4);
    printf("%d\n", result);
    return 0;
}

В этом примере функция `add` объявлена как `inline`, что означает, что компилятор может вставить её
код непосредственно в `main`, вместо того, чтобы делать вызов функции. Это может быть особенно
полезно для очень маленьких функций, которые вызываются очень часто, так как это может существенно
уменьшить накладные расходы и увеличить производительность программы.

Однако, стоит заметить, что `inline` является только предложением для компилятора, и он может
проигнорировать это. Компилятор может решить не вставлять функцию в код по разным причинам,
например, если функция слишком большая или содержит сложный код, который может затруднить
оптимизацию. Кроме того, слишком частое использование `inline` может привести к увеличению размера
исполняемого файла, так как один и тот же код функции может быть вставлен во многие места программы.
