Темы:
* Создание локального репозитория
* Создание локального репозитория (reprepro)
* Структура репозитория
* Почему APT задает вопросы во время установки пакета
* held packages
* Директория DEBIAN, ручная сборка и описание control файла
* pbuilder и сборка пакета
* Разбор этапов dpkg-buildpackage
* dpkg статусы (rc, ii)
* Работа с заплатками
* DEB переменные
* Подробнее про --as-needed
* debug packages
* debconf
* Скачать разные версии пакета
* dist-upgrade с исключением
* Разбор версий
* eatmydata
* Репозитории и зеркала
* Игнорировать Recommends, установка Suggests
* debian/rules по умолчанию
* UNRELEASED
* Non-maintainer upload
* Иерархия команд сборки
* Как предотвратить дублирование файлов (столкновение с другими пакетами)
* Проверка пакета на ошибки
* Какие пакеты были установлены за день
* Сравнение версий пакетов с помощью dpkg
* dget
* debdiff
* interdiff
* Утилиты для вкладчиков
* Утилиты для тестирования пакетов
* getbuildlog
* buildd
* pbuilder vs sbuild


--- Создание локального репозитория
$ apt-get install dpkg-dev

Нужно создать директорию и положить туда `*.deb` файлы:
$ cd /usr/local/debs/ && dpkg-scanpackages -m . | gzip > Packages.gz

Файл `Packages.gz` содержит информацию о пакетах.
-m означает, что будут положены все найденные `.deb` файлы в вывод.

В `sources.list` нужно:
deb [trusted=yes] file:///usr/local debs/

Можно тоже самое сделать и для исходников, только архив будет называться
`Sources.gz`. И нужно использовать утилиту `dpkg-scansources`.
Нужно создать директорию и положить туда `.orig.tar.gz`, `.dsc`, `.debian.tar.gz`
$ dpkg-scansources . | gzip > Sources.gz

В `sources.list` нужно:
deb-src [trusted=yes] file:///usr/local debs/


--- Создание локального репозитория (reprepro)
$ apt-get install reprepro
$ mkdir -p repo/conf
$ touch repo/conf/distributions

Origin: Debian               # название репозитория
Suite: unstable              # ветка (codename alias)
Codename: dick               # кодовое слово (например buster, bullseye)
Version: 1.0                 # версия
Architectures: amd64 source  # для amd64 + исходных кодов
Components: main             # компонент (main, contrib, non-free)
Description: my local repo   # описание
SignWith: yes                # подпись

reprepro -b <base_dir>
$ export REPREPRO_BASE_DIR=repo/

$ cd <base_dir> && reprepro export
$ reprepro -C <component> includedeb <codename> *.deb
$ reprepro repo/ createsymlinks
$ reprepro repo/ remove <codename> <name_of_deb>
$ reprepro repo/ removesrc <codename> <name_of_src>

`sources.list`:
deb [trusted=yes] file:///home/builder/repo/ <codename> <component>

Если нужно сделать репозиторий, который можно будет подключаться с внешнего
источника, тогда нужно развернуть на каком-нибудь сервере - Apache/Nginx,
создать репозиторий, подписать.


--- Структура репозитория
Содержит суммы, метаданные пакетов:
repo/dists
repo/dists/main
repo/dists/main/binary-<arch>/
repo/dists/main/binary-<arch>/Packages     # метаданные пакетов из компонента 'main'
repo/dists/main/binary-<arch>/Packages.gz  # архив gzip файла выше
repo/dists/main/binary-<arch>/Release      # описание релиза
repo/dists/main/binary-<arch>/Release.gpg  # подпись
repo/dists/contrib
repo/dists/non-free
repo/dists/Release                         # содержит суммы Packages/Packages.gz/Release и других
                                           # файлов метаданных

Содержит пакеты различных компонентов a/ b/ c/ ...:
repo/pool
repo/pool/main
repo/pool/contrib
repo/pool/non-free

Содержит управляемые пакеты и контрольные суммы в файлах баз данных:
repo/db


--- Почему apt задает вопросы во время установки пакета
$ apt-get install nautilus
Данный пакет зависит от совместно-используемых библиотек, поэтому `apt` скачает
их из архива и задает вопрос, нужно ли их скачать? можно? Если бы мы указали
имена этих библиотек `apt-get` он бы не стал спрашивать разрешения на установку.


--- held packages
Unable to correct problems, you have held broken packages. Пакеты нуждаются в
зависимостях, которые требуют предустановки. Система пытается их установить,
но не может (например этих зависимостей нет в источниках `sources.list`).

Решение:
* Обновить кэш
  $ apt-get update
  и попробовать установить пакет

* Найти проблемный пакет
  $ apt search <p>

* Поменять источник `sources.list` на другой


--- Директория DEBIAN, ручная сборка и описание control файла
Содержимое директории DEBIAN не копируется на диск при установке пакета.
При установке пакета все файлы (кроме папки DEBIAN) распаковываются в корень,
например в `/bin` или `/usr/bin`.

$ mkdir -p name-of-package/DEBIAN
$ vim name-of-package/DEBIAN/control

Package: name-of-package
Version: 1.0
Section: misc         # Указывается категория пакета, что помогает пользователям
		      # и менеджерам пакетов организовывать и находить пакеты по
                      # тематике.

- admin: Инструменты для администрирования системы.
- net: Сетевые утилиты и приложения.
- web: Веб-серверы, браузеры и другие веб-инструменты.
- mail: Почтовые клиенты и серверы.
- database: Базы данных и связанные утилиты.
- devel: Инструменты для разработки программного обеспечения.
- libs: Библиотеки, которые могут использовать другие программы.
- x11: Программы и утилиты для X Window System.
- doc: Документация.
- games: Игры и связанные с ними утилиты.
- graphics: Инструменты для работы с графикой.
- sound: Программы для работы со звуком.
- utils: Различные утилиты.
- editors: Текстовые редакторы.
- science: Программы для научных исследований.
- misc: Разное, что не подходит под другие категории.

Architecture: all     # Архитектура процессора, для которой предназначен пакет

- all: Пакет не зависит от архитектуры и может быть установлен на любую систему.
  Обычно это скрипты, документация и другие архитектурно-независимые файлы.
- any: Пакет может быть собран для любой архитектуры. Это означает, что исходный
  код пакета может быть скомпилирован на любую платформу, поддерживаемую Debian.
  Сопровождающий гарантирует, что его пакет собирается под всех необходимые
  архитектуры.
- amd64: Пакет предназначен для архитектуры x86_64 (64-битные процессоры AMD и Intel).
- i386: Пакет предназначен для архитектуры x86 (32-битные процессоры Intel и AMD).
и т.д.

Maintainer: <name>
Description: <desc>

Depends: debootstrap  # Список пакетов, которые нужно предустановить
Conflicts: vim        # Список пакетов с которыми нельзя ставить данный пакет
Recommends: bla, bla  # Список пакетов, рекомендуемых к установке (необязательно)
Priority: extra       # Приоритет пакета

- important: основные инструменты, важно.
- required: удалить нельзя, база/ядро системы.
- standard: устанавливаются по умолчанию на стандартной системе.
- optional: не являются необходимым, можно установить при необходимости.
- extra: дополнительные функции или утилиты.

Build-Depends: cmake  # Список пакетов, требуемых для компиляции исходников

Standards-Version: 4.7.0

Это поле не связано напрямую с конкретными выпусками Debian, такими как
Bookworm или Sid, а скорее с версией политики на момент упаковки. Указывает на
стандарт версии, которому соответствует пакет. Это поле используется для
описания стандартов, которым должен следовать пакет, включая правила упаковки и
рекомендации. Это поле также полезно для автоматизации и инструментов, таких
как Lintian, которые могут проверять ваш пакет на соответствие современным
стандартам и выдавать предупреждения, если определенные практики устарели или
не соответствуют текущим требованиям.

Стоит ли отправлять подобные патчи?
-Standards-Version: 4.6.1
+Standards-Version: 4.7.0

Такие патчи отправлять не имеет смысла. Сопровождающий пакета самостоятельно
поднимет эту версию перед следующем upload.

$ mkdir -p name-of-package/usr/local/bin
$ cp /path/to/binary name-of-package/usr/local/bin/

Затем нужно рекурсивно выставить всем файлам в корне пакета пользователя
и группу root:root
$ sudo chown -R root:root .
но можно этого и не делать:
$ fakeroot dpkg-deb --build <name-of-package>


--- pbuilder и сборка пакета
$ apt-get install pbuilder
$ pbuilder create --mirror http://deb.debian.org/debian --distribution sid
$ pbuilder --login --save-after-login --basetgz /var/cache/pbuilder/base.tgz
$ pbuilder --login

Перед этой командой нужно убедиться, что есть `*.orig.tar.gz` и `*.debian.tar.xz`:
$ pbuilder build <pack>.dsc

var/cache/pbuilder/build/<pid>/  # нахождение chroot
var/cache/pbuilder/result        # результат сборки

В чистой среде сборки (chroot) для проверки пакетных зависимостей очень полезен
пакет `pbuilder`. Он поможет убедиться в чистоте сборки для различных
архитектур и избежать опасной ошибки FTBFS (ошибка сборки из исходного кода),
которая всегда относится к категории RC (критична для данного выпуска). Можно
прописать `/var/cache/pbuilder/hooks/B90lintian`, который позволит вызывать
`lintian` после сборки пакета.


--- Разбор этапов dpkg-buildpackage
1. dpkg-source --before-build <path>
Подготавливает среду сборки, устанавливая различные переменные окружения.
Применяет патчи.

2. зависимости-конфликты удовлетворены?

3. fakeroot debian/rules clean
Зачищает дерево проекта, важно отметить, что это не только `rm` команды,
а так же всякие `cp <path> debian/changelog`, подготовка окружения

4. dpkg-source -b <path>
Создает source package, ему необходим `<pack>.orig.tar.xz`
Создаст `<pack>.dsc`/`<pack>.debian.tar.gz`

Можно проигнорировать этот этап вызовом: dpkg-buildpackage -b

5. fakeroot debian/rules build или fakeroot debian/rules binary
Сборка программы (создание ELF файлов, Makefile, configure)
или сборка двоичных пакетов (deb)

6. Создает .buildinfo файл

7. Создает .changes файл

8. fakeroot debian/rules clean

9. dpkg-source --after-build

10. Проверяет .changes

11. Подпись


--- dpkg статусы (rc, ii)
r - пакет помечен для удаления
c - только конфигурации пакета присутствуют на системе (удален не полностью)
i - установлен


--- Работа с заплатками
quilt работает с мета-данными из директории `.pc` создается эта директория после
`dpkg-source -x .dsc`.

Заплатка - кусок ткани, или кожи, нашиваемый на прорванное место одежды, или
обуви, или на какое-либо изделие для починки.

Есть исходные файлы:
dovecot_2.3.4.1-5+deb10u6.debian.tar.xz
dovecot_2.3.4.1-5+deb10u6.dsc
dovecot_2.3.4.1.orig.tar.gz

Чтобы не использовать `git init` + `git status`, можно заменить
`quilt diff` + `quilt series` и нижеописанные команды.

$ dpkg-source -x <file>.dsc   # выгрузит все архивы и применит все заплатки
$ dch                         # добавит в конце версии цифру (debian/changelog)
$ dch -e                      # изменить текущий debian/changelog без поднятия версии
$ dch -i                      # изменить debian/changelog - новая редакция
$ quilt refresh               # добавляет Index к патчу (после всех редактирований)
                              # допустим откатились на необходимый патч и сделали правки
                              # затем делаем эту команду и она добавляет эти правки в тот же патч
$ quilt series                # чтение debian/patches/series
$ quilt diff                  # изменение патча
$ quilt files                 # показывает файл в котором изменение (патча)
$ quilt pop                   # убирает последний патч (из примененных)
$ quilt push                  # добавляет последний патч
$ quilt pop -a                # удаляет все патчи (из примененных)
$ quilt push -a               # добавляет все патчи
$ quilt delete <patch>        # удаление патча
$ quilt delete -r <patch>     # удаление патча вместе с unlink
$ quilt edit <file>           # сделать изменения (они добавятся к последнему патчу)
                              # после edit необходимо сделать quilt refresh
$ quilt new <patch>           # поставить новый патч на top
$ quilt add <src/file.c>      # добавить файл в новый патч
$ quilt header -e             # описание заплатки
$ quilt rename -P <old> <new> # переименовать патч

Почему после `dpkg-buildpackage` нет нового `dovecot_2.3.4.1.orig.tar.gz`? из
новых архивов будет только `dovecot_2.3.4.1-5+deb10u6.1.debian.tar.xz` в котором
и будет наш новый патч `debian/` и эти патчи применяются к текущим исходникам, а
сами исходники не меняются.

$ dpkg-source --commit                          # local changed record
$ dpkg-source -itags --commit                   # ignore tags changes + commit

После данной команды нужно выполнить (когда добавили или удалили патч):
$ quilt refresh

Если необходимо отменить локальные изменения, можно сделать:
$ dpkg-source --commit
$ patch -p1 -R < new.patch
$ quilt delete new

Если `.pc` больше нет, можно добавить: export QUILT_PATCHES=debian/patches
$ quilt push -a

--

Немного про `debian/changelog`, `dch` и `.changes`:

Предположим, что в пакете нашли ошибку (номер #654321), и описываемую там
проблему можно решить. Включите краткое описание ошибки и её решение в список
изменений `changelog`, сопроводив текстом Closes: #654321. Это позволит
автоматически закрыть сообщение об ошибке с помощью программного обеспечения
обслуживания архива в тот момент, когда ваш пакет будет принят в архив Debian.

Не удаляйте старые записи из `changelog` (на первый взгляд это очевидно, но были
случаи случайного набора `dch` вместо `dch -i`)

Проверьте содержимое файла `.changes` и убедитесь, что вы выполняете отправку в
правильный дистрибутив, закрываемые ошибки перечислены в поле `Closes`, поля
`Maintainer` и `Changed-By` совпадают, файл подписан GPG и т.д.

Дату (RFC 5322 формат) для `debian/changelog` можно получить таким образом:
$ date -R


--- DEB переменные
`DEB_BUILD_OPTIONS`
Эта переменная окружения хранит различные флаги и `debian/rules` создает пакет в
соответствии с этой переменной.

nocheck  # не запускать тесты
noopt    # минимальная оптимизация -O0
nostrip  # отладочные символы НЕ будут удалены
debug    # будет включена отладочная информация
noddebs  # отказ от dbgsym пакетов

Можно экспортировать:
$ export DEB_BUILD_OPTIONS='nocheck noopt nostrip debug'

Можно настроить `~/.devscripts`:
DEBUILD_DPKG_BUILDPACKAGE_OPTS="-us -uc -I -i"
DEBUILD_LINTIAN_OPTS="-i -I --show-overrides"
Тогда вызов команд будет без флагов (они уже будут указаны).

Большинство программ, учавствующих в сопровождении пакета, будет искать имя и
адрес электронной почты в переменных окружения DEBFULLNAME, DEBEMAIL, EMAIL.
В `~/.bashrc` можно прописать:
$ export EMAIL="hertzog@debian.org"
$ export DEBFULLNAME="Raphael Hertzog"

`DEBIAN_FRONTEND`
Установка пакетов без интерактивных режимов (вопросов, которые могут тормозить
процесс установки). Вместо этого будут установлены значения по-умолчанию:
$ DEBIAN_FRONTEND=noninteractive apt-get -y install $pack

Часто встречается в `debian/rules`:
export DEB_LDFLAGS_MAINT_APPEND=-Wl,-O1 -Wl,-z,defs
DEB_LDFLAGS_MAINT_APPEND=-Wl,--as-needed
Добавляет дополнительные флаги для компоновщика (linker).

Префикс `-Wl,` используется для передачи последующих параметров непосредственно
компоновщику `ld`. -Wl используется только для линковки (LDFLAGS)
Передавать надо так: -Wl, ..., -Wl, ...

-z,defs: чтобы компоновщик проверил наличие всех необходимых символов на этапе
связывания. Компоновщик обнаружит, что отсутствуют необходимые символы, он
сообщит об этом и завершит сборку с ошибкой. Это полезно, потому что позволяет
выявить проблемы со связыванием на этапе сборки, а не в процессе выполнения
программы, что может быть гораздо сложнее для диагностики и исправления.

--as-needed: говорит компоновщику включать только те динамические библиотеки,
которые действительно необходимы для исполняемого файла. Это может привести к
уменьшению числа зависимостей и размера исполняемого файла, улучшению времени
загрузки программы и снижению потребления памяти.

Часто встречается в `debian/rules`:
export DEB_BUILD_MAINT_OPTIONS=hardening=+all
Повышает безопасность скомпилированного кода, добавляя защитные механизмы, такие
как защита от переполнения буфера или случайное расположение адресного
пространства.


--- Подробнее про --as-needed
Since Debian 11 (bullseye) the line with "Wl,--as-needed" is no longer needed,
as on GNU/* systems this flag is now passed by default to the linker by gcc.
Явное указание больше НЕ требуется:
export DEB_LDFLAGS_MAINT_APPEND= -Wl,--as-needed

Но всё же лучше проверить лог сборки пакета, если там будет указан --as-needed,
то указание не требуется.

Этот флаг заставляет компоновщик линковать библиотеки только в том случае, если
они действительно необходимы для разрешения символов:
$ gcc -o my_program my_program.c -Wl,--as-needed -lmylib

И чтобы проверить разницу между двумя бинарными файлами (без --as-needed и с
--as-needed), можно воспользоваться утилитами `ldd` и `size`.


--- debug packages
Пакеты с отладочной информацией собираются с:
DEB_BUILD_OPTIONS='nocheck noopt nostrip debug'

Если установить пакет и запустить `gdb`, он скажет 'file.c: No such file or directory'
Необходимо так же перенести исходные коды на отладочную гостевую:
$ scp -r path/to/dir .

Пакет может иметь файлы конфигурации, например как в `dovecot`:
`/etc/dovecot/conf.d/10-logging.conf`
Можно включить отладочную информацию и подобное.


--- debconf
Инструмент `debconf` в Debian используется для управления конфигурацией пакетов.
Он предоставляет централизованную систему для настройки пакетов, которая
позволяет пользователям отвечать на вопросы конфигурации во время установки или
обновления пакетов. Это помогает автоматизировать и упростить процесс настройки
программного обеспечения.

`debconf` работает с различными интерфейсами, такими как текстовый интерфейс,
графический интерфейс, или интерфейс на основе консоли. Он хранит ответы на
вопросы конфигурации в базе данных, что позволяет избежать повторного запроса
той же информации при обновлении или переустановке пакетов.

Например, во время установки данного пакета будут задаваться вопросы (это работает `debconf`):
$ sudo apt-get install postfix

Повторно запустить конфигурацию пакета, откроется `debconf`:
$ sudo dpkg-reconfigure tzdata

Посмотреть текущие настройки пакетов:
$ sudo debconf-get-selections

Для просмотра конфигурации:
$ debconf-show console-setup

Можно перед установкой пакета подготовить необходимую конфигурацию:
$ echo "package_name  package_template  select  value" > preseed.txt
$ sudo debconf-set-selections < preseed.txt
$ sudo apt-get install package_name -y

Для изменения настроек:
$ echo "package_name  package_template  select  new_value" > new-selections.txt
$ sudo debconf-set-selections < new-selections.txt


--- Скачать разные версии пакета
Прописать:
deb-src http://deb.debian.org/debian bullseye main contrib non-free
deb-src http://deb.debian.org/debian buster main contrib non-free
deb-src http://deb.debian.org/debian stretch main contrib non-free

Узнаем какие версии пакета доступны:
$ apt-cache madison glibc-source

Получить версию 2.28-10:
$ apt-get source glibc-source=2.28-10+deb10u1


--- dist-upgrade с исключением
$ apt-mark hold <package>
$ apt-get dist-upgrade
$ apt-mark unhold <package>


--- Разбор версий
1.9.0.1

1 - Major revision
Мажорная версия - та версия, в которой можно полностью менять
поведение, API, удалять старый код и т.д.

9 - Minor revision
Предназначена для добавления нового функционала или внесения изменений,
которые соблюдают обратную совместимость.

0 - Bug fix
Исправление багов, CVE fixed и т.д.

1 - Build number (номер сборки - CI) Идет после символа '+'

------------------------------------------------------------------
Разбор: 1:9.18.19-1~deb12u1 -> [epoch:]upstream_version[-debian_revision]

* epoch
1: (epoch) В changelog можно заметить такие случаи появления epoch. Например,
если был bison (1.25-1) experimental; urgency=low, затем стал bison (1:1.25-1)
unstable; urgency=low. Еще пример, был bison (1:2.6.2.dfsg-1), затем понизили
версию до 2.5.dfsg-3, соотвественно полностью стал: 2:2.5.dfsg-3, epoch
изменился с 1 на 2. Если были сделаны изменения, которые несовместимы с
предыдущими версиями, надо менять epoch.

* upstream_version
9.18.19 - это major / minor / bug fix
Эта версия берется от original source package (*.orig.tar.xz)

* -debian_revision
-1
Версия Debian пакета.
Относится конкретно к дебианизации -1 это номер debian ревизии.
Эта версия берется от source package (*.dsc и *.debian.tar.xz).
После изменений в debian/ мета-информации, сборочных скриптов и т.д.

* дополнительная метка
~deb12u1
Версия Debian пакета в системе Debian 12.1.
Какие-то исправления для Debian безопасности.
------------------------------------------------------------------

------------------------------------------------------------------
Разбор: 2:3.8.2+dfsg-1+b1
2      epoch
3.8.2  upstream_version (major/minor/bugs)
+dfsg  дополнительная метка (не содержит несвободное ПО)
-1     -debian_revision (номер debian ревизии)
+b1    номер сборки (изменения внесенные в пакет при его компиляции или сборке)
------------------------------------------------------------------

Бывают еще стадии разработки в версии.
Есть еще pre-alpha, когда прям сырой код, ведется разработка.

* alpha
начало тестирования программы, выпуск для ознакомления

* beta
стадия активного бета-тестирования и отладки программы, обычно такие программы
имеют кучу ошибок, такой продукт так же проверяют и тестировщики и разработчики

* rc
программы этой стадии прошли всё тестирование, и почти готовы стать стабильными,
но могут иметься некоторые ошибки, которые не были найдены при тестировании

* stable
финальная стадия


--- eatmydata
В мейнтейнерской среде часто используется инструмент `eatmydata` для ускорения
установки пакетов и выполнения операций. Этот инструмент позволяет временно
отключить синхронизацию данных на диске, что может значительно ускорить
выполнение операций ввода-вывода. Однако, следует помнить, что использование
`eatmydata` может повлечь за собой потерю данных в случае аварийного отключения
компьютера или других проблем. Поэтому его использование следует рассматривать с
осторожностью и только в тех случаях, когда ускорение работы действительно
необходимо.

$ eatmydata apt-get install <a lot of packages>


--- Репозитории и зеркала
Репозиторий - это сервер или хранилище, где хранятся пакеты программного
обеспечения для операционной системы. Зеркало (mirror) - это копия репозитория,
распределенная по различным серверам или местоположениям для обеспечения
быстрого доступа и загрузки пакетов пользователями. Зеркала позволяют
распределять нагрузку, обеспечивать отказоустойчивость и улучшить скорость
загрузки пакетов.


--- Игнорировать Recommends, установка Suggests
Существуют пакеты, которые ставят рекомендуемые пакеты, тем самым загрязняют
систему. Например, пакет `neofetch` (который вместе с ним устанавливает `w3m`,
`w3m-img` и подобные), хотя без этих пакетов он так же отлично работает.
Можно использовать опцию:
$ sudo apt-get install neofetch --no-install-recommends

А можно создать конфигурационный файл `/etc/apt/apt.conf.d/99_norecommends` и прописать:
APT::Install-Recommends "false";
APT::AutoRemove::RecommendsImportant "false";
APT::AutoRemove::SuggestsImportant "false";

Установить Suggests можно так:
$ sudo apt-get install <pkg> --install-suggests


--- debian/rules по умолчанию
Что означает конструкция:
%:
	dh $@

Этот фрагмент в `debian/rules` означает, что все цели сборки будут переданы
утилите dh (debhelper), которая затем вызовет все необходимые утилиты для
сборки пакета Debian. В данном случае, `$@` будет заменен именем цели сборки,
переданным в командной строке. Таким образом, это правило обобщенно определяет
обработку всех целей сборки в файле `debian/rules`.

`%` - это Makefile-шаблон, который означает "любой целевой объект". Когда
`debian/rules` вызывается с определенной целью, например, `build`, `clean`,
или `binary`, `Makefile` интерпретирует это как совпадение с шаблоном `%`
и передает эту цель утилите `dh`.

Debhelper: dh (Debhelper) предоставляет ряд стандартных целей для создания
пакетов, таких как:

debian/rules build: Компиляция исходного кода.

debian/rules clean: Очистка директории от файлов сборки.

debian/rules install: Установка собранного пакета в директорию временной
установки.

debian/rules binary: Создание бинарного пакета Debian.

debian/rules binary-arch и debian/rules binary-indep: Создание
архитектурно-зависимых и независимых бинарных пакетов соответственно.

Например:
Установка собранного кода: $ debian/rules install
Используется для создания бинарного пакета: $ debian/rules binary

Если выполнить $ debian/rules build, это эквивалентно вызову $ dh build
Вызывает `debian/rules` с определенными аргументами `dpkg-buildpackage` или
`debuild` (смотреть `--- Разбор этапов dpkg-buildpackage`).

Например, при запуске `debian/rules clean` выполняется команда `dh clean`,
которая запускает другие:
dh_testdir
dh_auto_clean
dh_clean

При `debian/rules build` выполняется команда `dh build`, которая запускает другие:
dh_testdir
dh_auto_configure
dh_auto_build
dh_auto_test
и т.д и т.п.

Важно отметить, что `debian/rules` файл вызывает `./configure`, и там можно
указывать определенные вызовы данного скрипта, например:

override_dh_auto_configure:
 ./configure --disable-perl-regexp

или

DEB_CONFIGURE_EXTRA_FLAGS += --disable-perl-regexp

Перед этим можно изучить какие опции поддерживает `configure`:
$ ./configure --help

`debian/rules` usually the file maintainers spend the most time on.
Убедитесь, что правила сборки корректны и соответствуют современным стандартам.
Используйте `debhelper` и минимизируйте использование устаревших или сложных
команд.


--- UNRELEASED
gentoo (0.9.12-1) UNRELEASED; urgency=low

  * Non-maintainer upload
  * ...

 -- Ivan Ivanov <ivan@debian.org>  Mon, 22 Mar 2010 00:37:31 +0100

UNRELEASED лучше использовать на момент создания пакета. После проверки
правильности всех изменений и их описания в `changelog`, можно поменять имя
выпуска с UNRELEASED на значение целевого дистрибутива `unstable`
(или даже на `experimental`).

Если вы измените дистрибутив в changelog с UNRELEASED на `unstable` и загрузите
пакет в Debian, он будет направлен в репозиторий `unstable`, при условии, что
все проверки пройдены успешно.

Важно помнить, что плохо написанные файлы создают плохое представление о вашем
пакете, вашей работе... и даже самом Debian. Еще отмечу, что лучше не стоит
использовать "he/she" гендерное значение, а лучше использовать "maintainer".


--- Non-maintainer upload
Когда кто-то, кто не является официальным сопровождающим (maintainer) пакета,
вносит изменения и создает новую версию пакета, это называется "Non-maintainer
upload" (NMU). Эта запись указывает на то, что изменения были внесены кем-то
другим, а не основным сопровождающим пакета.

NMU обычно используется для быстрого исправления ошибок, добавления патчей
безопасности или других необходимых обновлений, когда основной сопровождающий
не может сделать это вовремя. В таком случае обычно рекомендуется связаться с
основным сопровождающим и уведомить его о предстоящих изменениях.


--- Иерархия команд сборки
debian/rules = сценарий сопровождающего для сборки пакета

dpkg-buildpackage = ключевой инструмент сборки пакета

debuild = dpkg-buildpackage + lintian
(сборка при проверенных переменных окружение)

pbuilder = ключевой инструмент chroot-окружения Debian

pdebuild = pbuilder + dpkg-buildpackage (сборка в chroot)
можно настроить lintian в конце сборки

Различие между `pbuilder` и `pdebuild`:
pbuilder - это инструмент для создания chroot-среды и выполнения сборки пакета
внутри этой среды. Он гарантирует, что сборка пакета выполняется в изолированной
и чистой среде, что помогает избежать проблем с зависимостями и конфликтами.

pdebuild - это интерфейс к `pbuilder`, который интегрирует его с системой сборки
Debian-пакетов. Он позволяет использовать `pbuilder` для сборки пакетов, но с
более удобным интерфейсом. `pdebuild` автоматически запускает `pbuilder` для
выполнения сборки пакета, используя текущую директорию как источник пакета.
`pdebuild` это как бы обертка над `pbuilder`.


--- Как предотвратить дублирование файлов (столкновение с другими пакетами)
To prevent installation problems on different systems, you must make sure that
there are no filenames conflicting with other existing packages, using the
`Contents` file downloaded from the Debian archive. The `apt-file` command may
be handy for this task. If there are collisions, please take action to avoid
this real problem, whether by renaming the file.

For example: https://ftp.debian.org/debian/dists/bookworm/main/Contents-all.gz

Файл `Contents-all` в Debian архиве содержит список всех файлов, содержащихся во
всех пакетах, доступных в архиве для архитектуры `all`. Архитектура `all`
означает, что пакеты предназначены для всех архитектур (например, они не
содержат архитектурно-зависимого кода). Этот файл не включает файлы
архитектурно-зависимых пакетов (например, `amd64`, `i386` и т.д.).

Для архитектурно-зависимых файлов существуют аналогичные файлы, такие как
`Contents-amd64`, `Contents-i386` и т.д., которые содержат список всех файлов
для соответствующих архитектур.


--- Проверка пакета на ошибки
$ debi <pack>.changes
* Читает файл <pack>.changes, чтобы найти связанные с ним файлы пакетов `.deb`.
* Проверяет контрольные суммы и другие метаданные, чтобы убедиться в целостности
  и корректности файлов.
* Устанавливает или обновляет пакеты `.deb`, указанные в файле `.changes`.

$ sudo dpkg -r <pack>
Удаляет установленный пакет, но оставляет его конфигурационные файлы (статус
пакета `rc`). Например, какие конфигурационные файлы остаются?
Можно посмотреть командой:
$ dpkg -L <pack>

$ sudo dpkg -P <pack>
Полностью удаляет пакет, включая его конфигурационные файлы.

$ sudo dpkg -i <pack>
Устанавливает пакет.

Какие шаги можно сделать при тестировании пакета?

* установите предыдущую версию пакета

* обновите пакет с предыдущей версии
$ dpkg -i *.deb

* откатитесь на предыдущую версию
$ dpkg -i *.deb
dpkg: warning: downgrading mc-data from 3:4.8.31-1 to 3:4.8.29-2

* вычистите пакет
$ apt-get purge <pack>

* установите новый пакет

* удалите его
$ sudo apt-get remove <pack>

* установите опять

* вычистите пакет

Убедитесь, что очищенный пакет убран полностью, то есть, очистка должна удалить
любые напрямую или косвенно созданные любым сценарием сопровождающего файлы.
Убедиться можно с помощью `piuparts`.

+ еще можно развернуть репозиторий с помощью `reprepro` и попробовать установить
от туда новые пакеты. (смотреть `--- Backporting packages`).

Не забудьте проверить наличие в Debian предыдущей версии программы, которую вы
пакетируете. В этом случае пользователи, у которых установлена предыдущая
версия, могут захотеть обновить пакет и вам следует убедиться в отсутствии
проблем при таком обновлении. Также протестируйте обновления и с этой версии.
Хотя откат к предыдущей версии официально не поддерживается, будет здорово
обеспечить такую возможность.

Для сравнения двух разных патчей из `debian/patches/*` можно воспользоваться
утилитой `interdiff`.
$ interdiff old_patch.diff new_patch.diff > changes.diff

Можно сравнивать пакеты (пакетная разница, какие изменения были сделаны):
$ debdiff старый-пакет.dsc новый-пакет.dsc
$ debdiff старый-пакет.changes новый-пакет.changes

Можно просмотреть список файлов в двоичном пакете Debian с помощью команды `debc`:
$ debc <pack>.changes

Можно проверить правильность пакета:
$ lintian -i -I --show-overrides <pack>.changes --tag-display-limit 0
$ lintian -i -I --show-overrides <pack>_source.changes --tag-display-limit 0

Вывод:

E: - ошибка; нарушение политики или ошибка пакетирования.

W: - предупреждение; возможное нарушение политики или ошибка пакетирования.

I: - для информации; сведения о некоторых аспектах пакетирования.

N: - замечание; уточнение, помогающее при отладке.

O: - скрытые сообщения; информация, скрываемая на основе файла
`lintian-overrides`, но показываемая при указании параметра `--show-overrides`.

Если вы видите предупреждения - исправьте пакет, чтобы их не было или убедитесь,
что это нормально. Если предупреждения излишни - настройте файл `lintian-overrides`.


--- Какие пакеты были установлены за день
Для подобных задач можно отслеживать файл:
`/var/log/apt/history.log`


--- Сравнение версий пакетов с помощью dpkg
$ dpkg --compare-versions 1.0.0 lt 1.0.1
$ echo $? # 0
$ dpkg --compare-versions 1.0.2 lt 1.0.1
$ echo $? # 1

- gt - "greater than" (больше чем)
- ge - "greater than or equal to" (больше или равно)
- lt - "less than" (меньше чем)
- le - "less than or equal to" (меньше или равно)
- eq - "equal to" (равно)


--- dget
Используется для загрузки исходных пакетов (source packages) из репозиториев.
Он может загружать файлы `.dsc` и все связанные с ними файлы исходного кода,
такие как `.orig.tar.gz` и `.debian.tar.xz`. Это полезно, когда вы хотите
получить исходный код пакета для его изучения, модификации или пересборки.

Скачает все необходимые исходные пакеты:
$ dget http://deb.debian.org/debian/pool/main/h/hello/hello_2.10-2.dsc

С dpkg-source -x:
$ dget -x http://deb.debian.org/debian/pool/main/h/hello/hello_2.10-2.dsc

Скачает пакет из репозиториев, которые прописаны в `/etc/apt/sources.list`:
$ dget -u hello


--- debdiff
debdiff - это утилита из пакета `devscripts`, используемая для сравнения двух
Debian-пакетов или их исходных пакетов, чтобы увидеть различия между ними. Это
может быть полезно для разработчиков и мейнтейнеров пакетов, когда нужно понять,
что изменилось между двумя версиями пакета.

Сравнение двух бинарных пакетов:
$ debdiff package1_version1_arch.deb package2_version2_arch.deb

Сравнение двух .dsc файлов:
$ debdiff package1_version1.dsc package2_version2.dsc

На свой страх и риск:
$ debdiff source_package_version.dsc binary_package_version_arch.deb


--- interdiff
interdiff - это инструмент, используемый для сравнения двух патчей и вывода
различий между ними. Он полезен для разработчиков, которые хотят увидеть, как
изменился патч между двумя версиями.

Посмотреть изменения между двумя патчами:
$ interdiff patch1.diff patch2.diff

Еще пример:
$ git diff commit1 commit2 > patch1.diff
$ git diff commit2 commit3 > patch2.diff
$ interdiff patch1.diff patch2.diff


--- Утилиты для вкладчиков
$ wnpp-alert
Показывает для каких пакетов в системе присутствуют заявки в WNPP. Это помогает
пользователям и разработчикам узнать, какие пакеты нуждаются в помощи или
поддержке.

$ manpage-alert
Показывает для какого ПО в системе отсутсвуют man страницы.

$ how-can-i-help
Выводит список задач или багов, связанных с установленными пакетами, которые
нуждаются в работе. Это мотивирует пользователей участвовать в развитии и
поддержке Debian.

$ who-uploads <package>
Показывает, кто загрузил конкретный пакет в архив Debian. Это может быть полезно
для выяснения, кто отвечает за поддержку или обновление конкретного пакета.

$ rc-alert
Отображает ошибки уровня критичности release-critical (RC) для установленных
в системе пакетов. Такие ошибки могут помешать выпуску новой версии Debian,
поэтому их исправление является приоритетным.

$ reportbug
Сообщить о баге. Создать тикет в BTS.

$ whodepends <package>
Какие пакеты зависят от указанного пакета (косвенно).

$ dd-list <package>
Какие люди отвечают за данное ПО.

Чем занимаются люди в проекте Debian:
https://qa.debian.org/developer.php?login=<email>

Очень удобно смотреть информацию о пакете:
https://tracker.debian.org/pkg/<package>

$ mass-bug
Используется для массовой отправки отчетов об ошибках в пакеты Debian (BTS).
Например, если в баге взаимодействованы один и более пакетов, то лучше
использовать данный инструмент.


--- Утилиты для тестирования пакетов
$ adequate <package>
$ adequate --all
Помогает в тестировании пакетов, находит ошибки, проблемы, неправильные
зависимости и т.д.

$ dpkg-parsechangelog
$ dpkg-parsechangelog -n <number> # показать несколько записей
Выводит в удобном формате последнюю запись в debian/changelog.

$ licensecheck <path>
$ licensecheck -r <path>
Используется для автоматического определения лицензий файлов в проекте.
Она анализирует исходный код и файлы проекта, чтобы найти лицензии и их
соответствующие типы.

*No copyright* UNKNOWN
Забыли добавить лицензию в исходный файл.

- Проверьте актуальность информации о лицензии.

- Убедитесь, что все файлы покрыты правильными лицензиями и ссылки на лицензии
  правильны.

$ duck
$ duck -v <path>
Проверят URL ссылки в Debian-пакетах. Используется для автоматического
тестирования ссылок, чтобы убедиться, что они не ведут на неработающие или
устаревшие страницы.

Запускает команду сборки в режиме отслеживания зависимостей, необходимых для сборки.
$ dpkg-depcheck <build-command>
$ dpkg-depcheck <debian/rules build>

Результат может быть добавлен в `Build-Depends` и не только:
$ dpkg-depcheck -b dpkg-buildpackage -b -uc

Результат может быть добавлены в `Recommends` и `Suggests`:
$ dpkg-depcheck -d dpkg-buildpackage -b -uc

Помогает определить, какие пакеты необходимы для сборки другого пакета,
анализируя его поведение при сборке. Выполняет "strace" (слежение за системными
вызовами) за процессом сборки и на основе этого выводит список зависимостей.

Можно использовать `lsof` для того, чтобы понять какие библиотеки, файлы
использует пакет/программа, например, в одном терминале запустить программу:
$ mc

А в другом терминале:
$ lsof -c mc

Отследит открытые файлы и библиотеки, которые использует.

$ piuparts
(смотреть `--- piuparts`).

$ blhc /path/to/build.log
$ blhc --all --debian --arch=amd64 /path/to/build.log
Проверяет журналы сборки пакетов на наличие проблем, связанных с флагами
компиляции, такими как флаги для повышения безопасности.


--- getbuildlog
Утилита из пакета `devscripts`, которая предназначена для скачивания логов
сборки пакетов из архивов сборок Debian.

Скачать последний лог сборки:
$ getbuildlog <package> last amd64

Скачать все логи сборок:
$ getbuildlog <package> "" amd64


--- buildd
На серверах Debian пакеты автоматически собираются с помощью `buildd`. Buildd
(build daemon) для Debian - это система автоматической сборки пакетов. Она
используется для компиляции исходных пакетов в бинарные пакеты на различных
архитектурах. Вот основные аспекты `buildd`:

1. Автоматизация: Buildd автоматически берёт исходные пакеты из репозитория
Debian и компилирует их в бинарные пакеты для различных аппаратных архитектур.

2. Архитектурная поддержка: Debian поддерживает множество архитектур, и
`buildd` помогает обеспечить, чтобы каждый пакет был собран и протестирован на
всех поддерживаемых архитектурах.

3. Инфраструктура: Buildd состоит из множества машин (или виртуальных машин),
каждая из которых настроена для работы с определённой архитектурой.

4. Отчёты о сборке: После сборки `buildd` создаёт лог файлы, которые содержат
информацию о процессе сборки. Эти логи помогают разработчикам и сборщикам
пакетов выявлять и исправлять ошибки.

5. Координация и управление: Процессами сборки управляют определённые службы и
инструменты, такие как `sbuild` и `wanna-build`, которые координируют, какие
пакеты должны быть собраны, и отслеживают их статус.


--- pbuilder vs sbuild
Оба инструмента, `pbuilder` и `sbuild`, хороши для сборки пакетов в Debian, но
`sbuild` предпочтительнее для интеграции с инфраструктурой Debian, так как он
используется на их официальных сборочных серверах.
