Темы:
* Репозиторий
* Подпись
* Получение исходного пакета
* Описание исходного пакета
* Структура deb пакета
* Зависимости, общая информация
* Зависимости из других разделов
* Виртуальные пакеты
* Метапакеты
* Где собирать исходники
* fakeroot
* Создание бинарного пакета (дебианизация)
* Пакеты из sid для bookworm (тесты)
* Backporting packages
* Основные пакеты для сопровождающего
* dpkg -i *.deb и зависимости
* Lintian ошибки
* Где брать готовые бинарные пакеты
* piuparts
* debian/rules with verbose
* dpkg-buildflags
* hardening=+all
* hardening-check
* fzf, fzy, ripgrep
* udeb и dbgsym пакеты


--- Репозиторий
Репозиторий - это место, где хранятся и поддерживаются какие-то данные. Если
рассматривать конкретно к Debian, то репозиторий - это файловый сервер, который
хранит у себя пакеты для установки на операционную систему. Это могут быть как
пакеты программ, так и обновления для сервера в виде новых ядер, системных
утилит и т.д. Существует репозитории не только для ОС, но и для программ, там
могут хранится скомпилированные и готовые к установке пакеты, так и исходные
коды ПО. Помимо официальных репозиториев, есть сторонние, которые поддерживают
производители программ либо энтузиасты. Нужно внимательно относится к сторонним
репозиториям, не добавлять их бездумно (там может быть любое ПО).

Репозиторий в `sources.list` имеет структуру:

deb http://site.example.com/debian distribution component1 component2 component3
deb-src http://site.example.com/debian distribution component1 component2 component3

`apt` знает как обращаться с `http`, `ftp`, `file` (локальные файлы, напр.,
каталог, содержащий смонтированную ФС ISO9660), может быть еще и `ssh`.

* deb
  бинарные пакеты

* deb-src
  пакеты с исходным кодом

* http://site.example.com/debian
  url репозитория

* distribution
  псевдоним релиза, ключевое слово, либо класс релиза (stable, old и т.д)

* component
  main, contrib или non-free набор пакетов, находятся в pool/

Классы релиза, типы репозиториев Debian:
* oldstable       # старый поддерживаемый stable
* stable          # используется на производстве
* testing         # только для тестовых целей, переходит в stable
* unstable (sid)  # самое свежее, но непротестированное ПО
* experimental    # пакеты и утилиты, которые только разрабатываются (alpha)
* stretch         # 9 debian
* buster          # 10 debian
* bullseye        # 11 debian
* bookworm        # 12 debian
и т.д.

Есть так называемые Security Updates, отдельные репозитории в которые попадают
только обновления безопасности и ничего другого. Обновление сюда попадают
максимально быстро после выпуска исправлений.

* main
  эти пакеты считаются частью дистрибутива Debian, им не требуются какие-то
дополнительные пакеты/зависимости из `contrib` или `non-free`.

* contrib
  этим пакетам (зависимостям) могут потребоваться доп.ПО, которое может быть в
  других источниках, например `non-free`, то есть может потребоваться несвободное ПО.

* non-free
  содержит все остальное ПО (несвободное - несоответствует принципа СПО).

* non-free-firmware
  несвободные прошивки, которые доступны по умолчанию. хранятся драйверы и
  другие компоненты, которые содержат закрытый исходный код или несвободные
  лицензии.

Можно создать локальный репозиторий, он будет использоваться только на данном
ПК, собирать пакеты, класть в этот локальный репозиторий с другими, и
прописывать их в `sources.list` и делать установку от туда.


--- Подпись
Для обеспечения безопасности пользователей репозитории должны подписываться
ключами шифрования. Чтобы гарантировать, что установка пакетов ПО производится
из надежного источника. Владельцы репозиториев, подписав его своим закрытым
ключом, выкладывают в общий доступ соответствующий открытый ключ для этого
репозитория. Открытый ключ необходим для добавления удалённого подписанного
репозитория, это контролируется средствами СУП `apt`. Если ставить пакеты из НЕ
подписанного репозитория, там может быть абсолютно любое ПО, в том числе
злоумышленников и хакеров. При импорте ключа, будет запрос к серверу ключей, на
котором хранится закрытая часть ключа. Нужно поставить 'dirmngr' перед запросом
ключей. Иногда может появится ошибка, что ключ устарел (его поменяли) и нужно
добавить новый, а иногда просто NO_PUBKEY (означает, что нужно просто добавить
ключ).

Запрос:
$ gpg --keyserver pgp.mit.edu --recv ${KEY}

Добавление в систему:
$ gpg --export ${KEY} | sudo apt-key add -

Коротко:
$ apt-key adv --keyserver pgp.mit.edu --recv-keys ${KEY}


--- Получение исходного пакета
В `/etc/apt/sources.list` должен быть тип архива `deb-src`.

$ apt-get download <pack>   # скачать бинарный пакет
$ apt-get source <pack>     # скачать исходники
$ dpkg-checkbuilddeps       # проверяет наличие неустановленных Build-Depends из debian/control
$ apt-get build-dep <pack>  # установка Build-Depends зависимостей из debian/control
$ apt-cache showsrc <pack>  # так можно посмотреть Build-Depends

Например, изменили что-то в исходниках, затем нужно:
$ dch                                  # изменения в changelog
$ dpkg-source --commit                 # создание нового патча
$ dpkg-source --before-build .         # применить патчи
$ dpkg-buildpackage -rfakeroot -b -uc  # сборка пакета

Но нужно быть аккуратным, при сборке могут непроходить некоторые тесты, поэтому
после изменений исходников, нужно подправить и другие компоненты (тесты).
Или можно просто добавить `DEB_BUILD_OPTIONS`.

Если нужны только исходники из системы контроля версий salsa:
$ debcheckout curl

Пример использования утилиты `debcommit`.

1. Предположим, вы внесли изменения в исходный код вашего Debian пакета и
обновили файл `debian/changelog`.

2. Теперь вы хотите зафиксировать эти изменения в системе контроля версий (например, git).
$ debcommit
Эта команда создаст коммит в вашей системе контроля версий с сообщением,
основанным на последнем изменении в файле `debian/changelog`.

Пример использования `debrelease`.
Предположим, пакет собран и его нужно отправить в архив/сервер.
Эта команда отправит собранные файлы пакета на указанный сервер, который
настроен в конфигурации.
$ debrelease

Если сервер требует использования определенного протокола (например, SCP или FTP),
можно указать:
$ debrelease -r scp:your.server.com:/path/to/repository


--- Описание исходного пакета
pack-version.dsc            # source package
                            # описание пакета + суммы исходных архивов,
                            # данный файл подписан (подлинный)

pack-version.debian.tar.gz  # source package
                            # содержимое debian/ директории

pack-version.orig.tar.gz    # original source package
                            # содержимое исходных текстов, src, tests, libs и другие

pack-version*.changes       # содержит информацию о версии пакета, изменениях,
			    # которые были внесены в данной сборке, и другие
			    # метаданные о пакете. инженеры, загружающие пакет,
			    # могут посмотреть этот файл и сразу понять, что
                            # было изменено.

The `pack-version.dsc` and `pack-version*.changes` files must be signed using
the `debsign` command with your private GPG key in the `~/.gnupg/` directory,
before uploading them to the Debian FTP archive. The GPG signature provides the
proof that these files are really yours, using your public GPG key.

Для подписывания пакета Debian вашим закрытым GPG-ключом используется команда
`debsign`, входящая в состав пакета devscripts. (смотреть `Подпись пакета`).

* Управляющие файлы пакета: control файл, скрипты и файлы подсистемы debian

debian/rules                # Makefile осуществляет сборку пакета
                            # сценарий сопровождающего для сборки пакета

debian/control              # текстовый файл (описание)

Каждый пакет и каждые исходники, хранят в себе файл `control`. В самом `.deb`
пакете этот файл хранится в архиве `control.tar.gz`. В исходниках, хранится
в `debian/control`. Базы `apt` и `dpkg` хранятся в этом же формате.

debian/changelog            # изменения в проекте

debian/alternatives         # альтернативная версия

Некоторые терминальные пакеты используют это ключевое слово как ссылку на свой
терминал, например, `x-terminal-emulator` -> `xfce4-terminal`, такое можно
реализовать с помощью `debian/alternatives`.

debian/format               # формат пакета, современный формат 3.0
                            # 3.0 (native) - для родных Debian пакетов (lintian, dpkg, etc.)
                            # 3.0 (quilt) - для остальных пакетов

			    # для 3.0 (quilt) изменения записываются в виде
                            # серии заплат quilt в каталог debian/patches

При использовании старого формата пакета с исходным кодом 1.0 создавался один
большой файл `diff.gz`, который содержал файлы сопровождения в debian и заплаты
к исходному коду. Такой пакет немного громоздок для проверки и понимания каждого
изменения дерева исходного кода. Это не так уж хорошо. В новом формате 3.0
(quilt) заплаты хранятся в файлах `debian/patches/*` для создания которых
применяется команда `quilt`.

debian/compat               # версия debhelper

Файл `debian/compat` используется в пакетировании для Debian и его производных
(например, Ubuntu) с целью указания версии инструментария `debhelper`, который
будет использоваться при сборке пакета. Содержимое файла `debian/compat` обычно
представляет собой одно число, которое указывает версию `debhelper`, с которой
пакет совместим. Например, если файл содержит число 11, это означает, что пакет
использует 11-ю версию `debhelper`.

В более новых версиях `debhelper` (начиная с версии 12), вместо использования
файла `debian/compat`, рекомендуется указывать совместимость в файле
`debian/control` с помощью поля `Build-Depends` и переменной `debhelper-compat`.
Например: Build-Depends: debhelper-compat (= 12)

debian/watch                # оригинальный адрес с исходниками, нужен для uscan

Файл `debian/watch` используется для автоматического обновления и загрузки новых
версий пакетов из исходных архивов. Он содержит информацию о местоположении,
формате и правилах для поиска обновлений пакетов. Формат файла `debian/watch`
может различаться в зависимости от используемого инструмента для обновления
пакетов. В данном файле можно увидеть что-то подобное: version=4 (это версия
формата `uscan`).

uscan - это инструмент, который используется для автоматического поиска и
загрузки новых версий пакетов на основе информации из файла `debian/watch`.

$ uscan --no-download
$ uscan --verbose
$ uscan

После выполнения данной команды, скачается архив с актуальной версией пакета
(только архив с исходниками), можно его распаковать, скопировать `debian/`
директорию из прошлого архива, и дополнить новыми данными:
$ dch -v <new-version> "New upstream release."
$ dpkg-buildpackage -b -uc

После сборки пакета появятся файлы:
<package>.dsc
<package>_source.changes
и т.д ...

debian/conffiles            # конфигурационные файлы пакета

Файл `debian/conffiles` используется для указания конфигурационных файлов
пакета. При обновлении пакета система управления пакетами (например, `dpkg`)
будет обрабатывать эти файлы особым образом, чтобы избежать перезаписи
пользовательских настроек. Содержимое `debian/conffiles` - это список путей
к конфигурационным файлам, один путь на строку.

Когда пакет обновляется, если конфигурационные файлы были изменены
пользователем, `dpkg` предложит несколько вариантов: сохранить пользовательские
изменения, заменить файлы новыми версиями из пакета, или попытаться объединить
изменения.

debian/<pack>.dirs          # директории пакета

Файл `debian/dirs` используется для указания директорий, которые должны быть
созданы при установке пакета. Это полезно, если пакет требует наличия
определенных директорий для корректной работы. Например, `Makefile` может
закончится ошибкой, если не существует нужных директорий.

debian/*cron.*              # cron задачи-скрипты пакета

Эти файлы будут скопированы в соответствующие каталоги `/etc/cron.d/`,
`/etc/cron.daily/`, `/etc/cron.hourly/`, `/etc/cron.monthly/`, или
`/etc/cron.weekly/` при установке пакета. Таким образом, задания cron
автоматически добавляются в систему при установке пакета.

debian/<pack>.doc-base      # документация отличная от man/info

Если пакет исползует документацию другого формата, необходимо пользоваться этим
файлом. Обычно к таким файлам относятся файлы в форматах HTML, PS и PDF,
помещаемые в `/usr/share/doc/имя_пакета/`.

debian/<pack>.docs          # файлы документации пакета

Содержит список файлов документации, которые должны быть установлены вместе с
пакетом. Это могут быть README-файлы, руководства и другие документы, которые
будут помещены в стандартные директории документации `/usr/share/doc/<pack>/`.

debian/<pack>.init          # init пакета

Используется для определения init-скрипта, который будет управлять запуском и
остановкой сервиса. Этот скрипт будет установлен в `/etc/init.d/` и использован
для управления сервисом через стандартные команды (`start`, `stop`, `restart`)

debian/<pack>.default       # /etc/default пакета

Используется для установки значений по умолчанию для переменных окружения,
которые могут использоваться init-скриптом. Этот файл обычно копируется в
`/etc/default/` и содержит переменные и их значения, которые могут быть изменены
пользователем для настройки поведения сервиса.

debian/<pack>.install       # установка ПО пакета

Используется для указания файлов и директорий, которые должны быть установлены
в определенные места в файловой системе при установке пакета. В этом файле
указываются исходные файлы и целевые директории, куда они должны быть
скопированы. Это позволяет точно контролировать, какие файлы куда попадут при
установке пакета.

debian/<pack>.links         # символические ссылки пакета

Используется для создания символических ссылок (symlinks) при установке пакета.
В этом файле указываются исходные файлы и ссылки, которые должны быть созданы.
Например, можно указать, что нужно создать символическую ссылку из
`/usr/bin/foo` в `/usr/local/bin/foo`.

debian/lintian-overrides    # отменить предупреждения lintian

Этот файл используется для подавления определённых предупреждений и ошибок,
которые могут быть сгенерированы утилитой lintian. Lintian анализирует пакеты
Debian на наличие различных проблем и несоответствий стандартам. Если вы
считаете, что какое-то предупреждение или ошибка Lintian не актуальны для вашего
пакета, вы можете добавить их в этот файл, чтобы они не отображались при
проверке.

debian/lintian-profile      # настройка lintian

Этот файл используется для настройки профилей Lintian, инструмента для проверки
пакетов Debian на соответствие стандартам Debian Policy и обнаружение
потенциальных проблем. В этом файле можно указать, какие проверки Lintian
следует выполнить или пропустить для конкретного пакета. Настройка профиля
Lintian позволяет управлять выводом и уровнем предупреждений, которые генерирует
Lintian при проверке пакета, и сделать проверку более гибкой и настраиваемой для
конкретных потребностей и требований проекта.

debian/<pack>.symbols       # для shlibs

Этот файл используется для отслеживания изменений в символах (функциях,
переменных и т.д.) в библиотеках, которые могут повлиять на совместимость между
версиями пакетов. Этот файл помогает автоматизировать процесс обновления
пакетов, позволяя сборочной системе Debian узнать, какие символы были добавлены,
изменены или удалены в новой версии пакета. Это позволяет избежать ошибок и
конфликтов при обновлении пакетов и обеспечивает совместимость между различными
версиями пакетов.

* Немного про скрипты

В директории `debian/` могут быть и скрипты (конфигурации), скриптами не стоит
злоупотреблять и они должны отрабатывать так, чтобы целостность системы не
нарушалась при повтороном запуске. dh_make создает хороший шаблон данных
скриптов, лучше следовать ему и не усложнять. Не беспокойте пользователя меню
`debconf`, вызываемым из сценариев сопровождающего для обновления. Сценарии
сопровождающего являются сильной стороной Debian, из-за них люди выбирают
Debian. Нужно быть очень осторожны, чтобы не превратить их в источник
раздражения.

debian/<pack>.preinst   # выполняется перед установкой пакета (install)
debian/<pack>.postinst  # выполняется сразу после установки пакета (install)
debian/<pack>.prerm     # выполняется перед удалением пакета (rm) (зачистка)
debian/<pack>.postrm    # выполняется после удаления пакета (rm)

Вам следует убедиться, что не произойдёт ничего плохого в том случае, когда
сценарий будет вызван дважды, хотя обычно он вызывается только один раз.

* Дополнительные файлы пакета (появляются после сборки)

debian/<pack>/DEBIAN/conffiles  # список конфигурационных файлов пакета, абсолютные пути
debian/<pack>/DEBIAN/md5sums    # список MD5 сумм файлов пакета по одному файлу на строчку
debian/<pack>/DEBIAN/shlibs     # список разделяемых библиотек (shared)

Важно понимать, что директория DEBIAN имеет как бы сторону ФС и там можно
увидеть `usr/bin` и подобное.


--- Структура deb пакета
Скачанные из сети файлы помещаются на диск в каталог `/var/cache/apt/archives`
Если удалить из `/var/cache/apt/archives/<pack>` и заново установить пакет, он
будет скачиваться из сети по новой, если же наоборот, будет обращение к кэшу,
чтобы сэкономить ресурсы.

В директории `/var/lib/dpkg/info/` можно увидеть файлы различных пакетов,
скрипты, документации.

Файлы документации, `changelog` и подобного есть в `/usr/share/doc/<pack>`, там
хранится дополнительная информация о пакете, как им пользоваться и т.д.

Двоичный пакет deb - это обычный `ar` архив, состоит он из:
$ ar t <pack.deb>

debian-binary   # текстовый файл, содержит версию deb-пакета, 3.0 современный формат
control.tar.gz  # архив с управляющей информацией (control, conffiles, md5sums)
                # и скрипты, это называется мета-информация
data.tar.gz     # архив, содержащий дерево устанавливаемых файлов пакета
                # (исходники, документация, файлы, либы ..)
		# если этот архив разархивировать в корень системы, программа
                # как бы установится все файлы программы будут по своим местам

Мета-информация - это не только файлы пакета для установки, это так же описание
отношений с другими пакетами в системе Debian. Информация о другой информации.

Пакеты Debian - это не единственный формат пакетов, используемый в мире
свободного ПО. Основным конкурентом является формат RPM из дистрибутива Red Hat
Linux и его многочисленных производных. Red Hat - очень популярный коммерческий
дистрибутив (конкурент Debian). Не стоит использовать rpm пакеты в Debian, если
только использовать вместе с `alien`.


--- Зависимости, общая информация
Бинарные пакеты могут для свой корректной работы требовать наличия других,
отсутствия других, а также рекомендовать к установке другие пакеты, вместе с
которыми данные будут обеспечивать большую функциональность. Все эти поля хранит
файл `debian/control`.

Зависимости бинарного пакета:
Depends # Пакет не будет установлен до тех пор, пока перечисленные пакеты не
        # будут установлены.

Переменные вида:
${misc:Depends} ${perl:Depends} ${shlibs:Depends}
Значения этих переменных можно посмотреть: открыть бинарный пакет с помощью
`mc`, там будут эти Depends.

${misc:Depends}:
Эта переменная используется для добавления зависимостей, которые могут быть
определены различными инструментами сборки пакетов, например, `debhelper`.
Если ваш пакет использует `debhelper` (что часто так и бывает), то добавление
`${misc:Depends}` обеспечит включение всех необходимых зависимостей, которые
`debhelper` определяет автоматически.

${perl:Depends}:
Эта переменная используется для Perl-пакетов. Она автоматически добавляет
зависимости на другие Perl-модули, которые ваш пакет требует для работы.
Если ваш пакет написан на Perl или включает Perl-скрипты, то добавление
`${perl:Depends}` поможет правильно определить необходимые Perl-зависимости.

${shlibs:Depends}:
Эта переменная используется для добавления зависимостей, связанных с
библиотеками. Если ваш пакет ссылается на какие-либо общие библиотеки (например,
libc), то добавление `${shlibs:Depends}` обеспечит включение всех необходимых
библиотечных зависимостей.

Pre-Depends  # Эти зависимости дополняют 'Depends' зависимости.

Recommends   # Указывает на пакеты, которые рекомендуется устанавливать вместе с
             # данным пакетом, но это не обязательно.

Suggests     # Указывает на пакеты, которые могут быть полезны при использовании
	     # данного пакета, но не обязательны для его работы. Расширят
	     # возможности пакета, могут улучшить взаимодействие, добавить
             # документацию или еще что-то

Conflicts    # Указывает пакеты, вместе с которыми данный пакет работать НЕ может.

Replaces     # Указывает пакеты, файлы которых модифицируются этим пакетом.
	     # Требуется в случае создания патча, изменяющего что-либо.

Provides     # Указывает на виртуальные пакеты, которые предоставляются данным
	     # пакетом и могут использоваться другими пакетами как зависимости.
             # Пакеты Apache/Nginx предоставляют возможность демона httpd (виртуальный пакет).
	     # Например, у `mc` есть `Provides: mcedit` (виртуальный пакет).

Процесс сборки пакета не требует привилегий суперпользователя (root). Это
упрощает процесс сборки и делает его более безопасным, но это не касается
fakeroot:
Rules-Requires-Root: no

Зависимости сборки: Build-Depends, Build-Conflicts
Эти зависимости должны быть удовлетворены в тот момент, когда `debian/rules`
данного пакета вызывается с параметрами: `build`, `binary`, `binary-arch`,
`build-arch`, `build-indep` и `binary-indep`. Формат всех этих полей одинаков.
Он представляет собой список имён пакетов, разделённых запятыми.

Например, можно протестировать пакет, установить все Build-Depends и проверить,
собирается ли пакет, если нет - то нужно добавить еще какие-то зависимости.


--- Зависимости из других разделов
Пакеты, находящиеся в основной части репозитория (main), не должны зависеть от
пакетов из других частей репозитория (например, contrib или non-free) для
компиляции или выполнения.

Это значит, что:

- Пакет не должен требовать установки других пакетов из contrib или non-free для
  своей работы или сборки.
- Это касается зависимостей, указанных в полях Pre-Depends, Depends, Recommends,
  Build-Depends, Build-Depends-Indep и Build-Depends-Arch.
- Исключение допускается только в случае, если зависимость указана как
  альтернативная и по умолчанию используется пакет из main.

Таким образом, пакеты в main должны быть полностью самодостаточны и свободны от
несвободных компонентов.


--- Виртуальные пакеты
Виртуальный пакет не существует сам по себе, он служит для обозначения того, что
разные реальные пакеты могут предоставлять одинаковую функциональность. Другими
словами: виртуальные пакеты представляют собой абстракции, которые не содержат
собственных файлов, а служат для обозначения функциональности, предоставляемой
одним или несколькими реальными пакетами.

Например, существует виртуальный пакет `mail-transport-agent`. Он обозначает
любую программу, которая может работать как почтовый транспортный агент (MTA).
Реальные пакеты, такие как `postfix`, `exim4`, `sendmail`, `msmtp` и т.д, могут
удовлетворять эту роль.

Это позволяет системам управления пакетами (таким как `apt`) гибко управлять
зависимостями, предоставляя пользователю выбор из множества возможных
реализаций.

Когда пользователь пытается установить виртуальный пакет `mail-transport-agent`,
пакетный менеджер сообщает, что есть несколько реальных пакетов, которые
предоставляют эту функциональность. Однако пакетный менеджер не выбирает
автоматически один из них, так как они являются альтернативами, и пользователь
должен сам выбрать, какой именно реальный пакет установить.

Еще пример, существует виртуальный пакет `mcedit`, при его установке скачается
реальный пакет `mc` и его компоненты, `mcedit` связь с `mc`, грубо говоря alias
на необходимые пакеты. Еще пример, пакет `awk` предоставляет на выбор три
пакета: `original-awk`, `mawk`, `gawk`.


--- Метапакеты
Существуют пустые пакеты, в которых описаны только зависимости и метаданные
(документация и т.д). Они обеспечивают установку группы взаимосвязанных
программ. В описании можно увидеть. `Section: metapackages` (но это
необязательно и не всегда встречается). Например, пакет `build-essential`
является метапакетом. В таких пакетах нет исходников и подобного, а есть только
`debian/` директория с описанием. Такие пакеты существуют лишь ради эффектов,
которые их метаданные оказывают на стек работы с пакетами.

`build-essential` предоставляет необходимые инструменты для сборки пакетов в
Debian, включая компиляторы, библиотеки и другие инструменты, но сам по себе не
содержит какого-либо программного кода. Он лишь указывает на другие пакеты,
которые необходимы для сборки программ в Debian. Вся суть этого пакета в
Depends: и метаданных.

$ mkdir pack-1.0 && cd pack-1.0
$ equivs-control control  # появится control
$ vim control             # изменить под метапакет
$ equivs-build control    # соберет метапакет

еще примеры:
$ equivs-control debian   # появится debian/
$ equivs-build debian     # соберет метапакет


--- Где собирать исходники
Чтобы собрать пакет правильно, его необходимо собирать в минимальной системе,
где стоят только `build-essential` и зависимости этого пакета. Тогда не будет
никаких накладок из-за того, что в системе стоят некоторые пакеты вообще
неизвестно откуда и непонятно каких версий, для этого лучше использовать
`chroot` (debootstrap, pbuilder).


--- fakeroot
Процесс создания пакета является простым сбором в архив набора существующих
файлов. Собирать пакет от имени root не нужно! (это риск). Можно использовать
утилиту `fakeroot` и передать ей программу, которая будет обманута (мол она
запущена от имени root). Это настолько удобно, что `dpkg-buildpackage` имеет
встроенную функциональность `fakeroot`. Процесс будет выполняться от обычного
пользователя, а не root.


--- Создание бинарного пакета (дебианизация)
Есть некая программа в исходных кодах (tarball - архив), необходимо создать для
него набор, пригодный для сборки пакета deb. Этот процесс называется
дебианизацией программы. Для того чтобы дебианизировать программу, нужно в
дереве ее исходников создать каталог `debian/` и положить туда файлы.

$ mkdir -p <package>-<version>/src
$ cd <package>-<version>/src
$ touch hello.c; cd-  # прописать вывод hello
$ dh_make --native    # создаст родной debian/
                      # редактируем debian/ файлы, удаляем ненужные
$ dpkg-source -b .    # создать архивы (исходники) и мета

Если случайно удалили какие-то файлы из `debian/`:
$ dh_make --addmissing

В корне пакета, создать `Makefile`:
src/hello: src/hello.c
	gcc -g3 -O0 -o src/hello src/hello.c

install: src/hello
	install -D src/hello $(DESTDIR)/usr/bin/hello

DESTDIR имеет полный путь к папке:
`/home/builder/binout-1.0/debian/binout`
и нужный бинарный файл, будет положен в `usr/bin/`

Структура:
<package>-<version>/
<package>-<version>/Makefile
<package>-<version>/debian/
<package>-<version>/src/
<package>-<version>/src/hello.c

$ debuild -uc -us

Получаем на выходе:
helloworld_0.0.1_amd64.build    # build log file
helloworld_0.0.1_amd64.changes  # changelog and checksums
helloworld_0.0.1_amd64.deb      # binary package (двоичный пакет)
helloworld_0.0.1.dsc            # source package (debian source control)
helloworld_0.0.1.tar.gz         # original source directory

Описание dh_make:
Создает пакет, который предназначен для использования на одной конкретной
архитектуре и не должен быть переносимым на другие архитектуры: $ dh_make --native

Создает пакет, который является одиночным бинарным пакетом, который будет
установлен на одном компьютере:
$ dh_make --single

Подходит для небольших проектов, где весь функционал и все зависимости
собираются в один пакет. Пример: Если ваш проект компилируется в один
исполняемый файл или библиотеку и все файлы принадлежат одной программе,
`-s` будет подходящим выбором.

Вдобавок создаст `orig.tar.xz` с исходниками:
$ dh_make --createorig --single

Создает пакет, который является библиотекой (shared library), которая может быть
использована другими программами: $ dh_make --library

Создает архитектурно-независимый пакет, который может быть использован на
различных архитектурах и не зависит от конкретной архитектуры:
$ dh_make --indep

Применяется, когда пакет содержит файлы, которые не зависят от архитектуры
системы, такие как скрипты на интерпретируемых языках (например, Python, Perl),
документация, изображения и т.д. Применение: Подходит для пакетов, которые не
требуют компиляции или содержат только универсальные файлы.

`dephelper` представляет собой набор сценариев, эти сценарии вызываются из
`debian/rules`. Все команды, входящие в него, начинаются с префикса `dh_`
`dh_make` создает файлы, а `dephelper` использует эти сформированные файлы.

Можно еще использовать:
$ dh_make --copyright gpl3
Команда `dh_make` создает шаблонный каталог для создания пакета Debian. Опция:
`--copyright gpl3` указывает, что лицензия для пакета будет GNU General Public
License version 3 (GPL-3).

Создаст подкаталог debian с множеством файлов.
Обязательные файлы: `rules`, `control`, `changelog`, `copyright`.
Файлы `.ex` служат примерами, их можно удалить или изменить.

Эти файлы необходимо изменить под наш пакет.
`rules` это `Makefile`, набор правил, используемых для конфигурирования,
сборки и установки:

target: source1 source2 ...
        command1
        command2

Если один из файлов `source*` новее, чем файл `target`, то цель должна быть
создана с помощью command1 command2

Или можно использовать `dh_make` таким образом:
$ wget http://ftp.gnu.org/gnu/gnujump/gnujump-1.0.8.tar.gz
$ mv gnujump-1.0.8.tar.gz gnujump_1.0.8.orig.tar.gz
$ tar xf gnujump_1.0.8.orig.tar.gz
$ cd gnujump-1.0.8/
$ dh_make -f ../gnujump-1.0.8.orig.tar.gz # single binary


--- Пакеты из sid для bookworm (тесты)
Пакеты из ветки Sid (нестабильной версии Debian) не гарантированно будут
работать без проблем на более стабильных версиях, таких как Bookworm.
Sid - это ветка, где постоянно происходят изменения, и пакеты здесь могут
зависеть от более новых версий библиотек или других пакетов, которые могут не
быть доступны в стабильной версии.

Проблемы, которые могут возникнуть при тестировании пакетов из Sid на Bookworm с
использованием `piuparts`, могут включать:

1. Зависимости: Пакет может зависеть от более новых версий других пакетов,
которые отсутствуют в Bookworm.

2. Конфигурации и конфликты: Новые версии пакетов могут иметь изменения в
конфигурации или вызывать конфликты с существующими пакетами.

3. Функциональные изменения: В Sid могут быть изменения, которые не совместимы с
версиями пакетов, находящимися в Bookworm.

Таким образом, если пакет из Sid не проходит `piuparts` тесты на Bookworm, это
не обязательно означает, что с пакетом что-то не так. Это может просто отражать
различия между версиями дистрибутивов. Если нужно, чтобы пакет работал на
Bookworm, возможно, придется адаптировать его или собрать специально для этой
версии, учитывая её зависимости и особенности.


--- Backporting packages
Перенос пакетов на более старую систему.
Процесс установки более новой версии программного обеспечения на старую
операционную систему. Например, взять пакет из `unstable` и протестировать его
на `stable` ветке + доработать. Это может быть полезно для тестирования новых
функций, получения исправлений или улучшений, а также для обеспечения
совместимости с другими пакетами.

1. Новые возможности и улучшения: Новые версии программного обеспечения часто
содержат улучшения и новые функции, которые могут быть полезны пользователю.

2. Исправление ошибок: Более новые версии могут содержать исправления ошибок и
уязвимостей, которые отсутствуют в старых версиях.

3. Совместимость: Иногда новое программное обеспечение требует более новых
версий других пакетов, которые могут быть недоступны на старой системе.

Например, появилась необходимость протестировать новый `mc` на стабильном релизе
`stable`, можно скачать `mc` из `sid` собрать его в `stable` и протестировать на
нем же. Новые пакеты ставятся так:
$ sudo dpkg -i *.deb


--- Основные пакеты для сопровождающего
* dpkg-dev
Содержит инструменты, необходимые для создания deb-пакетов, такие как
`dpkg-source`, `dpkg-gencontrol`, `dpkg-buildpackage` и другие.

* build-essential
Мета-пакет включает набор инструментов необходимых для компиляции ПО, таких как
компилятор `gcc`, `make`, а также другие зависимости, необходимые для сборки
большинства программ из исходных кодов.

* devscripts
Содержит набор скриптов, которые облегчают выполнение различных задач, связанных
с разработкой deb-пакетов, таких как `debuild`, `dch`, `debuild`, `debi` и
другие.

* debhelper
Набор скриптов, упрощающих создание deb-пакетов. Включает такие инструменты, как
`dh_installdirs`, `dh_install`, `dh_clean` и многие другие.

Он значительно упрощает процесс создания пакетов за счет автоматизации многих
рутинных задач.

Предоставляет множество скриптов и команд, которые автоматизируют повторяющиеся
задачи, такие как установка файлов, настройки конфигурации, компиляция кода,
создание документации и т.д.

Помогает поддерживать единообразие в процессе сборки пакетов. Это делает пакеты
более предсказуемыми и совместимыми с общими стандартами Debian.

`debian/rules` использует `debhelper`.

`dh_installdeb`, `dh_make`, `dh_auto_configure` и подобные, это отдельные
команды или скрипты, входящие в состав набора инструментов `debhelper`.
`debhelper` включает в себя множество таких команд, каждая из которых отвечает
за выполнение конкретной задачи в процессе создания и управления пакетами
Debian.

* lintian
Инструмент для проверки deb-пакетов на наличие ошибок и несоответствий
стандартам Debian.

* quilt
Инструмент для управления сериями патчей. Полезен для применения и управления
патчами в исходных кодах пакетов.

* dh-make
Утилита, упрощающая создание структуры исходного пакета Debian из tarball'а с
исходным кодом.

* fakeroot
Утилита, позволяющая пользователю создавать файлы и каталоги с правами
суперпользователя, не имея их на самом деле. Полезна для создания пакетов от
имени обычного пользователя.

* equivs
Инструмент для создания "пустых" пакетов, которые могут выступать в качестве
зависимостей для установки других пакетов. Хорошо подходит для создания
мета-пакетов.

* debconf
P.S: Смотреть: `doc-b.txt` -> debconf

... и другие.


--- dpkg -i *.deb и зависимости
Когда делаем команду:
$ dpkg -i *.deb
Depends/Recommends и подобные, не устанавливаются автоматически, а устанавливает
только сами пакеты. Чтобы устанавить локальный пакет вместе с зависимостями:
$ apt install <pkg>


--- Lintian ошибки
- national-encoding
используется кодировка, отличная от стандартной UTF-8, надо использовать `iconv`.

- groff-message
все сообщения и документация, которые могут использовать `groff`, соответствуют
стандартам форматирования?

- redundant-installation-prerequisite
избыточные зависимости, записи, смотреть `debian/control`.

- newer-standards-version
версия стандарта, указанная в `debian/control`, новее той, которую текущая
версия Lintian умеет проверять.

- patch-file-present-but-not-mentioned-in-series
<file>.patch существует, но в `patches/series` не прописан, лучше прописать,
даже если не нужен (указать комментарий перед началом ненужного патча).

- unusual-interpreter /usr/bin/python [usr/lib/mc/extfs.d/s3+]
в пакете используется интерпретатор `/usr/bin/python`, который отсутствует в
системе.

- uses-dpkg-database-directly [usr/lib/mc/extfs.d/apt+]
скрипт напрямую обращается к внутренней базе данных `dpkg` (это может привести к
нестабильной работе системы), вместо этого лучше использовать официальные
источники `dpkg-query`, `apt-cache`, `apt-get`, и другие.

- debian-watch-uses-insecure-uri [debian/watch]
в `debian/watch` файле используется небезопасный URI адрес, пакеты хранятся на
небезопасном сервере, желательно изменить на HTTPS.

- older-debian-watch-file-standard 3 [debian/watch]
в `debian/watch` можно поднять версию с 3 до 4 (например), это даст более лучшу
функциональность.

- patch-not-forwarded-upstream [debian/patches/file.patch]
в патче поле Forwarded заполнено не `not-needed`, желательно указать `no` или
`not-needed`.

`no` -> пересылка в upstream пока что не сделана
`not-needed` -> не требуется, патч только для Debian
`yes` -> сделано

- Если присутствует поле "Bug" (указывающее на ошибку), то подразумевается, что
  патч был отправлен разработчикам исходного проекта, даже если поле "Forwarded"
  не указано.
- Если поле "Bug" отсутствует, то подразумевается, что патч не был отправлен
  разработчикам исходного проекта.

- debian-news-entry-has-unknown-version [usr/share/doc/mc/NEWS.Debian.gz]
https://bugs-devel.debian.org/cgi-bin/bugreport.cgi?bug=1021607
или действительно не совпадает с `debian/changelog`.

- hardening-no-bindnow usr/sbin/icmpinfo
в `debian/rules` необходимо добавить `export DEB_BUILD_MAINT_OPTIONS = hardening=+all`.

- hardening-no-relro usr/sbin/icmpinfo
потеряли в `debian/rules` (-Wl,-z,relro)

В целом hardening-* сообщения связаны с безопасностью флагов и можно
экспортировать `dpkg-buildflags` и проанализировать вывод `blhc`.


--- Где брать готовые бинарные пакеты
Можно использовать:
$ apt-get download <pack>

$ apt-get download <pack>/sid
$ apt-get download <pack>/bookworm

Или собрать самому из исходников.

Или использовать ссылки:
https://ftp.debian.org/debian/
https://snapshot.debian.org/


--- piuparts
Утилита `piuparts` предназначена для тестирования установки, удаления и
обновления пакетов в дистрибутиве Debian. Она проверяет, что пакеты могут быть
установлены, удалены и обновлены без возникновения ошибок, а также что они
корректно взаимодействуют с другими пакетами. Основная цель piuparts -
убедиться, что пакеты не оставляют "мусора" в системе после удаления и что
установка/удаление пакетов не приводит к нарушению зависимости или других
проблем.

Простой тест установки и удаления пакета:
$ piuparts -d sid <package>

Позволяет протестировать сценарий обновления пакета с более старого релиза на
более новый:
$ piuparts -d bookworm -d sid <package>

Тестирование установки с зависимостями (проверяет установку и удаление вместе с
зависимостями):
$ piuparts -d sid --install-recommends <package>

Проверка чистоты системы после удаления пакета.
Для проверки, что после удаления пакета не остаётся мусора в системе:
$ piuparts --install-purge-install -d sid <package>

Отображает предупреждения для пакетов, которые не являются частью тестируемого
пакета:
$ piuparts --warn-on-others -d sid <package>

FAIL тесты будут смягчены:
$ piuparts --warn-on-leftovers-after-purge -d sid <package>

Тестирование обновления пакета с одной версии на другую:
$ piuparts -d sid <old-package> <new-package>
$ piuparts -d sid a/*.deb b/*.deb

Можно с помощью `pbuilder` развернуть chroot, а затем использовать `piuparts`.
Если нужно протестировать пакет в конкретном chroot окружении:
$ piuparts --schroot sid-amd64-sbuild <package>

Тестирование пакета в конкретном .tgz:
$ piuparts --basetgz=/path/to/my/tarball.tgz <package>


--- debian/rules with verbose
$ export DH_VERBOSE=1
$ debian/rules clean
$ unset DH_VERBOSE


--- dpkg-buildflags
Используется для извлечения информации о флагах компиляции и сборки, которые
должны использоваться при построении пакетов. Она помогает обеспечить
единообразие и соответствие стандартам безопасности и оптимизации во всех
пакетах, собираемых для Debian и производных систем, таких как Ubuntu.

`dpkg-buildflags` позволяет получить список флагов, которые используются по
умолчанию для компиляции и линковки. Это включает в себя такие флаги, как
`CFLAGS`, `LDFLAGS`, `CPPFLAGS` и другие.

Можно изменять или добавлять собственные флаги, чтобы адаптировать процесс
сборки под конкретные нужды.

Использование стандартных флагов помогает улучшить безопасность и
производительность, так как они включают в себя современные подходы к защите и
оптимизации кода.

$ dpkg-buildflags --get CFLAGS
$ dpkg-buildflags --export

Пользователь может переопределять или дополнять флаги с помощью переменных
окружения, таких как `DEB_CFLAGS_APPEND`. Например, чтобы добавить флаг к
`CFLAGS`: export DEB_CFLAGS_APPEND="-O3"

Обычно `dpkg-buildflags` вызывается из сценариев (`debian/rules`) при сборке
пакета. Это обеспечивает автоматическое использование правильных флагов.

Например:

CFLAGS := $(shell dpkg-buildflags --get CFLAGS)
LDFLAGS := $(shell dpkg-buildflags --get LDFLAGS)

build:
    gcc $(CFLAGS) -o myapp myapp.c $(LDFLAGS)

или
include /usr/share/dpkg/buildflags.mk

Иногда делают так (что вставляет все значения по-умолчанию):
include /usr/share/dpkg/default.mk

Содержит набор стандартных правил и переменных, которые облегчают написание
файла `debian/rules`. Подключение этого файла позволяет разработчику
использовать предопределенные настройки и команды, что упрощает процесс сборки
пакета и обеспечивает консистентность с другими пакетами в системе Debian. Это
также помогает сократить количество дублируемого кода и улучшает читаемость и
поддержку файла `rules`.

В чем разница между CFLAGS = ... CFLAGS := ... CFLAGS += ... ?

(ленивое присваивание)
= Если другие переменные, используемые в присваивании, изменяются позже, это
повлияет на значение.

(жадное присваивание)
:= Оно остаётся неизменным, даже если другие переменные, используемые в
присваивании, изменяются позже.

(добавление к переменной)
+= Добавляет новое значение к уже существующему значению переменной, полезно для
накапливания значений в списке.

`-g` включает отладочную информацию

`-O2` оптимизация для скорости

`-fstack-protector-strong` защита стека от атак переполнения буфера.
Когда буфер (например, массив) в функции переполняется, это может позволить
злоумышленнику изменить содержимое стека, включая возвратные адреса, что может
привести к выполнению произвольного кода. Есть еще `-fstack-protector`, но это
базовая защита, не strong.

`-Wformat` в компиляторе GCC и подобных используется для включения предупреждений,
связанных с форматированием строк, особенно в функции `printf` и аналогичных.
Эти предупреждения помогают обнаружить потенциальные ошибки в использовании
спецификаторов формата. Например, неправильное использование спецификаторов,
или неверное кол-во и т.д. GCC предупредит об этом.

`-Werror=format-security` преобразует предупреждения о безопасности форматов в ошибки.

`-Wdate-time` используется для предупреждения о использовании устаревших макросов
даты и времени, таких как `__DATE__`, `__TIME__` и `__TIMESTAMP__`. Эти макросы
усложняют отладку и тестирование и т.д, короче, нежелательны в некоторых
ситуациях.

`-D_FORTIFY_SOURCE=2` используется, чтобы повысить безопасность приложений,
предотвращая потенциальные уязвимости, которые могут быть использованы для
выполнения произвольного кода через переполнение буфера или другие подобные
атаки. Он совместим с оптимизациями уровня `-O2` и выше. Это делается путем
добавления дополнительных проверок к функциям, таким как `sprintf`, `strcpy`,
`memcpy` и другим.

`_FORTIFY_SOURCE=1` менее строгий
`_FORTIFY_SOURCE=2` более строгий

`-Wl,-z,relro` эта опция линкера активирует механизм "Read-Only Relocation"
(RELRO). RELRO защищает таблицы перемещений и другие секции памяти от изменений
во время выполнения. Это делает более сложным эксплуатацию некоторых типов
уязвимостей, таких как переполнение буфера. Существует несколько уровней защиты
RELRO, и данная опция активирует базовый уровень защиты.

Есть еще PIE и BINDNOW - если кратко, повышают безопасность =)


--- hardening=+all
export DEB_BUILD_MAINT_OPTIONS = hardening=+all
Please enable "PIE" and "BINDNOW" in the build.
The "all" option enables "PIE" and "BINDNOW".

Each hardening feature can be enabled and disabled in the
DEB_BUILD_MAINT_OPTIONS environment variable's hardening value with
the "+" and "-" modifier. For example, to enable the "pie" feature and
disable the "fortify" feature you can do this in `debian/rules`:
export DEB_BUILD_MAINT_OPTIONS=hardening=+pie,-fortify


--- hardening-check
Это утилита, используемая для проверки бинарных файлов на наличие определённых
механизмов защиты (hardening). Она анализирует исполняемые файлы на предмет
различных техник, которые могут повысить их безопасность и устойчивость к
атакам.

Используя `hardening-check`, разработчики могут удостовериться, что их
программное обеспечение компилируется с включёнными механизмами защиты,
что повышает его устойчивость к различным видам атак.

Алгоритм: поставили пакет, а затем:
$ hardening-check /usr/bin/binary


--- fzf, fzy, ripgrep
fzf (Fuzzy Finder) - это интерактивный инструмент командной строки для нечеткого
поиска и фильтрации. Пример использования:

$ find . -type f | fzf

fzy - аналогичный инструмент, ориентированный на скорость и простоту,
неинтерактивный, но также эффективен для фильтрации. Пример:

$ find . -type f | fzy

ripgrep (rg) - мощный и быстрый инструмент для поиска текста в файлах.
Поддерживает рекурсивный поиск и регулярные выражения, игнорирует файлы,
указанные в .gitignore. Идеален для поиска текста в проектах:

$ rg 'search_term'

Все три утилиты отлично дополняют рабочие процессы разработчиков, ускоряя поиск
и навигацию по проектам. Часто используются в совокупности с vim, или другими
текстовыми редакторами/IDE.


--- udeb и dbgsym пакеты
Udeb пакеты (micro debs) - это урезанные версии deb-пакетов, используемые в
Debian Installer. Они содержат минимальный набор файлов, необходимых для
установки системы, и оптимизированы для уменьшения размера, что критично при
установке на ограниченные ресурсы.

Dbgsym пакеты - это специальные пакеты, содержащие отладочные символы для других
пакетов. Они используются для упрощения процесса отладки программ, позволяя
разработчикам и системным администраторам получить более подробную информацию об
ошибках и сбоях, сохраняя основную систему без отладочной информации для
экономии места.
