valgrind - выполняет сбор и анализ информации.

Состоит из модулей, которые выполняют определенную работу, например по-умолчанию
запускается модуль memcheck (обнаружение утечек памяти и т.д), чтобы запустить
другой модуль: $ valgrind --tool=callgrind ./a.out

Часто используемые опции можно задать один раз используя глобальный файл
конфигурации `~/.valgrindrc`, не придется их набирать при каждом запуске
valgrind.

Число равняется pid запущенному процессу в выводе ==12345==
Знаки ??? говорят об отсутствии отладочной информации.


*
запуск
$ valgrind ./a.out

*
обнаружение утечек памяти (full показывает подробно)
$ valgrind --leak-check=full ./a.out

*
показывает подробности ошибок LEAK SUMMARY, например покажет
где точно есть still reachable и другие ошибки запроса памяти
$ valgrind --leak-check=full --show-leak-kinds=all ./a.out

*
выдаст заключительный результат
$ valgrind --leak-check=full --show-leak-kinds=all -s ./a.out

*
если есть обращение к неинициализированной переменной
например int i; покажет где находится
--track-origins=yes


Пример:
valgrind Invalid read of size 1
Address <num> is 0 bytes after a block of size 8 alloc'
Говорит, что аллоцировано недостаточно памяти, например strcpy, memcpy
кладут в конец '\0' на который тоже нужно запросить память.

Исправление выглидит так:
size_t wtext_len = lent * sizeof(wchar_t) + sizeof(int);
До ошибки было просто lent * sizeof(wchar_t) + 1; Это неверно!


Разбор отчета:
LEAK SUMMARY:
  definitely lost: 2,260 bytes in 47 blocks.
  indirectly lost: 1,680 bytes in 66 blocks.
  possibly lost: 2,703,124 bytes in 13,791 blocks.
  still reachable: 82,359,875 bytes in 299,100 blocks.
  suppressed: 0 bytes in 0 blocks.

* definitely lost область памяти, на которую нет указателей (забыли освободить)

* possibly lost указатель, указывающий на часть области памяти, но valgrind не
  уверен в том, что указатель на начало области памяти до сих пор существует
  (это может происходить в тех случаях, когда программист вручную управляет
  указателями)

* still reachable указатель на начало не освобожденного блока памяти локальные,
  глобальные переменные (это не ошибка, с этим ничего делать не нужно)
