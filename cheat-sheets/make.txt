Темы:
* Make
* Autotools
* Makefile vars + gcc
* gcc (GNU Compiler Collection)
* Оптимизация кода
* Компилятор
* Этапы компиляции
* Заголовочные файлы и библиотечный файлы
* Библиотеки
* Компановка
* Инструменты библиотек
* LD_PRELOAD, ld.so, strace
* ELF


--- Make - сборщик
Сценарий помещается в Makefile и в нем прописываются связки. После повторной компиляции make видит
измененные файлы и перекомпилирует только их. Это общее решение для сборки исходников. Да мы могли
бы использовать Bash скрипт, но с ростом сложностью проекта, скрипт стало бы сложнее поддерживать и
в таких случая лучше использовать make.


--- Autotools
Система сборки, известная под названием GNU Build system
Включает в себя autoconf, automake, autoscan.
Заклинание: $ ./configure && make && sudo make install

Autotools нужен для того чтобы разные дистрибутивы (которые отличаются друг от друга) могли собрать
один и тот же проект при помощи определенной последовательности команд. Эта система используется
обычно в Unix системах.

*
Используется при обновлении скриптов сборки и конфигурации. Например, если сделали редактирование
файлов configure.ac или Makefile.am, то затем нужно выполнить эту команду, подтягивает новые
изменения.
$ autoreconf -iv

Makefile.am файлы пишет разработчик (какие файлы подключить, какие тесты запустить, какие файлы
собрать и т.д), а Makefile.in генерируются. autoreconf создает Makefile.in файлы, которые потом
использует ./configure это поможет configure создать Makefile файлы (это нужно для запуска make).

*
Выполняет поиск необходимых для компиляции библиотек, заголовочных файлов, инструментов и
зависимостей, устанавливает переменные окружения, которые будут использоваться в Makefile*.
В случае если сценарий обнаружит всё что ему нужно, он создаст Makefile*.
$ ./configure

*
Выполняет компиляцию программы, сборку и установку.
$ make

В некоторых проектах можно отдельно делать сборку:
$ mkdir build && cd build
$ ../configure --prefix=/usr
$ make

Опция `--prefix` используется в скрипте `configure` для указания пути установки программного
обеспечения (make install). Если не указать `--prefix`, то по умолчанию программа будет установлена
в системные каталоги, такие как `/usr/local`. С помощью `--prefix` можно установить программу в
другое место.

Утилите make можно передавать переменные окружения, например:
$ make CFLAGS="-Wno-error=use-after-free"

Еще бывают такие ситуации, что в проекте нет ./configure,
а есть autogen.sh / Makefile.am / configure.ac и т.д.

Сценарий autogen.sh используется для создания файлов configure и Makefile.in из файлов configure.ac
и Makefile.am соответственно. Он также может выполнять другие необходимые действия для подготовки
проекта к сборке, такие как установка файлов aclocal.m4 и др.

Заклинание может быть таким:
./autogen.sh
./configure
make
make install


--- Makefile vars + gcc
- CC
Относится к компилятору (gcc, cc и т.д)

- CFLAGS
Этап компиляции.
(Compiler Flags) - это флаги, передаваемые компилятору (например, gcc) для управления процессом
компиляции исходного кода. Они могут включать опции для оптимизации кода, установки уровня
предупреждений, определения макросов и т.д.
Например: -Wall, -g3, -O0, -I/usr/local/include

- LDFLAGS
Этап линковки.
(Linker Flags) - это флаги, передаваемые компоновщику (линкеру) для управления процессом компоновки
объектных файлов в исполняемый файл или библиотеку. Они могут включать опции для указания путей к
библиотекам, которые нужно подключить, установки версии библиотеки, определения символов и т.д.
Например: -lm

- LIBS
Включает в себя статические или динамические либы (-lm, archive.a)

- CPPFLAGS
Дополнительные флаги для препроцессора.

Переменные вида CXX относятся к C++, например CXXFLAGS

Опции предупржедений gcc:
-Werror -Wall

Языковой стандарт:
-std=c99 -ansi


--- gcc (GNU Compiler Collection)
$ gcc -c file.c         # получение объектного файла (-с (compile) означает только компиляция - без компановки)
$ gcc -o exe a.o b.o    # процесс сборки, получение бинарного файла (-o задает имя исполняемого файла)
$ gcc main.c -o program # компиляция одиночного файла
$ gcc -g                # поместить отладочную информацию в объектный / исполняемый файл
$ strip -s a.out        # удалить отладочную информацию из ELF
$ -O0                   # различные уровни оптимизации 0-3, 0 - НЕ оптимизировать код

-O3 означает оптимизировать код (улучшает его производительность, уменьшает размер кода и т.д)
Даже если программа собрана с -O3, volatile все равно говорит компилятору - НЕ оптимизировать код

-Wall                   # вывод сообщений о всех предупреждениях или ошибках, возникающих во время компиляции
-Wextra                 # дополнительные предупреждения

-L<путь> -l<библ>       # эти флаги служат для поиска библиотек, передается компоновщику (линковка)
-I<путь>                # для поиска заголовочных файлов -I/usr/local/include

gcc -o exe sums.c -lm   # в этой команде линкуется (связывается) библиотека maths

Бывают случаи когда библиотеки нет в стандартной библиотеке и компиляцию нужно осуществлять с
дополнительным флагом, например так:
$ gcc main.c -lpthread


--- Оптимизация кода
Это модификация программ, выполняемая компилятором с целью улучшения их характеристик, таких как
производителость, компактность, - без изменения функциональности. Перемещение кода, устранение
избыточного кода, замены, подмены и т.д.

До оптимизации:
int a = x;
int b = y;
int c = 32*32;
return a * a + b * b;

После:
//
//
int c = 1024;
return x * x + y * y;

До оптимизации:
int main() {
    int sum = 0;
    for (int i = 0; i < 100; i++) {
        sum += i;
    }
    printf("Sum: %d\n", sum);
    return 0;
}

После:
int main() {
    int n = 100; // количество элементов
    int sum = (n * (n - 1)) / 2; // прямое вычисление суммы
    printf("Sum: %d\n", sum);
    return 0;
}

Хотя это редкое явление, иногда оптимизации, проводимые компилятором, могут привести к
непредвиденным результатам или изменить логику программы.


--- Компилятор
Компилятор распознает язык по расширению файла.
* Исходник   - Исходный файл содержит код на языке Си, файл оканчиваются на .c
* Компиляция - Исходный код пропускается через компилятор, проверка на ошибки
* Результат  - Бинарный модуль

Компилятор создает новый файл (исполняемый/бинарник), содержит машинный
код, поток единиц и нулей, понятные ПК, это и есть программа.

Кодирование   -> бинарный код (текст воспроизводится в бинарный код (0/1))
Декодирование -> бинарный код воспроизводится в текст

Трансляторы:
* Компилятор -> СКОРОСТЬ
* Интерпретатор -> ГИБКОСТЬ


--- Этапы компиляции
* Препроцессинг (обработка - cpp)
$ gcc -E main.c -o main.i
Текст обрабатывается - производится:
- замена комментариев пустыми строками
- обрабатывает директивы #define / #ifdef
- включает #include (копирует содержимое файлов как текст)

* Трансляция кода в ассемблер
$ gcc -S main.i -o main.s
- транслирует исходный текст программы в ассемблерный код

* Компиляция (объектный файл - as)
$ as main.s -o main.o
- транслирует ассемблерный код в машинный код (бинарный модуль)
- обработка и анализ кода
- выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла
- генерация кода из преобразованного, получается объектный файл

Объектный файл - это программа машинных кодов с частичным сохранением символьной информации,
необходимой в процессе сборки.

При отладочной сборке возможно сохранение большого кол-ва символьной информации (переменные,
функции, типы).

* Компановка - линковка (связывание воедино всех объектных файлов - ld)
$ gcc main.o -o program
- определяет связь объектных файлов, нужно чтобы файл А увидел переменную
в файле Б, этой задачей занимается компановщик. Когда программа делает ссылку
на функцию, содержащуюся в библиотеке, компоновщик отыскивает эту функцию
(например printf()) и добавляет ее код к программе. Таким образом, к программе
добавляются только те функции, которые действительно будут в ней использоваться.

При этом возможны ошибки связывания, если объявили функцию не в том месте, то получим ошибку на этом
этапе.

* Загрузка
Вызвать загрузчик для загрузки нашей программы в память.

Кратко:
исходный текст -> препроцессинг -> ассемблер -> машинный код -> компановка -> загрузка.

Можно не вызывать данные компоненты напрямую, в компилятор они уже включены:
cpp - препроцессор
as  - ассемблер
gcc - компилятор
ld  - линковка


-- Дополнительно
Если имя файла заключено в угловые скобки <stdio.h>, то поиск заголовочного файла производится в
специальном каталоге /usr/include. А запись "file.c" будет искаться в первую очередь в текущем
каталоге. Так же можно указывать текущий путь заголовочного файла #include "/home/<user>/const.h"

Препроцессор определяет 5 констант
__DATE__ - дата компиляции
__FILE__ - имя компилируемого файла
__LINE__ - номер текущей строки исходного кода
__TIME__ - время компиляции


--- Заголовочные файлы и библиотечный файлы
Заголовочный файл - это подключаемый файл, содержимое которого автоматически добавляется
препроцессором в исходный текст в том месте, где располагается директива #inlude <stdio.h>
Многие библиотечные функции работают со своими особыми типами данных и со структурами, к которым
программа должна иметь доступ. Эти структуры и типы определяются в заголовочных файлах,
поставляемых с компилятором, и они (заголовочные файлы) должны включаться (с помощью #include)
в каждый файл, использующий функции, на которые они ссылаются.

Библиотечный файл - исполняемый код, подсоединяются к программе на стадии линковки.
К любой программе, использующей функции языка С (например, printf() или malloc()),
подключается библиотека времени выполнения. Если у программы есть GUI, то компануется
вместе с гуишными библиотеками.

Компоновать библиотеку можно двумя способами:
1. Статические (архивы .a) - коллекция объектных файлов, которая хранится в одном
файле -> архиве, объединить объектные файлы в архив можно так:
ar cr archive.a one.o two.o (флаги cr говорят о создании архива -> man ar)
После чего у нас лежит готовый архив archive.a и после чего можно подключить данную
библиотеку к нашему основному файлу так: $ gcc -o exe main.o -L. -larchive
В итоге получим бинарный файл.

2. Динамически (shared object .so) хранятся в директориях /lib /usr/lib
В отличие от статических библиотек, код совместно используемых (динамических) библиотек не
включается в бинарник вместо этого в бинарник включается только ссылка на библиотеку. Статические
более переносимые и при компиляции можно подключить с флагом -lmain Динамическая создается с помощью
gcc -shared Команда ldd выводит список совместно используемых библиотек, подключенных к заданному
исполняемому файлу.

Для чего это нужно? Библиотеки часто связаны одна с другой, например библиотека
libtiff использует библиотеку libjpeg и libz
Например: $ gcc -о tifftest tifftest.c -ltiff
здесь библиотека libtiff ссылается на вышеперечисленные.


--- Библиотеки
Библиотека - это набор скомпанованных особым образом объектных файлов. Библиотеки подключатся к
основной программе во время линковки, по способу компановки библиотеки разделяются на архивы
(статические и динамические). В отличие от статических библиотек, код динамических библиотек не
включается в бинарник, вместо этого в бинарник включается только ссылка на библиотеку.

Статические библиотеки делают программу более автономной: программа, скомпонованная со статической
библиотекой может запускаться на любом компьютере, не требуя наличия этой библиотеки (она уже
"внутри" бинарника). Программа, скомпонованная с динамической библиотекой, требует наличия этой
библиотеки на том компьютере, где она запускается, поскольку в бинарнике не код, а ссылка на код
библиотеки.

Бинарник, скомпонованный с совместно динамической библиотекой меньше размером, чем такой же
бинарник, с подключенной к нему статической библиотекой. Любая модернизация динамической
библиотеки, отражается на всех программах, использующих ее. Таким образом, если некоторую
библиотеку foo используют 10 программ, то исправление какой-нибудь ошибки в foo или любое другое
улучшение библиотеки автоматически улучшает все программы, которые используют эту библиотеку.
Именно поэтому динамические библиотеки называют совместно используемыми. Чтобы применить изменения,
внесенные в статическую библиотеку, нужно пересобрать все 10 программ.

Статические библиотеки имеют формат .a (archive)
Динамические .so (shared object)
Хранятся они обычно в /lib и /usr/lib


--- Компановка
Если нам нужно собрать программу из нескольких бинарных файлов, для этого понадобится
компоновщик/линковщик - программа, которая объединяет модули и создает бинарный файл. Этот процесс
называется компоновкой/линковкой В Linux в роли линковщика используется ld и gcc.

Например, мы создали два файла, файл A вызывает функцию файла B, для этого требуется
определить функцию в файле A до начала main функции. Затем собрать файлы с помощью
команды gcc -c main.c и получить на выходе main.o (объектный файл) и затем собрать
объектные файлы с помощью $ gcc -o program main.o hello.o и получить на выходе
исполняемый файл при выполнении которого получается программа.

Посмотреть информацию об объектных файлах можно с помощью $ nm main.o
Собирать каждый файл с помощью gcc муторный способ, если бы у нас было много файлов, пришлось бы
собирать каждый файл долго. Для выхода из такой ситуации лучше использовать make.


--- Инструменты библиотек
Большинство библиотек теперь используют утилиту pkg-config не только для указания местоположения
своих файлов и библиотек, но и для задания точных флагов, необходимых для компиляции и компоновки
программы.

$ pkg-config --list-all

Все чаще библиотеки поставляются с файлами .pc которые лежат в /usr/lib/pkgconfig такие библиотеки
позволяют запросить флаги компилятора и компоновщиков, необходимые для использования нужной
библиотеки.

Когда библиотека установлена с помощью пакетного менеджера, или другим способом, то в
/usr/lib/pkgconfig обычно появляется файл .pc этой библиотеки. В нем обычно указывается список
зависисимых библиотек, которые так же должны компилироваться, расположение заголовков, описание,
версия, и предоставляет дополнительные флаги компоновщика, необходимые для компиляции нашей
программы (в которой используется эта библиотека)

$ pkg-config libcap --modversion            # версия либы
$ pkg-config ncurses --libs                 # показывает все флаги компоновщика данной библиотеки
$ pkg-config ncurses --cflags               # показывает все флаги препроцессора и компилятора
$ dpkg -L libc6                             # показывает содержимое пакета (либы)
$ nm -D /path/to/lib.so | grep <func>       # посмотреть имя функции в либе
$ nm -o -D lib.so                           # подробнее
$ size ./a.out                              # выводит размеры различных сегментов

Допустим при компиляции исходника возникает ошибка '<bla/pam_ext.h> No such file or directory'
Можно попробовать найти данный header в системе, а если его нет.
$ apt-file search -x pam_ext.h # покажет пакет в котором есть данный header

Посмотреть содержимое пакета, не устанавливая его.
$ apt-file list xterm

Если в man написанно 'Link with -lrt' значит будет использоваться librt.so библиотека.

Выводит shared-библиотеки используемые исполняемым файлом.
$ ldd ./a.out    # print shared object dependencies
$ ldd -v ./a.out # подробный вывод
$ ldconfig -p    # показывает cache список (имеющиеся либы)


--- LD_PRELOAD, ld.so, strace
Создать бинарный файл a.out с функцией rand() - генерация чисел, пусть их будет 5
Создать библиотеку hack.so с содержимым функции: int rand() { return 42; }
$ gcc -shared -fPIC hack.c -o hack.so
$ export LD_PRELOAD=$PWD/hack.so
Указать загружаемую библиотеку.

$ ./a.out
Выполнится код библиотеки hack.so, подменили функцию rand() библиотеки libc.so на собственную.

$ ldd ./a.out
Можно увидеть, что библиотека hack.so выполняет раньше libc.so, тем самым, выполняется плохой rand()

Такую переменную необязательно экспортировать, можно прописать в /etc/ld.so.preload путь библиотеки
/home/<user>/main/zone/hack.so в этом файле обычно хранится список ELF библиотек, которые будут
загружены перед программой.

Если посмотреть strace, можно увидеть, что ld.so.preload читается постоянно, но он не всегда есть,
поэтому возврат будет ENOENT, а если доступ будет, он прочитает и загрузит библиотеку hack.so и
выполнит его исходный код перед библиотекой libc.so.

Динамические библиотеки, еще могут грузиться из файла /etc/ld.so.cache (скомпилированный список
библиотек-кандидатов, которые ранее были найдены по указанным путям). После прочтения этого файла,
загружается библиотека libc.so. /etc/ld.so.cache система кэширует информацию о доступных разделяемых
библиотеках и хранит ее в этом файле. Существует и файл конфигурации /etc/ld.so.conf, в котором
содержится список путей к директориям, в которых размещены разделяемые библиотеки.

LD_LIBRARY_PATH
Каталоги, в которых будет поиск ELF библиотек, похоже на PATH.

LD_PRELOAD
Заданный пользователем список дополнительных динамических ELF библиотек, они будут загружены перед
всеми другими. Это можно исопльзовать для выборочного перекрытия функций в других динамических
библиотеках.

При выводе ldd можно заметить первой строкой linux-vdso.so.1 (virtual dynamic shared object),
виртуальные динамический общий объект. Этого файла нет на диске, он виртуальный, это часть ядра,
которая экспортируется в адресное пространство каждой программой при ее загрузке. Эта библиотека
отображается ядром Linux в адресное пространство всех пользовательских процессов и используется
библиотекой языка C libc для повышения производительности при работе с некоторыми системными
вызовами. На нее не стоит обращать особого внимания. А последней строкой
/lib64/ld-linux-x86-64.so.2 это библиотека динамического линковщика.

$ ldd /lib/x86_64-linux-gnu/libc.so.6
Можно посмотреть какие библиотеки использует libc -> (vdso, ld)


--- ELF
Executable and Linkable Format.
Файл ELF, является выходным файлом компилятора или линкера и имеет двоичный формат. Вместо того,
чтобы напрямую использовать язык CPU, мы используем ЯП, имеющий стандартные функции. Компилятор
транслирует эти функции в объектный код. Этот объектный код затем линкуется в полную программу
(с помощью линкера). Результатом является двоичный файл, который может быть выполнен на конкретной
платформе и конкретном типе CPU. Объектные файлы, библиотеки, дампы ядра, a.out файлы, всё это ELF
файлы. $ file a.out # ELF
