Темы:
* Загрузка системы
* GRUB
* Смена GRUB DEFAULT
* Уровни выполнения
* За что отвечает ядро (задачи)
* Уровни ОС
* Состав ядра Linux
* Внутреннее устройство Linux
* Память компьютера
* Уровни выполнения (устарело, не используется)
* Recovery mode
* Capabilities - полномочия (мандаты)
* Как ядро работает с процессами, пользователями
* Идентификаторы пользователей
* uefi vs legacy bios (режимы загрузки)
* Что такое pam
* Что такое архитектура процессора
* x86 vs ARM
* Что такое регистр
* Форматирование диска
* Какое ядро бывает
* Аудит
* ACPI
* SCSI
* Secure boot


--- Загрузка системы

Досистемная загрузка:
* запуск ПК -> ПЗУ (BIOS) -> MBR -> GRUB -> kernel + initrd (rootfs) -> chroot to real FS root -> ...

Системная загрузка:
* /sbin/init (systemd) (pid 1) run all services -> pam (аутентификация пользователя)

Досистемная загрузка:

1. BIOS (Basic Input/Output System): При включении компьютера, BIOS производит инициализацию
аппаратных компонентов, проверяет работоспособность системы и ищет загрузочное устройство.
BIOS запускается в RAM ПК из ПЗУ.

2. Загрузочное устройство: После инициализации BIOS и поиска загрузочного устройства,
BIOS передает управление загрузчику (в загрузочном устройстве присутствует MBR).
MBR содержит небольшой исполняемый код, который использует BIOS для загрузки операционной системы,
а также таблицу разделов, которая описывает, как диск разделён на отдельные разделы.
GRUB установлен в MBR. Либо GRUB может быть установлен в EFI (/boot/efi) (для UEFI BIOS),
тогда в этом случае EFI запускает GRUB на прямую, без использования MBR.

Старое: Legacy BIOS -> MBR -> GRUB
Современное: UEFI BIOS -> EFI (/boot/efi) -> GRUB

3. Загрузчик (Bootloader): Загрузчик, такой как GRUB (Grand Unified Bootloader),
загружает ядро Linux (`vmlinuz-*-amd64` в память). Он также предоставляет пользователю выбор
различных операционных систем, если они установлены на компьютере.

4. Ядро Linux: Ядро Linux - это основная часть операционной системы.
Оно загружается в память и становится ответственным за управление ресурсами компьютера
и запуск других системных служб (на этом этапе происходит загрузка и выполнение
образов ядра и initrd).

Корневой диск для начальной инициализации (initial root disk - initrd) Представляет собой
виртуальную файловую систему в оперативной памяти (содержит rootfs). Этот диск минимальный набор
программ и модулей Linux, необходимый для обеспечения загрузки системы. Содержит необходимые
инструменты, скрипты для монтирования требуемых ФС перед запуском `/sbin/init` Ядро Linux запускает
скрипт настройки на этом корневом диске (init), который подготавливает систему, переключается к
действительной корневой ФС (наш корень) и затем передает управление `/sbin/init`.

Ядро работает в специальном режиме, «режиме супервизора», позволяющем ему иметь доступ сразу ко всей
оперативной памяти и аппаратной таблице задач. Процессы запускаются в "режиме пользователя": каждый
жёстко привязан ядром к одной записи таблицы задач, в которой, в числе прочих данных, указано,
к какой именно части оперативной памяти этот процесс имеет доступ. Ядро постоянно находится в памяти,
выполняя системные вызовы — запросы от процессов на выполнение этих подпрограмм.

Задача ядра — определить список внешних устройств, составляющих компьютер, на который оно угодило,
классифицировать их (определить диски, терминалы, сетевые устройства и т. п.) и, если надо,
настроить. При этом на системную консоль (обычно первая вирутальная консоль Linux) выводятся
диагностические сообщения (впоследствии их можно просмотреть утилитой `dmesg`).

Во время запуска ядро делает ряд проверок:
1. Процерка ЦПУ
2. Проверка ОЗУ
3. Обнаружение устройств
4. Настройка вспомогательной подсистемы ядра (сеть и др.)
5. Монтирование корневой файловой системы
6. Запуск пространства пользователя

Если ядро не обнаруживает какой - либо пункт = Kernel Panic / Oops

Системная загрузка:

5. Инициализация (`/sbin/init` (pid - 1)): После загрузки ядра Linux, запускается инициализация.
(начало пространство пользователя) Это процесс, в ходе которого происходит запуск системных служб и
инициализация устройств, таких как сетевые карты, звуковые карты и т.д. На этом этапе запускаются
`.target` (овые) сервисы и дальше по списку.

Раньше systemd (`/sbin/init`) запускал `runlevel` сценарии, но сейчас `runlevel` скрипты устарели
(сохранены для обратной совместимости), и были заменены `.targets`. Например: `runlevel 6`
соответствует target `reboot.target` (перезагрузка системы). В системах, использующих systemd,
каталоги `rc*.d` больше не используются для управления службами. Вместо этого systemd использует
свои собственные конфигурационные файлы.

6. Запуск системных служб: В этом этапе запускаются различные системные службы и демоны,
которые обеспечивают функциональность операционной системы. Примеры таких служб включают
сетевые службы, службы управления энергопотреблением, службы безопасности и т.д.

7. Вход в систему: После выполнения всех предыдущих этапов, операционная система переходит
в режим ожидания, где пользователь может войти в систему, используя свои учетные данные.


--- GRUB
Основная функция загрузчика Linux включает в себя возможность выполнять следующие задачи:
* выбирать одно из нескольких ядер;
* переключаться между наборами параметров ядра;
* разрешить пользователю вручную переопределять и редактировать имена и параметры образов ядра;
* обеспечить поддержку загрузки других операционных систем;

Файл конфигурации GRUB, который отображается при нажатии кнопки `e` в меню GRUB, можно прочитать в
файле `/boot/grub/grub.cfg` на диске. Однако, не рекомендуется редактировать этот файл напрямую, так
как он обычно генерируется автоматически с помощью команды `update-grub`, которая использует шаблоны
и настройки из `/etc/default/grub` и скриптов в `/etc/grub.d/`.

GRUB (GRand Unified Bootloader) в основном предназначен для загрузки операционной системы. Он
управляет процессом загрузки, позволяя пользователю выбрать операционную систему или ядро, которое
он хочет загрузить, и затем передает управление этому выбранному ядру.

1. GRUB не участвует в процессе выключения. Его роль ограничивается начальной фазой загрузки системы.
2. Процесс выключения (или перезагрузки) управляется самим операционным ядром (kernel)
и операционной системой, которые выполняют последовательность действий для корректного завершения
всех процессов, демонтирования файловых систем и отключения питания.

Таким образом, когда вы выключаете систему, GRUB не играет никакой роли. Его задача завершается
после того, как операционная система была успешно загружена.


--- Смена GRUB DEFAULT
Возможные варианты выбора можно получить так:
$ grep gnulinux /boot/grub/grub.cfg

GRUB хранит информацию о ядре в файле `/boot/grub/grub.cfg` и `/boot/efi/EFI/debian/grub.cfg`.

Например: gnulinux-simple-edb17961-1554-43e8-a149-3cd4ec6b3700
Задать данный вариант нужно в файл `/etc/default/grub`.

Можно выключить GRUB_SAVEDEFAULT (закомментировать или поставить false)
А в саму переменную GRUB_DEFAULT=gnulinux-simple-edb17961-1554-43e8-a149-3cd4ec6b3700 поставить так.

Затем делаем `update-grub` и готово :)
Так же важно заметить, что можно сменить время таймера GRUB_TIMEOUT и многое другое.


--- Уровни выполнения (устарело, не используется)
Все стартовые сценарии хранятся в `/etc/init.d`.

* 0 и 6 останова и перезагрузка

* 1 Уровень. Однопользовательский режим загрузки системы (не запускает никаких служб)
нужно для одного администратора, исправление ошибок

* 2 Уровень. Многопользовательский режим загрузки системы (службы есть, кроме сети)
можно настроить сети + администрировать

* 3 Уровень. Такой же как и 2 уровень + настроенная сеть
(на этом уровне обычно работают серверы)

* 5 Уровень. Многопользовательский графический режим загрузки X11

Переход на определенный уровень:
$ /sbin/init 1

Описание текущего уровня:
$ runlevel


--- За что отвечает ядро (за какие задачи)
* Процессы (ядро отвечает каким процессам разрешен доступ к ЦПУ)
* Аппаратура
- ЦПУ
- Память (ядро отслеживает состояние всей памяти, что свободно? что можно выделить?)
- Драйверы устройств (ядро выступает в качестве интерфейса между аппаратными средствами,
  например жёстким диском и процессами)
* Пользователи
- Системные вызовы (обычно процессы используют системные вызовы для взаимодействия с ядром)
- Разграничение прав доступа, взаимодействие пользователей, процессов и т.д
* Время
* ФС
* Сеть
* Виртуализация

Важно понимать что ядро располагает собственной областью памяти, к которой не могут получить доступ
пользовательские процессы. Пользовательские процессы не могут залезать на территорию памяти другого
процесса. А у пользовательских процессов есть свое пространство для которого ядро выделяет память,
называется - пространство пользователя. Важно отметить, что root пользователь работает в режиме
пользователя системы, а не в режиме ядра (это важно понимать) В плане памяти у ядра есть помощник
называемый MMU (виртуальная память) Ядро и процессы располагаются в памяти!

Ядро Linux представляет собой своего рода виртуальную машину для процессов. Процессы работают без
всякой информации про оборудование компьютера - ядро абстрагирует весь уровень оборудования в единый
совместимый виртуальный интерфейс. Кроме того, ядро реализует многозадачность прозрачно для всех
процессов - каждый процесс думает, что он является единственным процессом в системе, и имеет полные
и эксклюзивные права на память и другие ресурсы оборудования компьютера. Фактически же - ядро
выполняет несколько процессов одновременно, и оно ответственно за распределение ресурсов
оборудования таким образом, что бы каждый процесс получил достаточный доступ к этим ресурсам.

Ядро реагирует на события (системные вызовы), обрабатывает запросы оборудования, обеспечивает
диспетчеризацию процессов (scheduling)


--- Уровни ОС
* Оборудование
Центральный процессор выполняющий команды, память, устройства ввода, вывода
(input/output devices - I/O devices) и т.д

* Операционная система
Управляет использование аппаратуры компьютера

* Прикладные программы
Предназначены для решение различных задач пользователя

* Пользователь
Тот кто управляет всем этим становится частью системы


--- Состав ядра Linux
1. Process Scheduler (SCHED)
Планировщик процессов, отвечает за контроль над доступом процессов к CPU
Обеспечивает такое поведение ядра, при котором все процессы имеют справедливый
доступ к центральному процессору.

2. Memory Manager (MM)
Менеджер памяти, обеспечивает различным процессам безопасный доступ к основной
памяти системы. Кроме того, mm обеспечивает работу виртуальной памяти,
которая позволяет процессам использовать больше памяти, чем реально
доступно в системе. Выделенная, но неиспользуемая память вытесняется
на файловую систему, и при необходимости - возвращается из неё обратно в память (swapping)

3. Virtual File System (VFS)
Уровень абстракции поверх конкретной реализации файловой системы.
Целью VFS является обеспечение единообразного доступа клиентских приложений к
различным типам файловых систем.

4. Network Interface (NET)
Сетевые интерфейсы, обеспечивает работу с различными сетевыми стандартами
и сетевым оборудованием.

5. Inter-Process Communication (IPC)
Межпроцессное взаимодействие, обмен данными между потоками одного или разных процессов,
реализуется посредством механизмов, предоставляемых ядром OC или процессом.


--- Внутреннее устройство Linux
Делят на два уровня: пространство пользователя / пространство ядра.

* Пространство пользователя - user mode
GUI / CLI, библиотеки, утилиты, прикладные программы, GNU C Library

* Пространство ядра - kernel mode
- Аппаратная платформа, распределение ресурсов, ЦПУ, памяти, подкачки, времени, планировщик задач
- Системные вызовы, межпроцессорное общение, сигналы, процессы, нити, ввод/вывод, кэширование, вирт.память
- Сетевой стек, виртуальная файловая система, драйверы устройств
- Код ядра, то что поддерживает работу ядра

Подкачка используется тогда, когда происходит нехватка памяти, в результате страницы удаляются и
переносятся на жесткий диск. Обмен между оперативной памятью и жестким диском.

Библиотека GNU C осуществляет взаимодействие этих двух уровней, пространств.
В ядре Linux реализовано множество архитектурных элементов. Linux можно рассматривать
как монолитное целое, так как все общие сервисы находятся в ядре системы. Linux включает
в себя огромный функционал настроек. Ядро Linux поддерживает огромное кол-во протоколов.


--- Память компьютера
ОЗУ (RAM) делится на:

* Динамическая память(DRAM) при хранении данных должна периодически обращаться к каждой ячейки
памяти для хранения и подкреплять информацию более свежей. Не запоминает информацию надолго.
Находится в движении постоянно (ток прекращается и память становится больше невалидной), такой
памяти нужно постоянно обновляться чтобы сохранить данные. DRAM обычно используется в качестве
основной памяти в компьютерах и имеет высокую скорость доступа к данным.

* Статическая(SRAM) - запоминает без многочисленных обращений, запоминает надолго, пока устройство
не отключат. Находится в покое, пример такой памяти - кэш (L1 / L2 / L3) и регистры. Очень высокая
скорость получение данных, но это обходится более дорого (в плане энергопотребления).

Бывает так же:
* Внутреняя память - память компьютера (ОЗУ), обращение по адресам, работает пока ПК включен, энергозависима.
* Внешняя память - носители, оптические диски, cdrom, флешки, энергонезависима.

Linux отводит определенный размер памяти для хранения образа ядра, кода и статический данных.
Остальная оперативная память используется для:
* Запросы ядра на буферы, дескрипторы и другие динамические структуры данных.
* Запросы процессов на определенные области памяти.


--- Уровни памяти
Чем ниже, тем медленнее, но больше объем.
Чем выше, тем дороже.

У процессора есть регистровая память и кэш память.
Регистры это маленькие ячейки памяти расположенные на процессоре.
Самая маленькая память, самая быстрая потому что память расположена
прямо на процессоре и ему не надо никуда обращаться.

1. Регистры (SRAM)
Самая быстрая память компьютера. Бывают до 64 бита (8 байт).
Но их мало, поэтому много там не сохранишь.

2. Кэш (SRAM)
В кэшах хранятся обычно виртуальные адреса.
Не user space / kernel space не знают ничего про эту память.
Процессор обращения к памяти направляет через кэш (как proxy)

Схема такая: CPU Core -> Cache -> Main Memory и в обратную сторону
Процессор без кэшей работает довольно медленно.

Например: `for (int a = 0; i < count; ++i) { };` Переменные находятся в кэше.

Уровни кэша, используются для ускорения доступа к данным процессора:

* Кэш L1 (32кб)
Кэш L1 является самым быстрым и наименьшим по объему. Он находится прямо
внутри ядра процессора и обеспечивает наиболее часто используемые данные
и инструкции для минимизации задержек.

* Кэш L2 (512кб)
Кэш L2 немного медленнее и больше по размеру, чем L1. Он может находиться внутри
процессора или на отдельном чипе, близко к процессору. L2 служит в качестве буфера
между кэшем первого уровня и остальной памятью.

* Кэш L3 (2мб)
Кэш L3 является самым медленным и самым большим из трех уровней кэша, часто разделяемым
между несколькими ядрами процессора. Он действует как резервный кэш для L1 и L2 и помогает
уменьшить количество обращений к еще более медленной основной оперативной памяти.

Все три уровня кэша работают вместе, чтобы минимизировать задержки и ускорить обработку данных,
предоставляя процессору быстрый доступ к наиболее важным данным и инструкциям.

3. Оперативная память
SRAM / DRAM

4. Системная шина (System Bus): Шина соединяет CPU с другими компонентами компьютера,
такими как оперативная память (RAM), устройства ввода-вывода и т.д.,
и обеспечивает передачу данных между ними.

5. Флеш память и Магнитная память
Внешние устройства, передают данные через оперативную память, обращение через ядро.
Можно снимать / подключать, при этом ничего не перепаивая.


--- Recovery mode
Нужен для восстановления системы (режим восстановления) где есть командная строка
для исправления чего-либо (неисправной системы)


--- Capabilities - полномочия (мандаты)
Linux привилегии появились с Linux 2.6 ядра, до этого были просто `setuid`.
Полномочия обычного пользователя очень ограничены, в отличие от root пользователя,
так вот если нашему пользователю понадобиться осуществить привилегированное действие,
например убить процесс другого пользователя. Система выдаст на это
Операция не позволена - будет защитный механизм. Для этого были поделены
права root пользователя на отдельные, такие как CAP_KILL / CAP_CHOWN / CAP_NET_RAW
и многие другие, полный список которых можно получить `man capabilities`.

Дочерние процессы наследуют привилегии от процессов родителей.

Задаются привилегии $ setcap cap_kill+ep /bin/kill
Получить информацию о файле $ getcap /bin/kill
Удалить привилегию с файла $ setcap -r /bin/kill
Посмотреть привилегии конкретного процесса $ getpcaps <pid>
Привилегии пользователя $ capsh --user=root --print
`--print` показывает эффективные, наследуемые и доступные привилегии.

Можно рекурсивно посмотреть все привилегированные файлы:
$ getcap -r / 2>/dev/null

Есть 3 основных набора бит:
Inheritable (наследуемые) - разрешения, которые могут наследовать потомки.

Permitted (доступные) - это максимальный набор прав и привилегий, которые может
использовать процесс или пользователь. Это своего рода "потолок" для effective capability,
то есть effective capability не может превышать permitted capability.

Effective (текущие) - фактически используются в данный момент процессом
или пользователем в операционной системе.

При запуске нового процесса через execve, полномочия для дочернего процесса преобразуются
с использованием формулы $ man capabilities

Операторы `:`, `?`, `&`, `|` имеют значения как в Си, а другие P` (дочерний процесс, после execve)
P (текущий процесс, вызывающий execve, до execve) F (файловые разрешения)

Чтобы узнать привилегии процесса:
$ cat /proc/1/status
CapInh:	0000000000000000
CapPrm:	000001ffffffffff
CapEff:	000001ffffffffff

$ capsh --decode=000001ffffffffff

Например, задали `/usr/bin/sleep cap_kill,cap_syslog,cap_net_raw+ep`
Запустили `sleep` и узнали его `pid`, `/proc/<num>/status`

$ capsh --decode=400002020
Получили те же привилегии, что и задавали.

В `/usr/include/linux/capability.h` привилегии определены последовательно.
Например, CAP_NET_BIND_SERVICE равен 10, его hex можно высчитать `1 << 10`
получиться 0x400
$ capsh --decode=400 -> CAP_NET_BIND_SERVICE


--- Как ядро работает с процессами, пользователями
Когда мы говорим, что пользователь выполняет операцию, то на самом деле имеется в виду, что операцию
выполняет процесс с идентификатором соответствующего пользователя. Когда процесс делает системный
вызов, ядро проверяет идентификаторы процесса и определяет, имеет ли процесс право доступа к
запрашиваемым ресурсам. Если у процесса идентификатор пользователя 1000 и он запрашивает что-то
привилегированное, то ядро вернет на это ошибку, тот же принцип с GID. То есть ядро не работает с
именами пользователей / групп, а оно работает с идентификаторами. Пользователи, логины, группы, это
всё в user space.

Ядро занимается в основном хранением паролей, сверкой хешей и прав доступа (это что касается
пользователей). Например, если посмотреть стрейс useradd <user> там не будет системных вызовов по
типа `useradd`, будет `read()` / `write()` и различные сравнения полномочий, но не больше ...
Ядро не знает, что такое пользователь и что такое "добавить пользователя".

С помощью прав доступа к файлам можно определить кому разрешено обращаться к этим файлам, а кому
нельзя обращаться.

Как ядро определяет, имеет ли процесс право обратиться к заданному файлу. Сначала выясняется, кем
является пользователь, запустивший процесс: владельцем файла, членом его группы или кем-то другим.
В зависимости от категории пользователя проверяется соответствующий набор битов
чтения/записи/выполнения и на его основании принимается окончательное решение.

Есть, правда, одно важное исключение: процессы, запускаемые пользователем root (его идентификатор
равен нулю), всегда получают доступ к требуемым файлам независимо от их атрибутов.

Идентификация  - что за пользователь перед нами?
Аутентификация - подтверждение, su abc -> введите пароль, а вы точно abc?
Авторизация    - определение границ того, что дозволено пользователю


--- Идентификаторы пользователей
Каждый процесс снабжен несколькими идентификаторами пользователя (эффективный `euid` / реальный `ruid`)
Реальный `ruid` это как раз обычный `uid/gid`.
Эффективный (euid) - это идентификатор, под которым в настоящий момент выполняется процесс,
а реальный (uid) - это идентификатор пользователя, который изначально запустил процесс.

Любой пользователь может поменять пароль с помощью команды `passwd`, которая пишет
в файл `/etc/passwd` (файл суперпользователя), как так получается ? У файла `passwd`
есть `setuid` бит, с помощью которого эффективный UID поднимается до уровня root

Например:
int main(void)
{
  printf("%d %d\n", getuid(), geteuid());
  return 0;
}

Скомпилировать + поменять владельца (change owner), задать set bit - `chmod u+s a.out`.
И затем, можно наблюдать, что реальный ID равен 1000, а эффективный поднялся до уровня root
и стал 0. Это означает, что мы запустили программу от 1000 пользователя и реальный ID равен 1000,
а эффективный ID стал 0, потому что программа выполняется под ID 0

Проще говоря, `setuid` это - мы запустились не от root, но программа работает от root
Данный трюк не дает права root навеки вечные, это означает, что наш процесс будет работать от 0,
а ID пользователя изменен не будет. Программы с `setuid` нужно писать аккуратно
(если `euid` меняется к 0).

Один из лучших советов касательно программ, устанавливающих идентификаторы пользователя (UID) или
группы (GID), заключается в том, что их лучше не писать. Если существует возможность выполнить
задачу без получения повышенных привилегий, мы должны рассматривать ее в первую очередь,
поскольку это позволяет избежать потенциальной угрозы безопасности.

Возьмем для примера приложение, которое должно предоставить пользователям возможность обновить файл,
прав на запись которого они не имеют. Наиболее безопасным способом это сделать является создание
отдельной групповой учетной записи (идентификатора группы) специально для этой программы и
назначение этой группы соответствующему файлу (так, чтобы участники группы могли его записывать);
после этого можно написать программу, которая будет устанавливать действующий идентификатор этой
группы. Поскольку данная группа не имеет никаких других привилегий, это ограничивает потенциальный
ущерб на случай, если программа содержит ошибки или может быть использована злоумышленником.

Если приложение, устанавливающее пользовательский или групповой идентификатор, запускает другую
программу, оно должно сбросить все свои UID и GID к значению реального идентификатора пользователя
(группы), чтобы новая программа не унаследовала повышенные привилегии и не смогла их самостоятельно
получить. Один из способов, как этого можно достичь, заключается в сбрасывании всех идентификаторов
до выполнения `exec()`.

Привилегированная программа может открыть файл, недоступный обычным процессам. Полученный файловый
дескриптор представляет привилегированный ресурс. Перед выполнением `exec()` он должен быть закрыт,
чтобы запускаемая программа не смогла получить доступ к связанному с ним файлу. Необходимо закрывать
все файловые дескрипторы перед выполнением `exec()` Потому что дескрипторы файлов, открытые
родительским процессом, по умолчанию наследуются дочерним процессом при использовании системного
вызова `fork()`

Привилегированные программы не должны действовать, исходя из своих предположений о предоставляемом
им вводе или среде, в которой они выполняются. Не нужно доверять переменным среды.


--- uefi vs legacy bios (режимы загрузки)
`uefi` новый BIOS, а `legacy` старый (синий экран)

uefi
* быстрее загружается
* есть secure boot, который якобы делает безопаснее загрузку OC
* драйвера грузятся в uefi и передаются затем ОС
* имеет современный GUI
* формат загрузки дисков GPT
  (стандарт формата размещения таблиц разделом на физ.диске)

legacy
* драйвера загружаются во время запуска ОС, после загрузки биоса
* синий привычный экран, старый интерфейс
* формат загрузки дисков MBR


--- Что такое pam
Модули аутентификации.
API который осуществляет проверку подлинности пользователя.
Раньше проверку осуществляла утилита `login`, которая проверяла
данные введенные пользователем с `/etc/passwd` (сейчас это делает `/etc/shadow`),
сейчас же просто передает данные PAM, а он их проверяет с помощью
различных алгоритмов и возвращает ответ.

Настройка PAM осуществляется с помощью `/etc/pam.d/<name_program>`.
В этих файлах указано, что для успешной аутентификации пользователь
должен пройти через все указанные модули, модуль указан сначала, например `auth`.


--- Что такое архитектура процессора
32 бит или x86 или x32, или i386 - это почти одно и то же (архитектура процессора)

Архитектура 64 бит или x86-64 или amd64 или x64.

Разница между 32 и 64 в размере ячейки памяти. У 64 она больше, чем у 32, поэтому 64 уместит в себе
больше данных. Основная разница между 64-битной и 32-битной архитектурами заключается в количестве
данных, которое может обрабатывать процессор за один раз. 64-битные процессоры могут обрабатывать
гораздо большие объемы данных по сравнению с 32-битными, что приводит к более высокой
производительности и возможности использования большего объема оперативной памяти (более 4 ГБ).
Это позволяет запускать более сложные и требовательные приложения, а также улучшает многозадачность
и скорость обработки данных.


--- x86 vs ARM
Большинство смартфонов Apple, Android работают на архитектуре процессора ARM. В Apple смартфонах
встроены очень современные процессоры от ARM, это их плюс. На компьютерах доминирует x86 от Intel и
AMD. Невозможно запустить Word на телефоне.

На x86 сложный ассемблер, на ARM он попроще, в этом отличие, ассемблер отличается.
Разный дизайн процессора, то есть архитектура, x86 = CISC. ARM = RISC.

CISC - это сложные инструкции для x86, а RISC инструкции попроще.
Инструкции - это готовые функции для процессора.

В CISC присутствует очень много старых инструкций из 60 годов.
RISC более современная и обновленная архитектура.

Так же в ARM архитектуре проще устроена работа с памятью, больше производительность.
Современные x86 процессоры включают в себя ядра с поддержкой RISC, тем самым развивая CISC.
ARM процессоры бывают как 32 битными, так и 64 битными.


--- Что такое регистр
Это важный компонент CPU, через регистры производятся все вычисления. Специализированная ячейка
памяти, входящая в состав процессора. Регистры выполняют функции кратковременного хранения и
преобразования данных или команд. На физическом уровне регистр представляет собой совокупность
триггеров, способных хранить один двоичный разряд и связанных между собой общей системой управления.

Это определение связанно с ассамблером. Некоторые регистры хранят в себе стек, код, данные и т.д.
Регистр почти как переменная в программировании.

Регистр процессора x86-64 имеет объем 64 бита (8 байт).


--- Форматирование диска
Создание определенной ФС + зачистка старой. Во время форматирования создается ФС, создается
своебразная логическая таблица, с помощью которой в будущем и будет осуществляться доступ к
определенным данным.

Если вы приобрели новый жесткий диск, то вполне вероятно на нем еще нет файловой системы, то есть он
неотформатирован. В этом случае можно сделать форматирование, в результате чего на диске будет
создана файловая система и он будет готов к хранению информации.

При форматировании будет разрушена старая файловая система и на ее месте будет создана новая.
Это означает, что все данные, которые хранились на диске, будут потеряны!


--- Какое ядро бывает
Монолитное ядро — это архитектура операционной системы, при которой ядро системы является единым
целым и работает в одном адресном пространстве. Все основные компоненты системы, такие как драйверы
устройств, файловая система, управление памятью и прочее, интегрированы непосредственно в ядро и
выполняются в режиме ядра, то есть с максимальными привилегиями.

Это противоположно микроядерной архитектуре, где эти компоненты выполняются отдельно
как пользовательские процессы. Примерами операционных систем с монолитным ядром являются:
Linux, Windows и macOS.

Микроядро - это маленькое ядро с базовым функционалом (урезанное), выполняет базовые функции, а
большая часть сервисов и драйверов устройств реализована в виде модулей, работающих в
пользовательском пространстве. Это обеспечивает более высокий уровень модульности и изоляции,
повышает безопасность и упрощает обновление и обслуживание системы (их проще отлаживать, чем
монолитное ядро).

Базовые функции - это например, MM, IPC, Scheduler.

Микроядра являются модульными, и различные модули можно заменять, загружать, модифицировать, даже не
касаясь ядра. Единственный минус, микроядро намного медленнее чем основное ядро (из-за частых IPC).


--- Аудит
Нужен для отслеживания критичных с точки зрения безопасности системных событий.
* запуск и завершение работы системы;
* чтение, запись и изменение прав доступа к файлам;
* инициация сетевых соединений;
* попытки неудачной авторизации в системе;
* изменение сетевых настроек;
* изменение информации о пользователях и группах;
* запуск и остановка приложений;
* выполнение системных вызовов;

Ни одно из названных событий не может произойти без использования системных вызовов ядра.
Чтобы их отслеживать, достаточно просто перехватывать соответствующие системные вызовы.
Именно это и делает подсистема аудита.

$ apt-get install auditd
$ systemctl status auditd

Конфигурация: `/etc/audit/auditd.conf`.

$ autrace <path>                 # выполнить программу и отследить ее события (работает как strace)
$ ausearch -i -p <pid>           # после autrace
$ ausearch -ui 1000              # события 1000 пользователя
$ ausearch -i -e -13             # поиск событий по коду выхода
$ ausearch -ui 1000 -sc open     # искать события open
$ ausyscall --dump               # номера всех системных вызовов

При просмотре журнала аудита (событий) можно увидеть различные key=value
Поля начинаются с ключевого слова type:

type=SYSCALL                     # этих типов огромное кол-во, а текущий говорит, что произошел сис.вызов ядра
msg=audit(<n>.<n>:<n>):          # отметка времени
arch=c000003e                    # архитектура CPU (hex), чтобы писать по человечески нужно передать -i ключ
syscall=<n>                      # номер системного вызова $ ausyscall --dump
success=no                       # yes / no
exit=-13                         # код выхода $ errno -ls или $ ausearch -i -e -13
a0,a1,a2,a3                      # аргументы системного вызова
items                            # ?
ppid=<pid>                       # родительский процесс
pid=<pid>                        # текущий pid процесса

Различные uid поля, от какого id был запущен анализируемый процесс,
например auid (идентификатор пользователя сессии) затем можно делать:
$ ausearch -ui <uid> -i

tty=<>                           # номер tty или none
comm="cat"                       # команда, которая вызвала процесс
exe="/bin/cat"                   # путь команды
key=""                           #

type=CWD                         # текущая рабочая директория из которой был выполнен процесс

type=PATH                        # путь переданные в качестве аргумента
name="/etc/ssh/sshd_config"      # файл или каталог, который был передан системному вызову $ cat /etc/ssh/...
inode=<n>                        # номер индекса файла из name $ find / -inum <inode>
dev=00:05                        # minor & major ID of the device that contains the file or dir recorder in this event
mode=<perms>                     # атрибуты файла name
cap-*=                           # как-то связанно с привилегиями

type=DAEMON_START
type=USER_AUTH и др

AVC, здесь субъект (пользователь) имеет pdp-id 0:63:0:0, а объект /dev/sda имеет высокую метку конф.
subject=0:63:0:0 object=3:63:ffffffffffffffff:0


--- ACPI
Это стандарт (Advanced Configuration and Power Interface) определяющий способы программного
управления электропитанием компонентов компьютера с помощью встроенных средств ОС. Обеспечивает
взаимодействие между ОС аппаратным обеспечением и BIOS материнской платы. Другими словами данная
технология предназначена для управления состоянием персонального компьютера и энергопотреблением его
компонентов. ОС практически полностью управляет энергопотреблением и конфигурированием устройств
ПК. Спецификация ACPI требует поддержки со стороны, как материнской платы, так и подключаемых
устройств. Некоторые предыдущие версии BIOS не поддерживают интерфейс ACPI, поэтому компьютеры не
могут успешно переходить в дополнительные режимы питания, например в ждущий или спящий режим.


--- SCSI
Small Computer System Interface (скази) стандарты для физического подключения и передачи данных
между ПК и периферийными устройствами. SCSI-стандарты определяют команды, протоколы, интерфейсы.
Разработан для объединения на одной шине различных по своему назначению устройств, таких, как
жёсткие диски, накопители на магнитооптических дисках, приводы CD, DVD, сканеры, принтеры и т.д.


--- Secure boot
Технология Secure Boot нацелена на предотвращение исполнения недоверенного кода при загрузке
операционной системы. Устройства с Secure Boot содержат в энергонезависимой памяти базу данных
открытых ключей, которыми проверяются подписи загружаемых UEFI-приложений вроде загрузчиков ОС и
драйверов. Приложения, подписанные доверенным ключом и с правильной контрольной суммой, допускаются
к загрузке, остальные блокируются. Если подписанное приложение предоставляет возможность
недобросовестного использования напрямую или путём загрузки других приложений, оно становится
угрозой безопасности всех пользователей, доверяющих этому приложению.
