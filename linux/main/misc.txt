Темы:
* Учетные записи
* Атрибуты файла
* Изменение прав доступа
* Изменение владельца
* Hostname (сетевое имя компьютера)
* Окружение shell
* Файлы личного окружения пользователя
* Login shell и Non login shell
* Разница между терминалом и консолью
* Локализация
* Типы файлов в UNIX
* Виртуализация
* Графический интерфейс
* Сделать загрузочную флешку
* Создание приватного и публичного ключа
* Что такое fingerprint
* sudoers
* while (1) - 100% CPU
* Значения систем счисления (bin dec hex oct)
* Обратная совместимость
* Deb и RPM
* Floppy, CD, DVD, Blu-Ray, CDROM
* Дистрибутив
* Этапы разработки
* Android (передача файлов)
* Таблица разделов MBR vs GPT
* Что такое Subshell
* Рефакторинг
* Цвета тем
* Удаление файлов
* Облачное хранилище
* su vs sudo
* passwd vs shadow
* QEMU
* Гипервизор
* Виртуализация и контейнеризация
* Поддержка
* FAQ
* Основы шифрования
* ГОСТ
* foo bar
* Мандатная, ролевая и дискреционная модели
* X11 vs Wayland


--- Учетные записи
Учетные записи служат для авторизации, для разграничения прав доступа субъектов.
У каждого пользователя есть своя первичная группа. Два вида пользователей,
обычный и суперпользователь.

uid(user ID) - идентификатор пользователя
gid(primary group ID) - идентификатор основной группы

/etc/passwd - учетные записи ползователей хранятся в файле
              (имя пользователя, uid, gid, etc)

/etc/group - информация о группах

/etc/shadow - пароль пользователя


--- Атрибуты файла
`-` тип файла (`-` обычный файл, `d` каталог, `l` символическая ссылка,
               `c` файл для устройства, `b` блочное устройство)

`r` разрешается открывать и читать содержимое файла (без этого бита нет возможности открыть)
`w` разрешается записывать в файл или усекать его
`x` разрешается интерпретировать файл как программу и выполнять ее файлы сценариев

t (sticky bit) ограниченное удаление, присваивается каталогам. Например каталог
`/tmp` имеет sticky bit в этом каталоге могут создавать файлы все пользователи,
однако удаление чужих файлов - невозможно! Некий shared получается. Все
пользователи могут обмениваться между собой файлами.

s (setuid bit) предоставляет права другого пользователя, например, при запуске
файла с setuid. Создаваемый процесс получает полномочия пользователя-владельца
(группы владельца) запущенного файла `/etc/passwd` владелец root и права
`-rw-r--r--`, другие пользователи не могут изменять файл, кроме root, а утилита
`passwd` имеет `s` бит `ls -l $(which passwd)` `-rwsr-xr-x`, что означает что
любой пользователь может изменить свой пароль без прав суперпользователя.

Нужно запомнить что сначала идут привилегии для владельца, затем привилегии для
группы, затем привилегии для всех остальных. На каждый из этих трех классов
действий приходится по три бита, всего имеем девять бит.

read, write, execute - это права доступа к файлу.


--- Изменение прав доступа
Метод символических символов `chmod +x file`. Метод изменение прав доступа с
помощью восьмеричных чисел `chmod 777`.

Режимы доступа к файлу в двоичном и восьмеричном представлениях:
0  000  ---
1  001  --x
2  010  -w-
3  011  -wx
4  100  r--
5  101  r-x
6  110  rw-
7  111  rwx

Можно указывать прямо:
$ touch file; chmod 0 file
$ chmod +rwx file
$ chmod =r file
$ chmod -r file
$ chmod +t file
$ chmod +s file

(+) добавляет новые perms к файлу
(-) удаляет perms у файла
(=) удаляет существующие и заменяет на указанные

$ chmod u+rwx file
$ chmod g+w file
$ chmod o+r file
$ chmod a+rwx file


--- Изменение владельца и группы файла
$ sudo chown root: test_file


--- Hostname (сетевое имя компьютера)
Находится это название в файле `/etc/hostname` и его можно изменить, и `/etc/hosts`.
$ hostnamectl set-hostname <host_name>


--- Окружение shell
Командная оболочка на протяжении всего сеанса работы использует массу
информации, которая называется окружением. В окружение входит переменные
окружения, переменные командной оболочки (bash), псевдонимы, функции окружения.

Вывести окружение можно с помощью:
$ env
$ printenv PATH  # вывод переменной и его значения
$ set | less     # полное окружение, переменные, функции и т.д.
$ echo $HOME     # получить значение переменной

LANG             # язык программ
EDITOR           # текстовой редактор
DIRSTACK         # вершина стека
BASH_VERSION     # версия bash более чисто

Единственное что не выводит окружение это псевдонимы, но их можно посмотреть
командой alias.

Когда мы входим в систему, запускается программа bash и читает содержимое серии
конфигурационных сценариев, где определяется окружение по умолчанию, общее для
всех пользователей, затем запускается личное окружние, когда прочитаются файлы в
домашнем каталоге. Эти файлы используются для задания элементов окружения для
оболочки пользователя.


--- Файлы личного окружения пользователя
Программа оболочки Bash использует набор скриптов выполняемых при её запуске для
создания рабочего окружения. Каждый последующий выполняемый скрипт может
перезаписать значения, присвоенные предыдущим скриптом.

Важный системный файл, который читается всегда при запуске системы
`.bashrc` - существует для задания псевдонимов, команд, функций, используемых
пользователями оболочки bash.


--- Login shell и Non login shell
Оболочки:
- Интерактивная оболочка - взаимодействие (приглашение к вводу).
- Неинтерактивная оболочка - не может взаимодействовать (оболочка запускает скрипт
  или демон).

Login shell - это командная оболочка (shell), которая запускается при входе
пользователя в систему (при вводе логина и пароля). Она читает и выполняет
команды из файла настроек, например, `.bash_profile` или `.profile`, который
содержит переменные среды и другие настройки, специфичные для пользователя.

Non-login shell - это командная оболочка, которая запускается после входа в
систему, например, при открытии нового терминала или выполнении скрипта. Она
не читает файлы настроек логин-шелла, но обычно читает и выполняет команды из
другого файла настроек, например, `.bashrc`.

Основная разница между ними заключается в том, что login shell используется для
начальной инициализации сессии пользователя, устанавливая переменные среды и
прочие настройки, в то время как non-login shell предназначены для последующих
интерактивных сессий.

Чтобы распознать Login Shell: `echo $0` если есть '-bash' то вход осуществился.
Например вход по SSH на другой сервер производит Login Shell

Login Shell:
$ sudo -i
$ su -
$ su - <username>

Non-Login Shell:
$ sudo -s
$ su <username>

Различие заключается в разном порядке скриптов запуска при открытии этих
оболочек и их переменных окружения.

* Файлы окружения по умолчанию для всех пользователей
/etc/bash.bashrc   # выполняется для Non-Login Shell

/etc/profile       # выполняется для Login Shell

/etc/profile.d/    # находятся переменные окружения / параметры для всей
                   # системы, выполняется вместе с `/etc/profile`

~/.bashrc          # выполняется для Non-Login Shell

~/.profile         # выполняется для Login Shell

Данные файлы окружения запускаются от id пользователя, которым мы производим
вход в оболочку окружения. То есть когда user пользователь открывает оболочку
файлы окружения будут запущены от его имени.


--- Разница между терминалом и консолью
Для работы с консолью GUI не нужен. А терминал это программа, которая эмулирует
работу консоли и встроена в GUI. Все команды терминала - работают в консоли.
Терминал был создан для того, чтобы была возможность использовать консольные
утилиты при работе с GUI. Терминал позволяет использовать интерактивную
оболочку. Консоль нужна в тех случаях, когда есть проблемы с драйверами
видеокарты или графической оболочкой, например такие проблемы можно исправить
через консоль. Если какая-то программа зависнет и положит весь GUI, то на помощь
приходит консоль.

Терминал возвращает `pts/n` терминала
Консоль возвращает `tty/n` консоли

Можно отправить что-либо с ввода в вывод в другой терминал :)
$ echo "Hello" > /dev/pts/0


--- Локализация
Набор переменных, который определяет язык приложений, консоли и т.д.

Например, разбор en_US.UTF8:
en - язык
US - региональная настройка
UTF8 - кодировка

Региональная настройка - это определенные параметры, такие как формат даты и
времени, валюта, числовой формат и другие локальные настройки, которые могут
отличаться от других стран.

Кодировка - определяет соответствие между символами и числовыми значениями,
которые используются компьютером для их хранения и обработки.

Получить все доступные локали:
$ locale -a

Чтобы изменить локаль можно задать:
$ export LANG=en_US.utf8

Если при выводе выдаются ошибки типа:
Cannot set LC_CTYPE to default locale: No such file or directory

То скорее всего задается локаль, которая не была сгенерирована. Для этого нужно
подправить `/etc/locale.gen`. В этом файле нужно раскомментировать нужную
локализацию, например en_US.UTF-8 UTF-8.

Затем выполнить:
$ locale-gen
Появится новая локализация:
$ locale -a

Можно запустить приложение с другим языком, например:
$ LANGUAGE=zh_TW vim

LANG - Локаль, установленная в этой переменной используется в качестве значения
для всех остальных LC_*-переменных.

LANGUAGE - Запасные локали (нужно для вывода сообщений на разных языках).


--- Типы файлов в UNIX
1. Обычный файл (regular file) '-'
2. Каталог (directory) 'd'
3. Именованный канал (named pipe) 'p'
4. Символическая ссылка (soft link) 'l'
5. Специальный файл устройства (device file) 'c' и 'b'
6. Сокет (socket) 's'


--- Виртуализация
Термин "хостовая" обычно используется в контексте сетевых технологий и
обозначает компьютер или устройство, которое предоставляет ресурсы, данные или
услуги для других компьютеров или устройств, известных как клиенты, в сети.
Хост может быть сервером, который управляет веб-сайтами, электронной почтой,
базами данных и т.д. В более общем смысле, хостовая машина - это машина, которая
является домом для выполнения определенного программного обеспечения или
сервиса.

Эмулятор виртуальной машины - это ПО, устанавливаемое на хостовую ОС и
состояющее из монитора виртуальных машин. Монитор виртуальных машин
предоставляет собой ПО, обеспечивающее взаимодействие между виртуальными
машинами и реальным оборудованием.

Гостевая ОС - это операционная система, устанавливаемая на созданную виртуальную
машину.


--- Графический интерфейс
Заботы о вводе и выводе на низком уровне берёт на себя графическая подсистема
Linux - X11 (X Windows System), пространством ресурсов является ЭКРАН. На экране
отображатеся команды графического вывода и организуется обратная связь с
устройствами графического ввода. Примером обратной связи является - указатель
мыши. Сама мышь простое устройство ввода, способное передавать информацию о его
перемещении (точка ввода - фокус) Под управлением X11 (X Windows System)
осуществляется работа всех графических приложений.

Состоит эта система из X-сервер и X-клиент.

* X-сервер - это программа, которая организует работу с устройствами
ввода/вывода, производит отрисовку видимых элементов и предоставляет свои
ресурсы для X-клиентов, загружает драйверы устройств (видеокарты, мыши,
клавиатуры, управление раскладкой клавиатуры, шрифты). Процесс запускаемый
в фоне.

* X-клиент - программа, осуществляющая ввод/вывод графических данных при помощи
X-запросов к X-серверу браузер, программа, игры, мультиплеер, графические
редакторы и т.д это задачи, которые обращаются к X-серверу с запросами, обычно
клиент имеет окно (или несколько) потом клиент регистрирует события/активность
устройств ввода и изменение свойств окна.

Когда пользователь открывает графические приложение, то оно соединяется с
X-сервером по стандартному протоколу X11 и получает от X-сервера информацию о
событиях, перемещения мыши, нажатия кнопок и т.д.

X-сервер не занимается прорисовкой окна программы, не отвечает за внешний вид
приложения, он отрисовывает всё это в точности как ему передал X-клиент,
он занимается чтением данных из устройств ввода и передачей разных событий
X-клиенту. Так же X-сервер называется еще xorg.

Отрисовкой графического приложения занимаются библиотеки (тулкиты) gtk/qt
Затем они передают информацию библиотеке libX11 (транслятор) Затем библиотека
запрашивает информацию у X-сервера.

Для того чтобы X-клиенты обращались со своими запросами к X-серверу должен быть
какой-то точный адрес. Адрес X-сервера, к которому должны обращаться X-клиенты
хранится в переменной окружения DISPLAY (способ_доступа:номер_сервера.номер_экрана)
Под способом доступа может подразумеваться сеть (тогда используется сетевой
адрес машины с X-сервером). Если запустить команду `who` можно заметить (:0)
способ доступа стоит по умолчанию : а 0 это номер сервера.

Можно в shell указать адрес X-сервера в переменной DISPLAY, затем любой
запущенный X-клиент унаследует это значение и будет отправлять запросы X-серверу
к которому указано Например: $ export DISPLAY=:0

Чтобы включить X-сервер при удаленном подключении стоит прописать $ ssh -X
Чтобы приспособить графическую систему к имеющимуся оборудованию, требуется
организовать профиль, который находится в `/etc/X11`.

xterm - это эмулятор терминала системы X Window, а например gnome
терминал - стандартный эмулятор терминала проекта GNOME

xdm(x display manager) - дисплейный менеджер, программа, которая позволяет
запуск сессии на X-сервер, позволяет пользователю войти под своей уч.записью.

Важно заметить что оконный менеджер в каждом дистрибуте свой, эта программа
управляет размещением окон и их внешним видом xfwm4 fly-wm

`./Xauthority` в каждой домашней директории лежит файл используется для
аутентификации X-сессий, если он весит 0 байт или есть такие же файлы, то
наверное стоит их удалить, чтобы при повторном логине, создался новый такой
файл, в переменной окружения XAUTHORITY хранится путь к этому файлу.

Рабочий стол оформлятеся благодаря графическим средам для X11, такие как:
KDE, GNOME, XFCE

Можно из командной строки запустить графическую систему `sudo startx`.
Можно из командной строки запустить X-сервер `sudo X`.


--- Сделать загрузочную флешку
Очень важно обратить внимание, где используется конкретный раздел, а где само
устройство, например `dd` -> `/dev/sdb`, а `mkfs` -> `/dev/sdb1`.

Нужна - флешка и сам образ (.iso)
Для начала нужно подготовить флешку, сделать раздел W95 FAT32:
$ fdisk /dev/sdb
$ d # очистить

После удаления смотрим командой p разделы (их быть не должно - пустая)
$ p

Затем создание `n`, Выбрать primary, Выбрать default
Нажать `p` и убедиться что раздел создан System - Linux
Затем `t` -> `b` (получается W95 FAT32)
Затем перезапись -> `w`
$ mkfs.vfat /dev/sdb1 # (форматирование раздела)
С помощью `mkfs` создается новая файловая система

Затем записываем на флешку образ:
$ dd if=full_path.iso of=/dev/sdb bs=4M status=progress oflag=sync

Можно использовать `sync`, он сбрасывает все данные в кэше на устройство иногда
флешка может недозаписаться и тогда некоторые данные будут отсутствовать поэтому
лучше использовать `sync`:
$ dd bs=4M if=full_path.iso of=/dev/sdb status=progress; sync

Аналог:
$ dd bs=4M if=full_path.iso of=/dev/sdb status=progress oflag=sync

Чтобы очистить флешку:
d <n>   удаляем разделы
w       делаем запись
Затем можно отформатировать.


--- Создание приватного и публичного ключа
Открыть дополнительный tty в случае неправильных действий.

* На клиенте
SSH подключения без пароля - по ключам, генерация осуществляется с помощью `ssh-keygen`.

$ ssh-keygen              # создает id_rsa и id_rsa.pub
$ ssh-keygen -f id_file   # создает id_file и id_file.pub

При генерации можно добавить пароль к ключу, который будет запрашиваться при
входе на сервер, или оставить поле пустым.

* На сервере
$ mkdir .ssh
$ touch .ssh/authorized_keys # сюда нужно прописать .pub ключ
А приватный ключ хранится у нас на клиенте, его никому нельзя показывать.

Права доступа к `.ssh`
.ssh   # директория 700
.ssh/* # все файлы без исключеня должны быть 600
Владелец должен быть пользователь от которого происходит подключение.

После можно сделать `/etc/ssh/sshd_config`:
PubkeyAuthentication yes
PasswordAuthentication no
AuthorizedKeysFile .ssh/authorized_keys
и можно закомментировать PermitRootLogin

Затем `systemctl restart sshd.service`.
Теперь при подключении к серверу будет требовать пароль ssh ключа
Или просто входить без пароля, если мы не ввели ключевую фразу при генерации.

Так как название файла отличается от дефолтного id_rsa необходимо прописать
в `.ssh/config` на клиенте, например:
Host 192.168.50.240
  IdentityFile ~/.ssh/id_pc

Вот еще пример:
Host wb
  Port 33033
  User rrrrrrr
  HostName 95.70.100.200
  IdentityFile ~/.ssh/id_work_builder

Затем можно будет подключаться так:
$ ssh wb

Чтобы оставаться долго в ssh сессии, можно прописать `ClientAliveInterval 3600`.

sshd_config - ssh-сервер
ssh_config - ssh-клиент

Выполнить команду на сервере (перед выходом из SSH сессии)
$ nohup ./script.sh >/dev/null &


--- Что такое fingerprint
При первом подключении по SSH к удаленной машине генерируется fingerprint и
добавляется в файл known_hosts, наш ПК запоминает эту комбинацию и сверяет ее
при каждом входе, если кто-то переустановит SSH сервер или OC, то мы об этом
узнаем, потому что изменится fingerprint.


--- sudoers
User is not in the sudoers file
Можно добавить пользователя в группу sudo
$ usermod -aG sudo user и тогда пользователь может использовать sudo (работает не везде)

Добавление новой записи в `/etc/sudoers` происходит через `visudo`. Например,
чтобы не запрашивать пароль при получении прав суперпользователя можно добавить:
`<user> ALL=(ALL:ALL) NOPASSWD:ALL`. Но добавить эту строку нужно уже в конец
файла или после записи `%sudo`

Данное действие нужно проводить только в крайних случаях.
Можно еще сделать для конкретной программы, например:
<user> ALL=NOPASSWD: /usr/bin/apt

-> Требование пароля повышает планку для злоумышленника.


--- while (1) - 100% CPU
Процесс с бесконечным циклом использует CPU на 100% потому что эти ресурсы
простаивают, если бы были другие интенсивные процессы, то 100% бы не было,
а было бы 89% например.


--- Значения систем счисления (bin dec hex oct)
Символический метод записи чисел
bin - двоичное (1/0)
oct - восьмеричная (0,1,2,3,4,5,6,7)
dec - десятичное число (0,1,2,3,4,5,6,7,8,9)
hex - шестнадцатеричное (0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F)

Например, с помощью десятичной системы счисления dec 65 мы получим символ char A.
Этот процесс называется кодировкой символа.


--- Обратная совместимость
Наличие в новой версии компьютерной программы или компьютерного оборудования
интерфейса, присутствующего в старой версии, в результате чего другие программы
(или человек) могут продолжать работать с новой версией без значительной
переделки (или переучивания). Полная обратная совместимость означает, что при
замене старой версии компонента на новую, функционирование всей системы в целом
не нарушится.


--- Deb и Rpm
.deb и .rpm это всего лишь архивы, созданные с помощью утилиты `ar`. Эти архивы
включают в себя файлы программ, исполняемые файлы, библиотеки и т.д.

RPM (Red Hat Package Manager) - менеджер пакетов, используемый в операционных
системах, основанных на Red Hat, это вся ветка дистрибутивов: Fedora, OpenSUSE,
Red Hat, CentOS Red Hat сокращение -> RHEL

Deb (Debian Package Manager) - менеджер пакетов, использует архивы, которые
создаются с помощью `ar`. Для управления .deb пакетами используется dpkg.
Debian / Ubuntu / Mint.

Их иструменты очень похожи.


--- Floppy, CD, DVD, Blu-Ray, CDROM
Информация может храниться не только на жестком диске компьютера, но и на других
альтернативных носителях: CD, DVD, Blu-ray или USB-накопителях.

Floppy   дискета для хранения данных небольшого объема (2,5МБ)

CD       цифровой носитель, стандартный объем 700МБ, пришедший на смену
         floppy-дисков (использовался для музыки)

DVD      схож внешне с CD, но хранит в себе больший объем информации (5ГБ)
         (использовался для фильмов, видео)

Blu-Ray  предназначен для записи видео с высокой четкостью, может хранить в
         себе еще больше чем DVD (22-33ГБ)

CDROM    разновидность дисков с записанными на них данными, доступными только
         для чтения (read-only memory)


--- Дистрибутив
Дистрибутив - это просто согласованный набор программ, который идет с ядром.
А ядро Linux, оно во всех дистрибутивах практически одинаковое. Поэтому
окружение у дистрибутивах разное, например Ubuntu и Debian отличаются,
а в чем-то схожи.


--- Этапы разработки
* Сбор и обработка требований

* Получение технических заданий, планы работ

* Разработка
  - Дизайн
  - Кодирование
  - Тестирование
  - Документирование

* Поддержка
  - Внедрение (Установка ПО, обучение пользователей)
  - Сопровождение (Исправление выявленных ошибок, поддержка пользователей)


--- Android (передача файлов)
Получить права разработчика в телефоне, разрешить отладку через USB.
Подключиться через USB к телефону, выбрать (передача файлов).

Очистка ненужных пакетов:
$ adb shell
$ pm list packages | grep <name>
$ pm uninstall -k --user 0 <name>

Перенести файлы с ПК на телефон:
$ sudo jmtpfs /mnt/

Если копирование файлов осуществляется не на телефон, а на SD-карту, лучше
вставить SD-карту в слот ноутбука и передать файлы напрямую.


--- Таблица разделов MBR vs GPT
Таблица разделов -> Раздел А (отдельно) -> Раздел Б (отдельно)
В каждом разделе есть: Файловая система -> Данные в файле.

Компьютер обычно имеет как минимум один диск для хранения данных. Но физический
диск не может хранить данные без разбивки на разделы. Один физический диск может
содержать один или быть разбит на несколько разделов. Но как создать несколько
разделов? Здесь в дело вступает таблица разделов. Операционная система
обратится к этой таблице для получения данных о разделах.

MBR (Master Boot Record) старый стандарт, BIOS совместимость со старым
оборудованием.

GPT (GUID Partition Table) новый стандарт, более надежно, у каждого раздела свой
UUID, на 32 битной ОС, не получится использовать.


--- Что такое Subshell
Оболочка, это программа, которая позволяет запускать команды в Linux
Подоболочка, это новая оболочка предназначенная только для запуска желаемой
программы. Подоболочка получает все глобальные переменные оболочки (родителя),
экспортированные, но не локальные. Запустить подоболочку в оболочке можно:
$ bash

Например:
bash
 \_ bash script.sh
     \_ sleep 10000000
Сценарий script.sh выполняется в подоболочке (от оболочки bash)


--- Рефакторинг
Это переработка исходного кода программы, чтобы он стал более простым и
понятным. Рефакторинг не меняет поведение программы, не исправляет ошибки и не
добавляет новую функциональность. Он делает код более понятным и удобочитаемым.


--- Цвета тем
Для восприятия более удобны спокойные тона: светло-зеленый, голубой, серый.
В темной комнате лучше использовать темную тему или ночной режим.
Когда светло лучше использовать светлую тему (черный текст на белом фоне).


--- Удаление файлов
Когда пользователь удаляет файл через команду 'rm' или через файловый менеджер
в Linux, сам файл не удаляется полностью. Вместо этого лишь удаляется его запись
в индексе файловой системы, и пространство, которое он занимал, помечается как
доступное для записи. Фактический содержимое файла остается на месте и может
быть легко восстановлено, пока на это место не будет записана новая информация.

Чтобы этого избежать можно перезаписать область памяти нулями или случайными
числами. Но восстановить данные все равно можно будет (профессиональные
криминалисты знают где копать). Чтобы запутать, можно поменять файлам метку
времени.

Лучше использовать `shred`, он перезапишет это место случайными числами
(занятое файлом). И если восстановить файл, то его невозможно будет прочитать.

`shred` эффективен не во всех ФС (AIX, JFS, XFS, Ext3, NFS и подобные).

Важно заметить, что перезапись файлов несколько раз удлиняет интервал удаления
файла, делает этот процесс более медленным.


--- Облачное хранилище
Дает возможность хранить данные в Интернете (на чужих серверах), к которым есть
доступ у клиента 24/7. Поставщик обеспечивает безопасное хранение данных и
обслуживание серверов хранилища, сети и т.д.


--- su vs sudo
su - switch user
Команда su позволяет войти в систему под учетной записью другого пользователя,
предоставляя полный доступ ко всем ресурсам и привилегиям этого пользователя.
При использовании команды `su`, пользователь должен знать пароль от аккаунта,
на который он хочет переключиться.

sudo - superuser do
Позволяет выполнить определенную команду с правами суперпользователя (root), не
выходя из текущей учетной записи. Команда `sudo` требует, чтобы пользователь был
включен в файле настроек `sudoers` и вводил пароль своей учетной записи для
подтверждения действия.


--- passwd vs shadow
`/etc/passwd` хранит информацию о пользователях.
`/etc/shadow` хранит информацию, необходимую для аутентификации пользователей
при входе в систему.

В отличие от `/etc/passwd`, файл `/etc/shadow` доступен только для чтения
суперпользователю (root), чтобы обеспечить безопасность хранения паролей.

Когда создаются новые группы и пользователи файлы `passwd/group/shadow`
изменяются. Обычные пользователи начинаются с 1000, а с UID 1-499 или 1-999
это псевдопользователи и они выполняют системные службы (от их лица), у них нет
оболочки (nologin). А у обычных пользователей есть (bash).

Если вместо `x` поставить hash сумму из shadow, это сработает:
user1:$y$j9T$ICRkTA/TqMwVPxvGJUJ9Y1$A4spI3g11fRL0mqUB34tmzILUCCVSMoagET3cFjcQhD:1002:1002:,,,:/home/user1:/bin/bash

Если убрать `x`, то можно убрать пароль у пользователя:
user1::/home/user:/bin/bash

Раньше хеш-пароля был в `/etc/passwd`, но его решили убрать в отдельный файл
`/etc/shadow`, потому что `/etc/passwd` доступен на чтение всем, а `/etc/shadow`
может читать только root.


--- QEMU
QEMU - это эмулятор и виртуализатор с открытым исходным кодом, который позволяет
запускать гостевые операционные системы и программы, написанные для одной
архитектуры процессора, на другой архитектуре.

QEMU является CLI интерфейсом, управления командами из терминала. Чтобы не
изучать все опции QEMU можно установить `virt-manager`, это GUI интерфейс для
QEMU.

Часто можно заметить такое сокращение qemu-kvm, KVM это модуль ядра Linux,
обеспечивающий доступ к аппаратной виртуализации на базе Intel. QEMU может
работать отдельно от KVM, или вместе (с более высокой скоростью).

Libvirt - это демон/API, в который входят инструменты `virsh` и
`virt-manager`, они нужны для управления QEMU гостевыми. Управляет
виртуализацией QEMU.

Все эти инструменты имеют свободное распространение, являются частью
open-source.

Запускает виртуальную машину с конкретным ядром и initrd, выводит текстовый
интерфейс через сериальную консоль, и использует аппаратное ускорение KVM:
$ qemu-system-x86_64 \
  -kernel build/linux-5.5.11/arch/x86_64/boot/bzImage \
  -initrd build/initramfs.cpio.gz \
  -nographic -append "console=ttyS0" \
  -cpu host \
  -machine q35 \
  -enable-kvm

Создает виртуальный диск:
$ qemu-img create -f qcow2 disk.img 20G

Запускает виртуальную машину, загружая операционную систему с указанного
ISO-образа и предоставляя ей доступ к виртуальному жесткому диску (оперативной
памяти будет 2ГБ):
$ qemu-system-x86_64 -boot d -cdrom os-name.iso -m 2G -hda disk.img


--- Гипервизор
Механизм, который управляет, распределяет ресурсы под виртуальные машины
называется гипервизом. Создает изолированную среду для виртуальных машин, таким
образом виртуальная машина думает, что она настоящая хостовая.


--- Виртуализация и контейнеризация
Виртуализация позволяет запускать несколько операционных систем на одном
физическом сервере, при этом каждая операционная система работает в своем
собственном виртуальном окружении, которое называется виртуальной машиной (VM).
Это достигается за счет использования гипервизора, который управляет доступом
виртуальных машин к физическим ресурсам сервера. Таким образом, виртуализация
обеспечивает полную изоляцию между виртуальными машинами, каждая из которых
имеет свою операционную систему, приложения и настройки.

Контейнеризация, с другой стороны, позволяет запускать приложения в легковесных
контейнерах, которые используют общую операционную систему хоста, но
обеспечивают изоляцию процессов и зависимостей приложения. Контейнеры более
эффективны с точки зрения использования ресурсов и более быстро запускаются,
поскольку не требуют загрузки полной операционной системы, как это делают
виртуальные машины. Это делает контейнеры идеальными для микросервисной
архитектуры и непрерывной интеграции/доставки (CI/CD).

Виртуализация обеспечивает полную изоляцию с виртуальными машинами, в то время
как контейнеризация делит изоляцию на уровне операционной системы.

Виртуальные машины требуют больше ресурсов и времени на запуск, тогда как
контейнеры более легковесны и быстрее запускаются.


--- Поддержка
В контексте операционных систем "поддержка" обычно означает, что разработчики
продолжают предоставлять обновления безопасности, исправления ошибок и иногда
новые функции для данной версии операционной системы.

Когда говорят, что поддержка для определенной версии операционной системы
закончилась, это означает, что производитель перестал предоставлять обновления
для этой версии. Это означает, что безопасность и стабильность операционной
системы могут стать уязвимыми, так как обновления безопасности не будут
выпускаться.

Таким образом, если в CentOS 8 закончилась поддержка, это означает, что не будут
выпускаться обновления безопасности и исправления ошибок для этой версии. В то
время как поддержка для CentOS 7, возможно, продолжается, и обновления будут
выпускаться.

Например, Debian Bullseye имеет стабильный выпуск и имеет поддержку. Обычно
стабильные версии дистрибутивов длятся около 5 лет. Однако это может измениться
в зависимости от решения проекта.


--- FAQ
FAQ - это аббревиатура от английского выражения "Frequently Asked Questions",
что в переводе на русский язык означает "Часто задаваемые вопросы". FAQ
представляет собой список самых часто задаваемых вопросов и ответов на них,
который обычно размещается на веб-сайте или в документации к продукту или
услуге. Это помогает пользователям быстро найти ответы на свои вопросы без
необходимости обращаться к службе поддержки или другим источникам информации.


--- Основы шифрования
Создадутся приватный и публичный ключ:
$ ssh-keygen -t rsa -b 4096 -f fff
-t - type
-b - size of key (сложность ключа)
-f - file name

Лучше использовать `openssl genrsa`, чтобы подходил формат ключа. Например,
нужно сгенерировать ключ для Екатирины, приватный ключ будет лежать у нас,
а публичный у нее. У нее будет свой приватный ключ, а ее публичный ключ будет
у нас (обмен публичными ключами):
$ openssl genrsa -aes256 -out private.pem 4096

Создание публичного ключа:
$ openssl rsa -in private.pem -pubout > public.pem

Отправить публичный ключ:
$ scp public.pem ekaterina@e-machine:/path/

Шифрование файла (использовать нужно публичный ключ Екатерины):
$ openssl rsautl -encrypt -inkey public.pem -pubin -in secret -out top-secret
$ rm secret
$ scp top-secret ekaterina@e-machine:/path/

Для расшифровки этого файла, она должна использовать свой приватный ключ:
$ openssl rsautl -decrypt -inkey private.pem -in top-secret > secret

С помощью чужого публичного ключа - шифрование.
С помощью личного приватного ключа - расшифрование.

`openssl` лучше использовать для своих велосипедов, а `gpg` готовый инструмент
управления ключами.

Симметричное шифрование использует один и тот же ключ и для зашифрования,
и для расшифрования (например, `openssl enc` - с паролем).
$ openssl enc -e -aes256 -in a -out b

Асимметричное шифрование использует два разных ключа: один для зашифрования
(pub) другой для расшифрования (private).

Хранить расшифрованный файл рядом с зашифрованным на диске - опасно.
Злоумышленники могут перехватить расшифрованную версию. Лучше работать с stdout,
памятью.

Сквозное шифрование - это когда отправитель и получатель обмениваются
зашифрованным текстом, и только они могут читать текст сообщения (через ключи).
Шифрование и дешифрование происходит на конечных устройствах пользователей.

AES256 - AES шифрование. Во время шифрования используется специальный ключ,
определяющий стойкость шифра, длиной 128, 192, 256 битов.

Расшифровать в stdout:
$ openssl enc -d -aes256 -pbkdf2 -in a


--- ГОСТ
Это государственный стандарт. Криптографические алгоритмы, разработанные в СССР
и используемые для защиты информации. Они включают в себя алгоритмы шифрования,
хеширования, электронной подписи и другие методы защиты данных. ГОСТ алгоритмы
были широко использованы в России и других странах бывшего Советского Союза, и
многие из них все еще остаются популярными в сфере информационной безопасности.

Если касаться криптографии, то военные не любят пользоваться импортными
методиками, для них лучше ГОСТ шифрование, сертифицированное (криптопро и
подобное).

Некоторые из наиболее известных ГОСТ алгоритмов, которые могут быть использованы
с помощью OpenSSL, включают в себя:
* ГОСТ 28147-89 (Magma)
* ГОСТ Р 34.10-2012 (GOST R 34.10-2012)
* ГОСТ Р 34.11-2012 (GOST R 34.11-2012)

$ openssl ciphers -v | grep GOST
Нужен `openssl` с поддержкой гостов (включить при сборке).


--- foo bar
"Foo" и "bar" - это часто используемые метасинтаксические переменные в
программировании и компьютерной литературе. Они служат для обозначения
абстрактных переменных, функций, или других объектов, когда конкретные имена
не важны или не известны. Использование этих терминов помогает разработчикам
сосредоточиться на структуре и логике кода, а не на именах переменных.

Вот несколько причин, почему "foo" и "bar" так часто используются:

1. Традиция: Эти термины существуют с самого начала эры программирования и
используются в учебниках, документации и примерах кода. Эта традиция
продолжается и по сей день, потому что многие разработчики уже знакомы
с этими терминами.

2. Универсальность: "Foo" и "bar" не несут в себе никакого конкретного значения,
что делает их идеальными для использования в качестве временных имен. Они могут
обозначать что угодно - от переменных и функций до классов и объектов.

3. Легкость в запоминании: Эти короткие и простые слова легко запомнить и
набрать, что делает их удобными для использования в примерах и тестовом коде.

4. Избежание конфликтов: Поскольку "foo" и "bar" не используются в реальных
проектах, они минимизируют вероятность конфликтов с именами переменных, которые
уже могут быть в коде.

История этих метасинтаксических переменных восходит к ранним дням компьютерной
науки и хакерской культуры. Они, вероятно, происходят от военных терминов
"FUBAR" (fouled up beyond all recognition -> испорченный до неузнаваемости),
используемых во время Второй мировой войны, которые потом были адаптированы в
область компьютерных наук.

Вместе с "foo" и "bar" иногда используются и другие похожие термины, такие как
"baz", "qux", "quux" и так далее, особенно когда требуется несколько абстрактных
имен.


--- Мандатная, ролевая и дискреционная модели

В операционных системах, включая Linux, модели контроля доступа определяют, как
пользователи и процессы могут взаимодействовать с системными ресурсами.

1. Мандатная модель (MAC - Mandatory Access Control)

Мандатная модель контроля доступа ограничивает доступ на основе сложных
централизованных политик безопасности. Пользователи и процессы получают доступ к
ресурсам не по своему усмотрению, а в соответствии с политиками, которые
устанавливаются системным администратором или политиками безопасности.

Например, SELinux (Security-Enhanced Linux): Расширение для Linux,
предоставляющее поддержку MAC. Оно позволяет системным администраторам
устанавливать строгие политики безопасности, которые контролируют доступ
пользователей и процессов к файлам и другим ресурсам. Еще пример, это система
Parsec в Astra Linux SE, которая реализовывает MAC политику.

Мандатная модель часто используется в государственных и военных системах,
требующих высокой секретности и строгого контроля доступа.

* Свойства:
- Безопасность управляется на уровне системы, а не на уровне отдельных пользователей.
- Политики устанавливаются администраторами и не могут быть изменены пользователями.
- Высокий уровень безопасности, подходящий для систем, где требуется строгий
  контроль доступа.

2. Ролевая модель (RBAC - Role-Based Access Control)

Ролевая модель контроля доступа предоставляет доступ к ресурсам на основе ролей,
которые назначаются пользователям. Каждая роль имеет определенные права доступа,
и пользователи получают доступ к ресурсам в зависимости от их роли.

Хотя в базовой установке Linux RBAC не является встроенной моделью, она может
быть реализована через различные системы управления доступом и модули, такие как
SELinux или AppArmor, в корпоративных средах.

Ролевая модель используется в корпоративных и крупных организационных системах,
где управление доступом осуществляется на основе ролей сотрудников. Применяется
в системах управления предприятием и базах данных.

* Свойства:
- Упрощает управление доступом в больших организациях, где пользователи могут
  выполнять множество различных функций.
- Изменение доступа осуществляется через изменение ролей, а не прав каждого пользователя.
- Гибкость в управлении, позволяющая быстро адаптироваться к изменениям в организации.

3. Дискреционная модель (DAC - Discretionary Access Control)

Дискреционная модель контроля доступа (стандартная модель в Linux) позволяет
владельцам ресурсов (например, файлов) определять, кто может иметь к ним доступ
и какие операции могут быть выполнены. Владелец ресурса имеет полную свободу в
управлении доступом.

Широко применяется в коммерческих и домашних операционных системах, включая
стандартные установки Linux, где пользователи управляют доступом с помощью
команд, таких как chmod, chown и т.д.

* Свойства:
- Гибкость для пользователей в управлении доступом к своим собственным ресурсам.
- Менее строгая по сравнению с MAC, что может привести к потенциальным
  уязвимостям, если пользователи неаккуратно управляют правами доступа.
- Подходит для систем, где требуется высокая степень индивидуальной настройки доступа.

Заключение:
- Мандатная модель (MAC) применяется там, где необходим строгий контроль и
  централизованное управление доступом.
- Ролевая модель (RBAC) удобна в корпоративных средах, где доступ определяется
  ролями пользователей.
- Дискреционная модель (DAC) обеспечивает гибкость и удобство для пользователей
  в управлении собственными ресурсами и является стандартной в Linux.

Каждая модель имеет свои преимущества и области применения в зависимости от
требований безопасности и управления.


--- X11 vs Wayland
Wayland — это современный протокол, который управляет графическими интерфейсами
в Linux и других Unix-подобных системах. Он предназначен для замены X11,
обеспечивая более простую и эффективную архитектуру для отображения графики,
что потенциально улучшает производительность и безопасность.

Wayland считается более современным и эффективным по сравнению с X11. Он
предлагает:

1. Простоту и легковесность: Wayland имеет более простую архитектуру, что может
   улучшить производительность и снизить задержки.

2. Безопасность: Wayland предоставляет лучшее управление доступом к экранам
   и вводам, что улучшает безопасность.

3. Современные возможности: Wayland лучше поддерживает новые графические
   технологии и аппаратные ускорения.

Однако, X11 более зрелый и поддерживает больше функций, а также совместим с
большим количеством приложений на данный момент. Выбор между ними может зависеть
от конкретных требований и экосистемы, в которой вы работаете.
