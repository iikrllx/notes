Темы:
* Модули
* Библиотечные функции и системные вызовы
* Коды ошибок системной части Linux
* Ввод/вывод и основные системные вызовы
* Именованный канал
* CTRL + D, CTRL + C, CTRL + Z (оболочка)
* FIFO каналы (именованные каналы) - pipes
* Сокеты
* Устройства
* Системный вызов Linux
* Просмотр отчета с помощью strace
* inode
* Файловый дескриптор
* Разница между inode и fd
* Файл
* Файловая система
* Разделы файловой системы (partion)
* EOF
* Разница между FD и FILE
* Метаданные

Важно понимать, что процессы, потоки, файловые системы, сокеты, устройства, каналы, и т.д,
это абстракции ОС.


--- Модули
Модуль - это любой кусок кода, который может быть обработан компилятором
это отдельный исходный файл (source file).


--- Библиотечные функции и системные вызовы
Библиотечные функции - верхний уровень, работает в пространстве пользователя, обеспечивает более
удобный интерфейс к функциям, которые выполняют работу (системным вызовам). То есть библ.функции
обращаются к системным вызовам.

Системные вызовы - работают в привилегированном режиме от имени ядра и предоставляются самим
ядром. Например библиотечная функция printf() формирует строку, в соответствии с заданным форматом,
и передает ее низкоуровневому системному вызову write(), который и выводит строку на устройство
стандартного вывода. Пример можно увидеть в `strace ./printf`.

Цепочка: Программа обращается к библиотечным функциям, находясь в пользовательском режиме.
Затем библиотечная функция обращается к системным вызовам. Системные вызовы уже работают в режиме
привилегированном (являются частью ядра). Затем когда сис.вызов завершает работу, он возвращает
управление библиотечной функции и происходит обратный переход в пользовательский режим.

Unix производит переключение из пространства пользователя в пространство ядра всякий раз, когда
приложение делает системный вызов или приостанавливается аппаратным прерыванием. Например, код
модуля исполняется в пространстве ядра, а обычная программа, исполняется в пространстве пользователя
(прикладное ПО)


--- Коды ошибок системной части Linux
Для этого можно установить moreutils и выполнить команду `errno -ls`
и получить в выводе список кодов ошибок. Вот самые часто встречаемые:

EPERM 1 Operation not permitted - например пользователь пытается
поменять `chmod` файла `/etc/passwd` или `chown`, но выдает ошибку,
потому что владелец файла root, а пользователь операции не root
либо когда делается setuid(0) от обычного пользователя.

ENOENT 2 No such file or directory - например пользователь
передает команде `ls` несуществующий файл.

EACCES 13 Permission denied - например пользователь пытается прочитать
файл, но на это прав не имеет, так как файл имеет такие атрибуты `--wx------`

EOPNOTSUPP 95 Operation not supported - программа не знает, что делать
с этим вызовом. Operation not supported on transport endpoint
Например, нет устройства, как в timer_create не было wakeup в `/sys/class`.


--- Ввод/вывод и основные системные вызовы
open() close() read() write() lseek() pipe()
Программы взаимодействуют с ядром операционной системы посредством специальных механизмов,
называемых системными вызовами. Внешне системные вызовы реализованы в виде обычных
функций языка С, однако каждый раз вызывая такую функцию мы обращаемся к ядру ОС.
Механизм ввода/вывода реализован через файлы (файловый ввод/вывод) FILE*
Когда пишется команда `find / 2>/dev/null` - то у этого процесса файловый
дескриптор 2 начинается ссылаться на `/dev/null` (если посмотреть `ls -l /proc/<pid>/fd`)
Вот такая картина 2 -> /dev/null

ТО ЕСТЬ ПОЛУЧАЕТСЯ ЧТО МЫ УПРАВЛЯЕМ ПОТОКОМ ЧЕРЕЗ ЕГО ДЕСКРИПТОР.
Согласно идеологии UNIX, стандартные потоки можно перенаправлять.
Это позволяет образовывать цепочки программ, связанных посредством каналов.

Функции ввода-вывода при работе с файлом: низкоуровневые (read(), write() и т.д.)
и потоковые (fopen(), fprintf() и т.д).

Поток данных - это открытый файл для ввода/вывода.


--- Именованный канал
Канал межпроцессорного взаимодействия (труба/конвеер) - системный вызов. Именованный канал
(называется еще FIFO - первым пришел, первым обслужен) Это коммуникационное устройство,
одноправленное взаимодействие. Чаще всего используется в shell-скриптах для перенаправления вывода
одной команды (stdout) в ввод другой (stdin), например `ls -al | sort -h`. Конвеер выполняет
асихронное выполнение команд с использованием буферизации ввода/вывода Таким образом каждая команда
это отдельный процесс. Размер этого буфера составляет 64Кб Важно, что несмотря на то, что pipe
оперирует файловыми дескрипторами потоков ввода/вывода, все операции выполняются в памяти, без
нагрузки на диск.

Вся прелесть этого FIFO в том, что несвязанные процессы могут общаться через него и обращаться к
этому файлу.

Например:
$ cat /dev/zero | sleep 1000
У этих двух процессов есть родительский процесс - bash
У первого процесса заменяется stdout дескриптор на дескриптор pipe с помощью dup2
А у второго процесса меняется дескриптор stdin на дескриптор pipe с помощью dup2
И получается что эти два процесса общаются между собой с помощью буфера весом 64Кб
То есть происходит запись в трубу одного процесса и чтение из другого.


--- CTRL + D, CTRL + C, CTRL + Z (оболочка)
Не является сигналом, в отличие от CTRL + C (SIGINT), это EOF символ (закрывает stdin)
Поэтому обработать с помощью signal handler не получится.
А CTRL + Z посылает сигнал SIGTSTP, который останавливает процесс.
CTRL + D можно поймать например так - реализуем посимвольный ввод с помощью getchar()
и данная функция вернет нам -1 в случае CTRL + D (EOF) и можно обработать выход.


--- FIFO именованные каналы (pipe) - очередь
Вот именованный канал: prw-r--r--
Создатеся таким образом `mkfifo fifo`.
И теперь можно поиграться, в первом терминале сделать `cat < fifo`
а во втором `cat > fifo` процесс -> уходит / приходит.
И на практике посмотреть их файловые дескрипторы.


--- Сокеты
Межпроцессорная связь.
Это устройство двунаправленного взаимодействия, которое предназначено для связи с другим процессом,
выполняющимся на этом же или на другом компьютере. Например с помощью `curl` утилиты можно получить
HTML страницу сайта, потому что утилита общается через сокет с веб-сервером. Сокеты работают
наподобие телефонного звонка.

Пространство имен сокета определяет способ записи адресов. Например, в локальном пространстве имен
адреса - это обычные имена файлов. В пространстве имен Internet адрес сокета состоит из IP-адреса
компьютера, подключенного к сети, и номера порта. Благодаря номерам портов можно различать сокеты,
созданные на одном компьютере.

Чтение и запись через сокеты происходит с помощью обычных функций read()/write()
И у сокета будет свой дескриптор.

Бывают локальные сокеты и серверные сокеты, локальное соединение через сокет
происходит через fd - файлы. А серверные сокеты через IP адреса / порты
Сетевые сокеты работают по протоколам TCP/IP

Атрибуты файла сокета выглядят так: srwxrwx--x


--- Устройства
Ядро предоставляет sysfs и udev интерфейсы (файловые системы) для работы с аппаратной частью.
Linux взаимодействует с аппаратными устройствами (клавиатура, мышь, монитор) с помощью модульных
программных компонентов называемых драйверами, которые являются частью ядра. Драйвера недоступны
пользовательским процессам. С помощью файлов устройств происходит взаимодействие с драйверами, и
соответственно с аппаратной частью.

Типы устройств, бывают символьные (ссылка на устройство) и блочные:
1. Символьные выглядят так: crw-rw-rw- null (клавиатура / монитор)
Читают и записывают данные в виде потока байтов. Ссылка является лишь своего рода порталом,
через который происходит взаимодействие с устройством. Есть еще специальные символьные устройства,
а это `/dev/null` и т.д.

Символьные устройства не имеют размера, потому что они не содержат фиксированного объема данных, как
блочные устройства. Вместо этого они передают данные потоком, по одному символу за раз, между ядром
и устройством. Примерами символьных устройств могут быть клавиатура, мышь, принтер, терминал или
последовательный порт. Поскольку они не хранят данные, а лишь передают их, нет необходимости в
определении размера.

Команда `stat` в Linux предоставляет информацию о файлах и файловых системах.
Когда вы используете `stat` на специальном файле блочного устройства (например, `/dev/sda`),
поле размера (Size) часто показывает 0. Это происходит потому, что специальные файлы устройств в `/dev`
не содержат реальных данных, как обычные файлы. Они являются интерфейсами для доступа к устройствам
на более низком уровне и работают как точки входа для системных вызовов.
Размеры блочных устройств можно посмотреть с помощью `fdisk -l`, а не `ls -l` или `stat`.

2. Блочные: brw-rw---- sda (HDD / SSD - диски)
Читают и записывают данные блоками фиксированного размера.

Приложения не работают с блочными устройствами.
Лишь ядро получает доступ к блочному устройству,
а программы обращаются к содержимому диска через обычные файлы и каталоги.

Драйверы блочных устройств имеют прямой доступ к данным, хранящимся на диске. В большинстве
Linux-систем прямой доступ к таким устройствам разрешен лишь процессам, выполняющимся от имени
пользователя root, но и они способны нанести непоправимый ущерб, изменив содержимое диска.
Осуществляя запись в блочное устройство, программа может модифицировать или уничтожить не только
управляющую информацию, хранящуюся в файловой системе, но и таблицу разделов диска и даже главную
загрузочную запись. Вследствие этого жесткий диск или вся система может оказаться разрушенной.

Жесткие диски, дисководы гибких дисков, CD-ROM, флэш-накопители все это примеры блочных устройств.
Доступ к ним осуществляется через файлы блочных устройств и только от лица root

Примеры: Как работать с аппаратными устройствами?
Например у нас есть устройство принтера и нам нужно распечатать документ
Можно сделать так `cat document.txt > /dev/lp0`.
А программными способами, открыть файл с помощью open() на запись и сделать write() в устройство.

Либо вот пример как послать на звуковую плату аудиоданные:
$ cat /usr/share/sndconfig/sample.au > /dev/audio


--- Системный вызов Linux
Это вызовы функций, совершаемые из пользовательского пространства в пространство ядра.
Смысл системного вызова, запросить у ОС определенную службу или ресурс.

Библиотечная функция - это обычная функция, которая принимает на вход аргумент (не всегда)
находится во внешней библиотеке, подключаемой к программе (libc)

Системный вызов - аргументы вызова упаковываются и передаются ядру, которое берет
на себя управление программой, пока вызов не завершится. В качестве вызовов можно
рассматривать такие низкоуровневые функции как open(), read() и другие.

Некоторые системные вызовы оказывают очень большое влияние на ОС. Есть вызовы, которые
могут завершить работу системы, выделить ресурсы или запретить другим пользователям
доступ к ресурсам. Программы которые имеют такие привилегированные вызовы, требуют
права суперпользователя.

Другими словами - Обращение прикладной программы к ядру ОС для выполнения какой-либо операции.
Вызов функции в ядре системы. В Си есть функция syscall, позволяющая непосредственно
выполнять системные вызовы. Из user space отправляются системные вызовы через обертку libc
printf() эта функция обертка (user space code), которая делает
системный вызов sys_write (kernel space code)

Например, пользователь вызвал команду `ls` в терминале:
Утилита командной строки -> Функции системных библиотек (libc) -> Системные вызовы

Системные вызовы - это способ для программы обратиться к операционной системе с просьбой выполнить
какое-то действие, которое программа сама выполнять не может из-за ограничений прав доступа. Когда
программа хочет сделать системный вызов, она помещает данные в регистры процессора (это как
специальные ячейки памяти внутри процессора), которые сообщают операционной системе, что именно
нужно сделать. Затем программа выполняет специальную команду процессора, которая переносит
исполнение программы в ядро операционной системы.

На процессорах Intel это делается с помощью прерывания с номером 0x80 или более современная версия
syscall. Происходит передача управления из userspace в kernelspace, процессор начинает работать в
kernelspace. Прерывание - это сигнал процессору остановить текущую задачу и выполнить другую, в
данном случае - обработку системного вызова. Когда прерывание происходит, процессор переключается из
пользовательского режима (в котором работают обычные программы) в режим ядра (в котором работает
операционная система) и начинает исполнение кода ядра, который обрабатывает системный вызов.

Таким образом, программа может попросить операционную систему сделать что-то, что требует повышенных
привилегий (например, запись в системный файл или управление аппаратными устройствами), и
операционная система может это выполнить от имени программы, при этом сохраняя контроль над тем, что
именно программа может делать.

sys_call_table в Linux - это таблица системных вызовов. Это специальная структура данных в ядре
операционной системы, которая содержит адреса функций (ядра), обрабатывающих системные вызовы.

Каждый системный вызов имеет свой уникальный номер, и когда пользовательская программа хочет
выполнить системный вызов, она использует этот номер для обращения к соответствующей функции в
sys_call_table. Таким образом, таблица системных вызовов служит своего рода "списком контактов"
для ядра, позволяя ему быстро находить и вызывать нужные функции для обработки запросов от
пользовательских программ.

Вот как это происходит:

1. Пользовательская программа выполняет системный вызов, используя соответствующую инструкцию и
передавая идентификатор системного вызова (например, номер операции).

2. Процессор переходит в привилегированный режим и начинает выполнение кода ядра.

3. Ядро использует идентификатор системного вызова для поиска адреса соответствующей функции
обработчика в sys_call_table.

4. Функция обработчика системного вызова выполняется в пространстве ядра.

5. После выполнения обработчика управление возвращается в пользовательскую программу,
и процессор переходит обратно в непривилегированный пользовательский режим.


--- Просмотр отчета с помощью strace
Команда `strace` отслеживает выполнение программы.
Каждая строка в выводе соответствует одному системному вызову.

Например: $ strace cat /dev/null
1 строка отражает принцип создания процесса, то есть текущий процесс (родитель)
создает дочерний процесс с помощью fork() и strace работает уже с дочерним проц.
который является `/usr/bin/cat /dev/null`, обычно это execve(), за которым следует brk()
вызов инициализации памяти, важно обратить на "= 0", это означает что системный вызов вернул 0,
а не ошибку.

Следующие 30 строк отражают механизм загрузки стандартной библиотеки языка С из
библиотечного файла, и других разделяемых библиотек (происходит их загрузка).

Затем самое нужное начинается с вызова openat() файла `/dev/null`, который возвращает
файловый дескриптор 3, то есть у процесса cat 3 файловый дескриптор будет смотреть в `/dev/null`
и через этот fd будет общение с файлом, затем происходит чтение файла, и когда читать
уже нечего, процесс закрывает все fd и делает выход с помощью exit_group().

Всегда стоит обращаться к `man` в случае непонятного вывода, `man 2 openat`.
В выводе очень много различных системных вызовов и все они считаются вспомогательными
действиями для запуска процесса, инициализация, очистка процесса, памяти и т.д.


--- inode
Индексный дескриптор файлов или каталогов (на диске). Это структура данных, содержит информацию
о файле (такую как: размер файла, id пользователя, группы, права, временные метки и т.д)
inode не содержит имя файла, только его идентификатор.

Кол-во inode имеет фиксированный размер, он разный в зависимости от ФС.
Имя файла ссылается на inode (который содержит метаданные об этом файле)
Увидеть эти метаданные можно `stat /home` или `ls -i` или `df -i1`.
Когда создается файл, ему присваивается имя файла и индекс (inode).
Бывает такое, что у пользователя есть место на жёстком диске, но не хватает
для этого inode, тогда создать файл не получится.

Каталоги содержат список названий файлов, с каждым из которых связан номер индексного дескриптора.
Каждое имя называется записью в каталоге, а каждая связь имени и номера индексного дескриптора
именуется ссылкой.


--- Файловый дескриптор
Дескриптор файла аналогичен файловому указателю. Идентифицирует файл, указывает на ОТКРЫТЫЙ файл,
отображает метаданные, ассоциированные с открытым файлом, соответствует типу (int)

Значительная часть системного программирования сводится к управлению файловыми дескрипторами,
открытие / закрытие и т.д. Файловые дескрипторы начинаются с 0 и заканчиваются цифрой 1024, но при
необходимости эту цифру можно повысить.

Библиотека Си не ссылается непосредственно на целые числа 0,1,2
А предоставляет препроцессорные определения STDIN_FILENO, STDOUT_FILENO
и STDERR_FILENO. Это уже предопределенные файловые дескрипторы:
#define STDIN_FILENO 0  (чтение)
#define STDOUT_FILENO 1 (запись)
#define STDERR_FILENO 2

Дескрипторы могут ссылаться не только на обычные файлы, но и на файлы
устройств, каталоги, FIFO, сокеты и т.д.
Это соответствует парадигме: "ВСЕ ЕСТЬ ФАЙЛ".

В user space дескриптор представляется как обычное число.
В kernel space как структура.

struct file {
  struct path f_path;
  struct inode *f_inode;
  ...
}


--- Разница между inode и fd
Важно понимать разницу между индексным дескриптором и файловым дескриптором,
разница несущественная, ибо два этих определения связанны с понятием "Файл".

Индексный дескриптор это структура файловой системы, представляющая файл в то время файловый
дескриптор, это целое число, возвращаемое системным вызовом open. Ядро пользуется отображанием
индексных дескрипторов в файлы. То есть когда из user space прилетает запрос на открытие файла,
ядро по имени файла получает его индексный дескриптор.


--- Файл
Файл является самой фундаментальной абстракцией системы UNIX, следующая по важности идет ПРОЦЕСС.

Содержит байты данных, организованные в виде линейного массива, который называется потоком байтов,
любые байты внутри файла могут использоваться для считывания или записи, эти операции всегда
начинаются с указанного байта, который можно назвать местоположением в файле (файловая позиция или
смещение). Это указатель внутри открытого файла, который отслеживает текущее местоположение, с
которого будет происходить следующая операция чтения или записи. Это позволяет операционной системе
продолжить работу с файлом с того места, на котором она остановилась в предыдущий раз. Это важнейший
элемент метаданных, который ядро ассоциирует с каждым открытием файла. Когда файл открывается
впервые, его позиция равна нулю.

Файл - это способ хранения информации вне памяти компьютера.

Так же есть термин "усечение" файла, которое позволяет урезать файл до определенной длины байт, этим
занимаются сис.вызовы truncate().


--- Файловая система
Это набор файлов и каталогов разной иерархии. Файловые системы можно по отдельности добавлять к
глобальному пространству имен и удалять их из этого глобального пространства файлов и каталогов.
Данная операция называется монтированием и размонтированием. Каждая файловая система может быть
индивидуально монтирована к конкретной точке пространства имен. Она обычно называется точкой
монтирования.

Файловые системы обычно существуют на диске, хотя есть и виртуальные файловые системы по типа proc,
которые находятся в оперативной памяти ПК или сетевые файловые системы.

Файловая система это не аппаратура, она не вшита в железо, она независима от неё.
Что связывает файловую систему и аппаратуру?
Как через ФС удается записать данные на диск?
(Благодаря "Драйверу устройств")

1. Файловые системы на диске (находятся на блочных устройствах)
2. Виртуальные файловые системы (находятся в памяти)
3. Сетевые файловые системы

Диск делится на разделы, а в Windows на диски.
Чтобы на каждом разделе можно было работать с файлами и каталогами,
необходима определенная файловая система, например:
NTFS, FAT32, Ext4 (Extended Filesystem), Swap

Формат хранения данных, либо виды ФС:
iso9660  файл iso, это фс только для чтения, при монтировании iso, можно заметить ro
NTFS     ФС для семейства ОС Microsoft Windows
FAT32    основана на Fat16, до сих пор используется для форматирования USB
Ext2/3   прошлые версии Ext4
Ext4     журналируемая ФС, используемая в ОС на ядре Linux
Swap     раздел жесткого диска, предназначен для виртуальной памяти
tmpfs    временное файловое хранилище, размещается в ОЗУ вместо физ.диска (вирт.фс)
         обычно монтируется в `/run` или `/tmp`
procfs   позволяет получить доступ к информации из ядра о системных процессах (нужна для ps,top)
         обычно монтируется в `/proc` (вирт.фс)
sysfs    позволяет получить доступ об ядре, модулях в ОС, драйверах
         обычно монтируется в `/sys` (вирт.фс)

Эти виды отличаются: методами хранения метаданных, обработки файлов, хранением файлов, хранение имен
файлов, права доступа к этим файлам и т.д, это их отличает друг от друга.

$ cat /proc/filesystems
вывод всех файловых систем в ядре


--- Разделы файловой системы (partion)
Например:
Корневой раздел (/)
Раздел виртуальной памяти (swap)
Раздел домашнего каталога (home/)

На одном устройстве может быть несколько разделов, то есть на одном физическом диске можно хранить
информацию в разных файловых системах. Это полезно, когда мы хотим допустим на одном диске хранить
несколько ОС.

Если оперативная память на исходе, система виртуальной памяти Linux может автоматически перемещать
фрагменты памяти на дисковое хранилище и обратно. Этот процесс называется подкачкой. Для swap можно
даже за(dd)ешить обычный текстовой файл и указать его в роли подкачки.

Раздел может быть либо первичным, либо логическим:
* Первичный - используют для запуска операционной системы.
На этом разделе хранится наше ОС, в Linux это корень, а в Windows это диск С.
Эти разделы должны быть основными
* Логический - невозможно запустить ОС, предназначен для хранения
информации пользователя, в Linux это `/home`, а в Windows допустим диск D
Больше 10 логических разделов не создать

Вообще можно ограничитсья только "root" и "swap" разделами, остальные (`/home`, `/boot` и другие)
будут храниться в "root".


--- EOF
Макрос, который возвращается функциями при конце файла. end-of-file, конец файла, не считается
ошибкой, означает что файловая позиция превысила последнее допустимое значение в файле и читать
больше нечего.


--- Разница между FD и FILE
Файловый дескриптор - это низкоуровневый целочисленный дескриптор, используемый для идентификации
открытого файла на уровне ядра в Linux, а указатель FILE - это конструкция уровня стандартной
библ.Си, используемая для представления файла.

FILE оборачивает дескриптор файла и добавляет буферизацию и другие функции, облегчающие ввод -
вывод. FILE открывается в буферизированном режиме по умолчанию. Это означает, что данные будут
записываться в буфер и передаваться на диск ТОЛЬКО при достижении определенного размера буфера или
при явном вызове функции fflush(). Это позволяет снизить количество обращений к физическому
устройству и улучшить производительность.

FILE данный указатель называется указатель файла, ссылается на структуру, содержащую информацию о
файле (адрес буфера, положение текущего символа в буфере, открыт файл на чтение или на запись, были
ли ошибки при работе с файлом и не встретился ли конец файла)

(Это описание касается так же open() fopen() ... read() fread()) open() это системный вызов,
а fopen() библиотечная функция. fopen() и подобные - более переносимы, чем системный вызов open().
open() -> Данные передаются непосредственно между файлом и физическим устройством без промежуточного
хранения в буфере.

В сравнении с FD, которая обеспечивает не буферизированный IO, использование FILE может значительно
увеличить производительность операций чтения и записи, особенно при работе с большими объемами
данных.

Однако, буферизация может привести к потере данных в случае аварийного завершения программы до
явного вызова функции fflush() или закрытия файла.


--- Метаданные
For example: inode: file name; owner; size; type of file; date and time it was created;
GPS coordinates of where it was created; copyright information; and data lineage.

Большие объемы метаданных лежат в DB (`mysql` и подобные) Метаданные могут быть извлечены из цифровых
активов для внешнего использования. Для поиска метаданных используются специальные инструменты,
поисковики и сборщики метаданных. Так называемые трекеры, которые отслеживают активность.
