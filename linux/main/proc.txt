Темы:
* Что такое процесс
* Как рождаются процессы
* Планировщик процессов
* Работоспособный процесс
* Квант времени
* Бинарные модули и процессы
* Какие процессы бывают
* Что такое потоки (threads)
* Приоритет процесса
* Сигналы
* Файловая система /proc
* Как отслеживать процессы
* Что такое демоны и Systemd
* Управление процессами и ресурсами
* Синхронность и асинхронность процесса
* Адресное пространство процесса
* Прерывания (CPU)
* IPC
* Что будет если закрыть терминал с дочерними процессами
* Гонка обращения к файлам и блокировка
* pthreads
* Dbus (Desktop Bus)

Пользовательские процессы изолированы друг от друга и умирая не тянут за собой
всю систему.


--- Что такое процесс
Это программа, выполняющаяся в оперативной памяти компьютера (запущенная
программа). В любой многозадачной операционной системе может запущено много
программ (процессов), но они запускаются не одновременно, а выполняются в
определенный момент времени, выполняется только один процесс. Планировщик
выделяет каждому процессу небольшой квант времени и по истечению этого кванта
передает управление следующему процессу. Кванты времени, выделяемые процессу,
так малы, что у пользователя создается иллюзия одновременного выполнения многих
процессов. Когда у процесса истекло время, ЦП переходит к другому процессу и
делает снимок состояния прошлого процесса чтобы сохранить его действия, затем
когда он возвращается, то уже работает с тем что было сделано. Такая возможность
известна под названием многозадачность.

Процессы в большинстве своем - однопоточные, но так же бывают и многопоточные
процессы то есть одновременно выполняется несколько действий в процессе.
Поток - это единица активности в процессе. У каждого процесса есть свой
идентификатор (pid)

Пользовательские процессы изолированы от физической памяти, они не знают сколько
у нас действительно ОЗУ и по каким адресам она находится.


--- Как рождаются процессы
Если ядру не удалось запустить ни один процесс из init `/sbin/init` или
`/etc/init` и другие, то ядро переходит в состояние паники. Новые процессы
создаются методом клонирования какого-то уже существующего процесса, порожденный
процесс наследует все открытые файлы родительского процесса. Каждый процесс
порожден другим процессом (родительским). Каждый дочерний процесс имеет все
данные процесса-родителя. Ядро создает дочерний процесс путем изготовления
дубликата родительского процесса.

Дочерний процесс наследует копии родительских сегментов данных, стека и кучи,
которые затем могут изменяться независимо от своих родительских копий. Так же
наследует все переменные окружения родителя, открытые файловые дескрипторы
родителя, привилегии, приоритет выполнения (nice) и многое другое, эти моменты
можно ограничить fcntl(). Важно отметить, что все блокировки, которые были
установлены родителем (на дескрипторы) так же передаются дочернему процессу.

Однако, благодаря технике copy-on-write, фактическое копирование сегментов
памяти происходит только при попытке записи. Это позволяет снизить накладные
расходы на копирование и повысить эффективность работы системы.

Если используется execve и подобные, тогда принципы наследования не срабатывают.
Происходит как бы выполнение совершенно новой программы.

Когда система стартует, вначале запускается ядро, которое тоже представляет
собой процесс PID (0), затем в конце инициализации ядра порождается процесс init
PID (1). init - монтирование корневой файловой системы. После чего init ищет
другие файлы и запускает дерево процессов и т.д.

В системе не может быть процессов с одинаковыми PID. Ядро может поддерживать
таймеры процесса, позволяющие посылать процессу сигналы об истечении
установленных временных интервалов. Система защищает собственное пространство от
доступа прикладных процессов и они общаются вызовами. Процессы изолированны
друг от друга, но они могут общаться через сигналы, каналы, это называется
межпроцессорное взаимодействие. Процессы независимы от друг друга и выполняются
асинхронно (одновременно) поэтому нельзя заранее сказать кто раньше закончится,
но бывают моменты когда родитель ждет своих потомков.

Зомби - если родитель не дожидается своего потомка и потомок завершился и не
сообщил об этом своему родителю, то тогда потомок становится <defunct> процессом
(зомби), именно поэтому нужен вызов wait(), ибо потомок будет занимать ресурсы
ПК, номер pid и другое. А если процесс занимает номер pid, этот номер не смогут
занимать другие процессы, а если процессов зомби очень много, то может быть
достигнут лимит и не родится ни один процесс (fork бомба). Зомби процесс
находится в ущербном состоянии, у него закрыты все fd, освобождена память,
просто pid занимает и хранит exit статус, который хочет сообщить родителю,
поэтому wait() служит для того чтобы "прибить" потомка, получить exit статус
и убить.

Вот пример зомби процесса:
switch (child = fork()) {
	case -1:
		abort();
	case 0:
		exit(0);
	default:
		sleep(50);
}

Каждый процесс принадлежит определенному пользователю и группе. Эти
принадлежности используются для управления правами доступа к ресурсам.
С точки зрения ядра, пользователь и группа, это просто целочисленные величины.
Они хранятся в `/etc/passwd` и `/etc/group`.

Когда процесс завершает свою работу (например exit), то ядро сообщает родителю о
завершении потомка (посылает SIGCHLD родителю) Классический способ прекратить
работу программы - не использование явного системного вызова, а простое
"достижение конечной точки" программы.

Каждый процесс является членом группы процессов, которая представляет собой
коллекцию из одного или нескольких процессов. Основная особенность группы
процессов заключается в том, что эти сигналы могут быть отправлены ВСЕМ
процессам в группе: одно действие может прервать, остановить или продолжить все
процессы в этой группе. Каждая группа процессов идентифицируется с помощью
идентификатора группы процессов, а также имеет лидера группы процессов.
Идентификатор группы процессов равен pid лидера группы процессов. Группы
существуют, пока в них остается хотя бы один член. Даже если лидер группы
процессов прерывается, группа продолжает существовать. Группы процессов
предоставляют механизм для упрощения адресации сигналов всем членам группы,
выполнение контроля. Например, когда пользователь покидает терминал, то SIGQUIT
отправляется всем процессам в группе терминала. Когда пользователь нажимает
CTRL+C, то SIGINT посылается всем процессам в группе. Допустим пользователь
зашел в оболочку bash (pid 1700) в этой группе bash единственный член и лидер
этой сессии, новые команды, которые пользователь запустит в этой оболочке, будут
работать в этой группе внутри сессии с идентификатором 1700 Например, команда
`cat file.txt | grep a | grep b` вернет группу процессов, включающую три
процесса Таким образом, оболочка может отправлять сигналы трем процессам
одновременно.

Все процессы рождаются благодаря вызову fork(), создается копия процесса
родителя под названием потомок, начиная с init. Дочерний процесс продолжает
работу родительского.


--- Планировщик процессов (scheduler)
Подсистема ядра (НЕ systemd), которая разделяет ограниченное значение ресурса
времени процессора между системными процессами. Это компонент ядра,
обеспечивающий выбор процесса, который будет выполняться следующим. Принимая
решение, какие процессоры могут быть запущены и когда, планировщик отвечает за
максимизацю использования процессора одновременно с обеспечением видимости, что
несколько процессов выполняются одновременно, не мешая друг другу.

Планировщик процессов использует различные алгоритмы для распределения
процессорного времени между процессами, чтобы обеспечить максимально эффективное
использование ресурсов системы и справедливое распределение времени между
процессами. Также он учитывает приоритеты процессов, их состояние
(готовность, ожидание ввода-вывода и т.д.), а также возможность многозадачности
и многопоточности.

Решение о том, какие процессы запустить, когда и на какой период времени,
- основная ответственность планировщика процессов.


--- Работоспособный процесс
Если он не заблокирон, он является работоспособным. Заблокированный процесс
является спящим, ожидающий ввода-вывода из ядра. Процессы, взаимодействующие с
пользователями, считывающие или записывающие большие файлы либо реагирующие на
события из сети, скорее всего, будут проводить довольно много времени в
заблокированном состоянии, ожидая ресурсов, позволяющих им снова начать работу.
Следовательно в это время они не являются работоспособными.


--- Квант времени
Квант времени, который планировщик выделяет каждому процессу, является очень
важной величиной с точки зрения общего поведения и производительности системы.
Если квант слишком велик, процессы должны ждать долгое время между периодами
выполнения, минимизируя видимость одновременной работы. Пользователей могут
раздражать заметные задержки. И наоборот, если квант времени слишком мал,
значительная доля системного времени тратится на переключение между разными
приложениями, из-за чего выгода сосредоточенности на времени пропадает.

Процессы, которые последовательно расходуют все доступные им временные кванты,
считаются ограниченными. Они активно тратят ресурсы времени и отрабатывают все,
что выделит им планировщик. Например:
while (1) { }

Процессы, которые с более низким приоритетом просто приходится подождать, пока
высокоприоритетные исчерпывают свой временный квант и заблокируются. Принцип
UNIX: все процессы должны постепенно выполняться.


--- Бинарные модули и процессы
Бинарные модули - это программы, находящиеся в пассивном состоянии в хранилище и
скомпилирванные в формате, приемлемом для данной ОС и машинной архитектуры,
готовые к запуску, но пока бездействующие.

Процессы - это абстракции ОС, представляющие собой данные модули в действии,
загруженный двоичный код, виртуальная память, ресурсы ядра, такие как открытые
файлы, связанный пользователь и т.д. Иными словами, процессы - это выполняющиеся
бинарные модули.


--- Какие процессы бывают
* Пользовательские процессы (запускаются в режиме пользователя, ограниченные ресурсы)
* Процессы ядра (запускаются в режиме ядра, привилегированные процессы)
* Демоны (работают в фоне)


--- Что такое потоки (threads)
Поток - это одно из действий внутри процесса. Каждый поток имеет собственный
виртуализированный процессор, включающий в себя стек, состояние процессора,
например регистры, а также командные указатели. Если в процессе поток только
один, то процесс и является потоком.

Большинство процессов содержат всего один программный поток. Тем не менее
процессы могут включать в себя и множество программных потоков, в каждом из
которых выполняется своя задача. Такой процесс называется многопоточным.
Многопоточный процесс можно представить как совокупность мелких процессов,
делающих общее адресное пространство. В многопроцессорной системе два и более
программных потока, относящихся к одному процессу, могут даже работать
параллельно.

Программные потоки могут перезаписывать совместно используемые данные, если
разработчик специально не организует синхронизацию доступа к данным (такая
практика называется блокировкой). Блокировка нужна, чтобы разные программные
потоки не наступали друг другу на пятки. В результате гарантируется, что
отдельные программные потоки, относящиеся к одному процессу, могут выполнять
параллельные вызовы стандартного ввода-вывода - даже по отношению к одному и
тому же потоку данных! При этом параллельные операции нисколько не мешают друг
другу.

Если мы попытаемся сделать параллельную работу нескольких процессов, которые
общаются между собой и передают какие то данные, это будет довольно сложно.
Мы не сможем напрямую у другого процесса прочитать память или вызвать функцию,
лезть в чужую память не получиться (ибо у каждого процесса свое адресное
пространство закрытое, разные адреса). Чтобы решить эту задачу, лучше
использовать потоки, у них одно адресное пространство (.stack, .heap и остальные
секции). Поток вызывают напрямую функцию из другого потока, читают память друг
друга. Но все же процесс и поток в Linux это одно и то же. У каждого потока есть
pid и tid

Пример многопоточного приложения: графические приложение. Первый поток
обслуживает frontend, второй обслуживает backend задачи, если такая программа
будет работать в одном потоке, то всё зависнит (когда мы нажмем какую нибудь
кнопку).

Потоки внутри одного процесса могут более эффективно обмениваться данными,
так как они находятся в одном и том же адресном пространстве. Потоки обычно
используются для реализации параллельной обработки внутри одного процесса.


--- Приоритет процесса
Устанавливается в момент рождения, и учитывается планировщиком процессов при
выделении процессам времени центрального процессора. Получает значение nice +20
(наименьший приоритет, выполняется когда процессор ничем не занят) -20
(наивысший приоритет). Каждому процессу, кроме демонов ставится TTY.

Linux гарантирует, что каждый процесс получит свой кусочек пирога под названием
процессор (вычислительная мощь) Ни один процесс не окажется полносьтью лишенным
доступа к процессору, можно сообщить системе, что процессор не очень важен и
поставить его фактор уступчивости под +20, а отрицательная уступчивость гласит
о том, что процесс выполняется намного дольше (больше времени на выполнение).
Только программа с привилегиями пользователя root может запускать процессы с
отрицательным фактором уступчивости или понижать это значение у выполняющегося
процесса. Это означает, что вызывать команды nice и renice с отрицательными
аргументами можно, лишь войдя в систему как пользователь root, и только процесс,
выполняемый от имени суперпользователя, может передавать функции nice()
отрицательное значение. Таким образом, обычные пользователи не могут помешать
работать процессам других пользователей и монополизировать системные ресурсы.


--- Сигналы
Это средство, с помощью которого процессам можно передавать сообщения о
некоторых событиях в системе, с помощью сигналов можно остановить, завершить
процесс и т.д. Когда мы нажимаем комбинацию CTRL+C мы посылаем сигнал завершения
процесса и дочерний процесс посылает родительскому сигналу о завершении. Сами
процессы тоже могут генерировать сигналы с помощью которых они передают ядру и
другим процессам информацию. Все имена начинаются на SIG Например, когда процесс
превышает свою временную квоту, ему отправляется соответсвующий сигнал. Сигналы
являются асинхронными, то есть когда процесс получает сигнал, он его
незамедлительно обрабатывает, прерывая текущий код программы, в Linux сигналы
обозначаются символическими константами. Поскольку сигнал может прийти в любой
момент, он способен застать программу "врасплох" за выполнением критической
операции, не подразумевающей прерывание. Такой операцией, к примеру, является
обработка предыдущего сигнала. Поэтому не стоит осуществлять операции
ввода/вывода и т.д в обработчике. Обработчик должен выполнять минимум действий
в ответ на получение сигнала и как можно быстрее возвращать управление в программу.

* Системные сигналы
* Сигналы устройств
* Пользовательские сигналы

Сигнал - это сообщение, уведомляющее процесс о том, что событие определенного
типа произошло в системе Например, SIGINT, SIGKILL, SIGSEGV и другие.
Отправляется ядром или другим процессом. То есть тип сигнала определяется
целочисленной константой (1-30). Передается только факт возникновения сигнала и
его номер.

Ядро может игнорировать обработчики таких сигналов как SIGKILL и SIGSTOP. Ибо
программист, мог бы сделать процесс бессмертным.


--- Файловая система /proc
Чтобы управлять системой, ядро должно следить за каждым запущенным процессом,
включая себя. Информация о процессах должна быть доступна для многих
пользовательских приложений (top, ps). Для этого существует псевдо-файловая
система процессов - `/proc` она используется для получении информации о
запущенных процессах. Не находится на диске, а существует в памяти ядра.
Каждый каталог соответствует PID процесса. Каталоги появляются и исчезают
динамически по мере запуска и завершения процессов.

Содержимое таких файлов генерируется ядром динамически в процессе чтения из
файла. Размер файлов равен нулю. Поскольку содержимое файла создается ядром "на
лету", понятие размера файла здесь неприменимо. Соответственно время модификации
файла равно времени запуска команды.


--- Как отслеживать процессы
Как работают процессы? В момент запуска ядро реализует несколько своих задач,
которые запускают программу с названием init и это программа выполняет
последовательность программ (начальные загрузки) > `/etc`, которые запускают все
системные службы и многие из этих служб реализованы как программы-демоны.

Файл init имеет id 1 всегда, не завершает свою работу - он постоянно находится в
памяти и отслеживает выполнение других процессов.

Принцип запуска: родительский процесс запускает дочерний процесс.

ps - список процессов
PID  - это ID процесса
PPID - это ID родительского процесса
TTY  - терминал

# выводит все процессы, очень удобно использовать вместе с `-o`
$ ps -e

# выводит все процессы, принадлежащие всем пользователям
$ ps -axu

# выводит дерево
$ ps -axuf

# вывод конкретной информации
$ ps -o tty,pid,ppid,cmd

# пример конкретного процесса
$ ps -o tty $(pidof vim)

# все процессы с определенной меткой
$ ps -eo cmd

# означает на отсутствие управляющего терминала (демоны)
TTY ?

$ pstree -p <pid>         # дерево
$ ps -p <pid> -o ppid     # процесс родитель
$ ps -C <name> -o pid     # текущий pid
$ pidof vim               # можно отследить pid процесса по имени
                          # или так `ps -C vim`
$ pkill -u <user>         # убить все процессы пользователя

Для того чтобы узнать действующий идентификатор пользователя у процесса. Можно
прописать $ ps -u root тем самым мы узнаем все привилегированные процессы.

STAT (state) состояние
R - выполняется или готов к выполнению (run)
S - приостановлен, временно не выполняется, находится в ожидании операций ввода-вывода(sleep)
s - лидер сессии
T - процесс принудительно остановлен
Z - недействующий процесс-зомби, дочерний процесс, который завершился, но не был удален
    родителем. мертвый процесс, который следует удалить
< - высокоприоритетный процесс, потребляют больше ресурсов
I - простаивает, ожидает чего-то
L - ?
D - процесс ожидает определенного сигнала, находится в состоянии непрерываемого состояния

PR - приоритет задачи в расписании. Если в этом поле есть rt, это означает, что
задача запущена в расписании приоритетов в реальном времени (это самый высокий
приоритет). Это поле показывает приоритет планирования процесса с точки зрения
ядра. Это реальный приоритет, которое ядро выбирает самостоятельно.

NI - значение nice задачи, негативное -20, означает более высокий приоритет, а
положительное - низкое. Это значение влияет на приоритет процесса и складывается
с PR. Значение NI может интерпретировано как подсказка для ядра о том, какой
приоритет должен иметь процесс, но ядро может выбрать реальный приоритет (PR)
самостоятельно, в зависимости от ситуации, но обычно используется формула
PR = 20 + NI

VIRT - общее количество используемой задачей виртуальной памяти, все коды,
данные, совместные библиотеки и т.д.

top - позволяет вывести процессы в динамике, обновляет информацию каждые 3
секунды load average (средняя нагрузка), первое значение отражает среднюю
нагрузку за посл. 60 секунд, второе - за последние 5 минут, и третье за
последние 15 минут, значение ниже 1.0 сообщает, что системе не нагружена. Важно
понимать что процессы, которые спят и тупо ожидают ввода с клавиатуры или мышки
не влияют на это значение. Процессы, которые реально что-то выполняют влияют на
это значение.

Tasks: суммарное число процессов в разных состояних
Mem: объем использования ОЗУ
Swap: подкачка, виртуальная память

$ top -d 1                # обновлять каждую секунду
$ top -p $(pidof vim)     # анализ процесса

Горячие клавиши top
M - отсортировать по памяти
P - отсортировать по ЦПУ
u - отсортировать по пользователю
V - показывает дерево процессов или F5

htop - улучшенная версия `top`, в которой больше информации


--- Что такое демоны и systemd
systemd - это главный демон, управляет работой служб вплоть до их выключения.

Демон - это фоновый процесс, который не привязан к терминалу, это нужно для
представления возможности выполнять другую работу на переднем фоне, длительное
время пребывает в таблице процессов. Обычно демон активизируется по запросу
(событию).

Демоны отличаются от обычных процессов только тем, что они работают в
неинтерактивном режиме. То есть неприсвоенны к определенному терминалу.

Процесс init является родительским, то есть все другие процессы являются
потомками. Принято оканчивать имена доменов на букву `d`, например (sshd, httpd).

Процесс init запускает демонов, создавая свои ответвления для запуска новых
процессов. Получив команду, они выполняют действие, для которого были созданы,
а все остальное время находится в ожидании.

systemd продвинутая система управления службами, разрешение зависимостей,
параллельный запуск, отсрочка запуска и перезапуск при ошибке, на этапе
инициализации системы.

systemd управляет не только процессами и службами, но способна так же
монтировать ФС, отслеживать таймеры, сетевые сокеты и т.д.
Существуют различные типы модулей, которые описаны в `man systemd`
и чуть ниже (.target, .service, .socket, .automount и многие другие) это то,
чем занимается systemd.

Например, модули монтирования осуществляют контроль присоединения ризличных
файловых систем. Работа systemd начинается с default.target, который объединяет
несколько юнитов служб и монтирования в качестве зависимостей. При активации
этого юнита все юниты под ним также активируются.

Например:
default.target -> multi-user.target -> basic.target -> \
 crond.service -> syslog.service -> iptables.service

* Юниты служб (service units). Управляют служебными демонами, найденными в
  системе Unix.

* Целевые юниты (target units). Управляют другими юнитами, группирует их.

* Сокет-юниты (socket units). Представляют местоположения запросов на входящее
  сетевое подключение.

* Юниты монтирования (mount units). Контролируют присоединение файловых систем с
  системой.

Утилита systemctl нужна для управления планировщиков задач systemd.
$ systemctl                      # выводит все сервисы (обращение к systemd)
                                 # можно изучить в выводе демоны .mount/.target
                                 # и уже указывать тип через -t

$ systemctl -t service           # сервисы запущенные в данный момент

$ systemctl -t target

$ systemctl enable cups          # по умолчанию большинство юнитов не
                                 # запускаются при старте системы
                                 # чтобы юнит автоматически запускался
                                 # существует enable параметр,
                                 # disable это противоположность

$ systemctl stop/start           # старт/стоп сервиса
$ systemctl status name.service  # статус сервиса
$ systemctl daemon-reload        # перезагружает конфигурацию всех модулей
$ systemctl reload <unit>        # перезагружает конфигурацию модуля
$ systemctl --failed             # сервисы остановленные в аварийном режиме
$ systemctl reset-failed         # удаляет failed статус
$ systemctl cat <unit>           # прочитать содержимое юнита (узнать путь)
$ systemctl edit <unit>          # добавить правило в юнит
$ systemctl edit <unit> --full   # отредактировать текущие правила

/etc/systemd/system - юниты, устанавливаемые системным администратором (можно
изменять) в основном ссылаются на `/usr/lib/systemd/system`.

/usr/lib/systemd/system - юниты, предоставляемые пакетами при их установке
(не надо изменять).

Пример модуля и его описание:
# Секция Unit нужна для описания модуля и объявления зависимостей
# Например, запустить данный юнит после какого-то юнита, или наоборот и т.д
[Unit]
Description=test

# Секция Service нужна для реализации действия модуля
[Service]
ExecStart=/usr/local/bin/test.sh

# Секция Install аналогична Unit (почти что) там объявляется Wants
# а здесь например WantedBy. В этом примере говорится что multi-user.target
# должен быть запущен, некая зависимость
[Install]
WantedBy=multi-user.target

$ systemd-analyze blame
$ systemd-analyze critical-chain


--- Управление процессами и ресурсами
Существует три типа аппаратных ресурсов: центральный процессор, память,
устройства ввода/вывода. Процессы соперничают за эти ресурсы, и задачей ядра
является правильное распределение ресурсов. Не следует уделять излишнего
внимания ускорить систему, которая и так работает хорошо (пустая трата времени)
Чтобы понять сколько ЦПУ тратит времени на какой-либо процесс можно выполнить:
$ time ls (это называется процессорное время).


--- Синхронность и асинхронность процесса
Асинхронность - одновременно, не прерывая основной цикл программы, параллельно `&`.
Синхронность  - не одновременно, действие начнется только тогда, когда
                завершится основное действие программы.

Синхронные программы легче отлаживать, а асинхронные наоборот.


--- Адресное пространство процесса (память процесса)
Когда программа запускается на выполнение, ядро выделяет для нее место в
оперативной памяти.

Память запущенной программы (процесса) разделена на ряд непрерывных секций.
Команды из секций выполняются последовательно. При развертывании программы
секции разделяются и каждая готова для работы.

Некоторые секции уже известны перед запуском процесса, например .text, .data, .bss.
Которые можно посмотреть $ size obj.o

.text еще может называться code space.
.data может называться data space.

.text (младшие адреса 0x0)
Код программы, машинные инструкции (исполняемый код), используется для хранения
исполняемого кода программы, выполняется во время выполнения кода, сюда нельзя
ничего записывать (процессу). Эта секция существует в read-only чтобы
предотвратить несанкционированное изменение кода программы.

.data
Глобальные, статические переменные, которые определены
(int i = 2, char name[20]) изначально эта секция пуста,
и она существует на чтение/запись.

.bss
Глобальные, статические переменные, которые НЕ определены (int i)

.heap
Динамическая аллокация памяти (для долгоживущих объектов). Она аллоцируется,
когда процесс стартует и не привязана ни какому файлу (месту на диске),
а .text, .data, .bss можно увидеть `/proc/$(pidof a.out)/maps`.

.stack
Может расширяться и сжиматься по мере вызова функций (фреймов). Аргументы
функций, локальные переменные функций (короткоживущие объекты) Вызов функции
приводит к помещению в стек (создание кадра), когда функция возвращает
управления, кадр уничтожается. Размер у стека фиксированный (8 MiB).

.env (0xfffffff...)
Аргументы командной строки и переменных окружения.
Это могут быть argc, argv, envp (переменные окружения).

.debug
Ключ -g при компиляции, добавляется отладочная информация.

Программист, когда использует в программе указатели, использует память процесса
(адресное пространство) и работает с ней и только с ней! Указатели = работа с
адресным пространством процесса (логические адреса).


--- Прерывания (CPU)
Прерывание - сигнал к процессору, испускаемый аппаратными средствами или
программным обеспечением, и указывающий на событие, которое требует немедленного
внимания CPU. Прерывание предупреждает процессор о высокоприоритетном состоянии,
требующем прерывания текущего кода, выполняемого процессором.

Например, процессор исполняет какие-то инструкции, затем ему приходит
"прерывание" он должен бросить выполнение этих инструкций, и начать выполнять
более приоритетные инструкции.

Процессор отвечает, приостанавливая свои текущие действия, сохраняя свое
состояние и выполняя функцию, называемую обработчиком прерываний для обработки
события. Это прерывание является временным, и после завершения обработки
обработчика прерывания процессор возобновляет обычную работу.

Программное прерывание - системный вызов (например, запрос памяти).

Аппаратное прерывание - нажатие клавиши на клавиатуру, перемещение мыши
(немедленная реакция). Позволяет таким устройства, как внешние устройства
ввода-вывода и системные часы, асинхронно прерывать работу центрального
процессора.

Исключения - тоже прерывание, исключительная ситуация, деление на ноль.


--- IPC
Процессы изолированы друг от друга и не могут напрямую обмениваться данными,
за исключением использования специализированных методов межпроцессного
взаимодействия (IPC), таких как сокеты, каналы, сигналы, файлы, разделяемая
память, файловая блокировка, наследование дочерним процессом окружения родителя
и т.д.

Например, ядро может отправить сигнал процессу, когда произойдет что-нибудь из
следующего перечня:
* пользователь набрал на клавиатуре команду прерывания (обычно это Ctrl+C);
* завершился один из дочерних процессов данного процесса;
* истекло время таймера (будильника), установленного процессом;
* процесс попытался получить доступ к неверному адресу в памяти.

В оболочке сигнал процессу можно отправить с помощью команды `kill`.
Сигнал можно проигнорировать, либо написать обработчик сигнала.

Сигнал и прерывания это разные вещи, работают на разных уровнях.
Сигнал (userspace) / Прерывание (kernelspace).
Таким образом, сигналы и прерывания выполняют схожие функции (уведомление о
событиях), но на разных уровнях системы и обычно в разных контекстах.

Сигналы работают в пространстве пользователя (userspace), и это механизм,
который позволяет операционной системе или другим процессам взаимодействовать с
процессом. Например, когда вы нажимаете Ctrl+C в терминале, генерируется сигнал
SIGINT, который отправляется в процесс, выполняющийся в текущем терминале, чтобы
сообщить ему о необходимости остановки.

Прерывания, с другой стороны, обрабатываются на уровне ядра (kernelspace) и
часто связаны с аппаратным обеспечением. Например, когда готовы новые данные от
диска или сетевого интерфейса, генерируется прерывание, чтобы ядро могло
обработать эти данные.


--- Что будет если закрыть терминал с дочерними процессами
Например, открыл терминал xfce4-terminal, в нем есть несколько процессов
bash и vim. Если закрыть терминал, все процессы получат сигнал SIGHUP
и закроются.


--- Гонка обращения к файлам и блокировка
Блокировки позволяют процессам синхронизировать свои действия с файлами. Гонка
обращения к файлам (race condition) возникает, когда два или более процесса
одновременно пытаются считать, изменить и записать данные в один и тот же файл
или ресурс, и итоговый результат зависит от того, в каком порядке произошли
доступы. Это может привести к непредсказуемому поведению, повреждению данных или
уязвимостям в безопасности, если один из процессов зависит от содержимого файла,
которое может быть изменено другим процессом.

Блокировка в Linux - это механизм, который используется для предотвращения гонки
обращения к файлам. Она позволяет одному процессу "заблокировать" файл, тем
самым предотвращая другие процессы от доступа к нему до тех пор, пока блокировка
не будет снята.

Файловые блокировки (File Locks): Linux поддерживает два типа файловых
блокировок: блокировки записи (exclusive locks), которые позволяют только одному
процессу иметь доступ для записи в файл, и блокировки чтения (shared locks),
которые позволяют нескольким процессам одновременно читать файл.Эти блокировки
устанавливаются с помощью системного вызова fcntl() или flock(). fcntl() более
гибкий механизм. flock() более грубый, он блокирует весь файл и не дает другим
процессам взаимодействовать, fcntl() же наоборот, можно заблокировать какие-то
определенные (участки) части файла и разрешить другие, например, только на
чтение. fcntl() и flock() это системные вызовы.

Блокировки с помощью мьютексов (Mutexes): Мьютекс - это примитив синхронизации,
который используется для защиты доступа к ресурсам в многопоточных приложениях.

Мьютексы (mutexes) могут работать как в пространстве пользователя (userspace),
так и в пространстве ядра (kernelspace). В пространстве пользователя они
используются для синхронизации доступа к общим ресурсам между потоками одного
процесса или разными процессами. В пространстве ядра мьютексы используются для
синхронизации доступа к общим ресурсам между различными частями ядра, такими как
модули, системные вызовы и прерывания.

Функции библиотеки stdio выполняют буферизацию в пользовательском пространстве,
в связи с чем следует быть осторожными, применяя их вместе с методиками
блокировки. Лучше использовать read()/write() без буферизации. Либо отключить
буферизацию с помощью setbuf().

Можно еще осуществлять блокировку для памяти, не только для файла.

Все блокировки в системе можно посмотреть в файле: `/proc/locks`.
Большинство блокировок все таки от 0 до EOF, частичную блокировку редко заметишь.
FLOCK flock() / POSIX fcntl(). В 5 колонке PID, далее название файла (major:minor:inode)
major - номер устройства где находится файл.
minor - номер раздела на устройстве.
inode - inode.

Можно найти так:
$ find / -inum <inode>

В конце таблицы:
0 EOF - от начала до конца


--- pthreads
По аналогии с процессами потоки выполнения представляют собой механизм для
одновременного выполнения нескольких параллельных задач в рамках одного
приложения. Один процесс может содержать несколько потоков. Все они выполняются
внутри одной программы независимо друг от друга, разделяя общую глобальную
память - в том числе инициализированные/неинициализированные данные и сегменты
кучи. Потоки в процессе могут выполняться одновременно.

Процессы не разделяют память напрямую, так что для обмена данными между
ниминеобходимо использовать межпроцессное взаимодействие (IPC), которое может
быть менее эффективным.

Создание процесса с помощью fork() потребляет относительно много ресурсов.
Приходится дублировать различные атрибуты процесса, такие как таблицы со
страницами памяти и файловыми дескрипторами; это означает, что вызов fork()
занимает существенное время.

Потоки помогают избавиться от этих проблем.

Потоки исполняются в общем адресном пространстве, что облегчает обмен данными
и синхронизацию. Все потоки имеют доступ к одним и тем же глобальным переменным
и структурам данных. Это позволяет им легко обмениваться информацией и
синхронизировать своё состояние, используя методы синхронизации, такие
как мьютексы (mutexes), семафоры (semaphores) или условные переменные
(condition variables).

Мьютекс (от англ. mutex, сокращение от mutual exclusion - взаимное исключение) -
это примитив синхронизации, который используется для контроля доступа к общему
ресурсу в многопоточной программе. Под "капотом" мьютекс обычно представляет
собой переменную, которая указывает, захвачен ли он каким-либо потоком.

Однако это также подразумевает, что потоки должны быть осторожны, чтобы избежать
гонок за данные (data races) и других проблем синхронизации, поскольку
одновременный доступ к общим ресурсам без должной синхронизации может
привести к непредсказуемому поведению программы.

Обмен информации между потоками является простым и быстрым. Для этого всего лишь
нужно скопировать данные в общие переменные (глобальные или в куче).

Создание потока занимает меньше времени, чем создание процесса - обычно имеем
как минимум десятикратный выигрыш в производительности.

Сразу после запуска программы итоговый процесс состоит из одного потока, который
называют исходным или главным.

Обмениваться данными между потоками просто. Такой же обмен данными, но между
процессами требует больше затрат (например, создания общего сегмента памяти или
использование конвейера).

Ошибка в одном потоке (например, изменение памяти через неправильный указатель)
может повредить остальные потоки в процессе, поскольку все они используют общее
адресное пространство и некоторые другие атрибуты. Для сравнения, процессы
являются более изолированными друг от друга.

Работа с сигналами в многопоточном приложении требует тщательного проектирования
(как правило, рекомендуется избегать использования сигналов в многопоточных
программах).

Мьютексы позволяют потокам синхронизировать использование общих ресурсов, чтобы,
к примеру, один поток не пытался получить доступ к разделяемой переменной в
момент, когда другой поток изменяет ее значение. Условные переменные дополняют
это решение, позволяя потокам оповещать друг друга о том, что разделяемая
переменная (или другой общий ресурс) изменила свое состояние.

Потоки работают тоже по временным интервалом, которым присваивает планировщик
задач. Временной отрезок, отведенный планировщиком для потока 1, исчерпывается,
после чего начинает выполнение поток 2. Второй поток работает больше, чем 1
поток (допустим). А затем 1 может работать больше чем 1, это поведение
непредскауземо. Такое непредсказуемое поведение является результатом причудливой
работы планировщика ядра. В сложных программах подобные ошибки возникают редко
и их бывает сложно воспроизвести - а значит, сложно найти.

Чтобы избежать проблем, которые возникают при попытке обновления разделяемой
переменной из разных потоков, следует использовать мьютекс
(отmutual exclusion - «взаимное исключение»); это позволит гарантировать, что
только один поток имеет доступ к переменной в определенный промежуток времени.
В целом мьютексы можно использовать для обеспечения атомарного доступа к любым
разделяемым ресурсам, но чаще всего они применяются для защиты общих переменных.
В большинстве приложений влияние мьютексов на производительность не является
значительным. Мьютекс имеет два состояния: закрытое (блокированное) и открытое
(разблокированное).


--- Dbus (Desktop Bus)
Система, которая позволяет приложениям и сервисам общаться между собой.
Dbus состоит из управляющего демона. `systemctl status dbus.service`. Каждое
приложение, которое хочет работать с Dbus, должно зарегистрировать свой сервис
в демоне Dbus. Поскольку все приложения и сервисы могут беспрепятственно
обмениваться сообщениями, этот способ еще называется шина Dbus.

На шине каждое приложение имеет свой адрес, а каждое сообщение имеет своего
отправителя и адресата. Приложение может обмениваться сообщениями даже не с
одним, а несколькими приложениями одновременно. Каждое приложение может
отправлять сообщения и прослушивать входящие.

Этот механизм дает системе огромную гибкость, например, программы могут
подписываться на сообщения о подключении новых устройств, изменении настроек,
изменении состояния системы и многое другое.

Обычно Dbus создает две шины или области, в которых программы могут обмениваться
сообщениями. Это системная шина - для системных сервисов. Ее главная задача -
доставка сообщений об изменении состояния оборудования. Вторая шина сессионная,
создается отдельно для каждого пользователя и позволяет приложениям, запущенным
от его имени взаимодействовать между собой.

Пример объектов:
org.freedesktop.NetworkManager
org.freedesktop.UDisks
org.freedesktop.DisplayManager
org.kde.plasmashell

Включить музыку в VLC:
$ dbus-send --print-reply --dest=org.mpris.MediaPlayer2.vlc /org/mpris/MediaPlayer2 \
org.mpris.MediaPlayer2.Player.Play

Send a message to a message bus:
$ dbus-send

Debug probe to print message bus messages:
$ dbus-monitor

С помощью Dbus можно:
1. Реализовать автоматизацию задач, таких как запуск определённых приложений при
   подключении устройств.

2. Интегрировать различные приложения для обмена данными, например, отправка
   сообщений между чат-клиентами.

3. Управлять аудио и видео сервисами, например, регулировать громкость или
   воспроизводить мультимедиа.

4. Разрабатывать плагины и расширения для системы и приложений, использующие
   DBus для взаимодействия с другими компонентами.

5. Создавать системы нотификации, которые могут уведомлять пользователя о
   различных событиях.

6. Управлять сетевыми настройками и подключениями.

7. Мониторить состояние системы и ресурсы, такие как использование CPU, память,
   диск и т.д.

D-Bus является инструментом уровня пользовательского пространства (userspace).
Это означает, что он работает на более высоком уровне, чем ядро операционной
системы (kernel space), и предоставляет API для взаимодействия приложений и
служб, работающих в пространстве пользователя. D-Bus не взаимодействует напрямую
с аппаратным обеспечением или ядром системы, а служит механизмом для передачи
сообщений и команд между различными процессами на уровне пользовательского
интерфейса и служб.

А в IPC kernelspace входят: сигналы, прерывания, сокеты и т.д. Описано выше в секции IPC.
