Темы:
* Учетные записи
* Атрибуты файла
* Изменение прав доступа
* Изменение владельца
* Hostname (сетевое имя компьютера)
* Окружение shell
* Файлы личного окружения пользователя
* Login shell / Non login shell
* Разница между терминалом и консолью
* Локаль OC (локализация)
* Типы файлов в UNIX
* Виртуализация
* Графический интерфейс
* xfce и lightdm
* Сделать загрузочную флешку
* Создание приватного и публичного ключа
* Что такое fingerprint
* sudoers
* while (1) - 100% CPU
* Значения систем счисления dec bin hex oct char
* Обратная совместимость
* GNU (GNU's Not Unix)
* Deb / RPM
* Floppy / CD / DVD / Blu-Ray / CDROM
* Дистрибутив
* Этапы разработки
* Android & USB
* Таблица разделов MBR vs GPT
* Как зайти в BIOS
* Что такое Subshell
* CI / CD
* Хуки (перехват)
* Рефакторинг
* Цвета тем
* Удаление файлов
* Облачное хранилище
* su vs sudo
* passwd vs shadow
* QEMU
* Гипервизор
* Виртуализация и контейнеризация
* Поддержка


--- Учетные записи
Учетные записи служат для авторизации, для разграничения прав доступа субъектов.
У каждого пользователя есть своя первичная группа.
Два вида пользователей, обычный и суперпользователь.

uid(user ID) - идентификатор пользователя
gid(primary group ID) - идентификатор основной группы
/etc/passwd - учетные записи ползователей хранятся в файле (имя пользователя, uid, gid, etc)
/etc/group - информация о группах
/etc/shadow - пароль пользователя


--- Атрибуты файла
- тип файла (- обычный файл, d каталог, l символическая ссылка,
c файл для устройства, b блочное устройство)

r разрешается открывать и читать содержимое файла (без этого бита нет возможности открыть)
w разрешается записывать в файл или усекать его
x разрешается интерпретировать файл как программу и выполнять ее файлы сценариев

t (sticky bit) ограниченное удаление, присваивается каталогам.
Например каталог /tmp имеет sticky bit в этом каталоге могут создавать файлы все
пользователи, однако удаление чужих файлов - невозможно! Некий shared получается.
Все пользователи могут обмениваться между собой файлами.

s (setuid bit) предоставляет права другого пользователя, например, при запуске файла с setuid
Создаваемый процесс получает полномочия пользователя-владельца (группы владельца) запущенного файла
/etc/passwd владелец root и права -rw-r--r--, другие пользователи не могут изменять файл, кроме root
а утилита passwd имеет s бит ls -l $(which passwd) -rwsr-xr-x, что означает что любой пользователь
может изменить свой пароль без прав суперпользователя.

Нужно запомнить что сначала идут привилегии для владельца, затем привилегии для группы,
затем привилегии для всех остальных. На каждый из этих трех классов действий приходится
по три бита, всего имеем девять бит.

read, write, execute - это права доступа к файлу.


--- Изменение прав доступа
Метод символических символов chmod +x file
Метод изменение прав доступа с помощью восьмеричных чисел chmod 777

Режимы доступа к файлу в двоичном и восьмеричном представлениях:
0  000  ---
1  001  --x
2  010  -w-
3  011  -wx
4  100  r--
5  101  r-x
6  110  rw-
7  111  rwx

Можно указывать прямо:
$ touch file; chmod 0 file
$ chmod +rwx file
$ chmod =r file
$ chmod -r file
$ chmod +t file
$ chmod +s file

(+) добавляет новые perms к файлу
(-) удаляет perms у файла
(=) удаляет существующие и заменяет на указанные

$ chmod u+rwx file
$ chmod g+w file
$ chmod o+r file
$ chmod a+rwx file


--- Изменение владельца и группы файла
$ sudo chown root: test_file


--- Hostname (сетевое имя компьютера)
Находится это название в файле /etc/hostname и его можно изменить и /etc/hosts
$ hostnamectl set-hostname <host_name>


--- Окружение shell
Командная оболочка на протяжении всего сеанса работы использует массу информации, которая
называется окружением. В окружение входит переменные окружения, переменные командной
оболочки (bash), псевдонимы, функции окружения.

Вывести окружение можно с помощью:
$ env
$ printenv PATH  # вывод переменной и его значения
$ set | less     # переменные командной оболочки и окружения, и функции (полное окружение)
$ echo $HOME     # получить значение переменной

LANG             # язык программ
EDITOR           # текстовой редактор
DIRSTACK         # вершина стека
BASH_VERSION     # версия bash более чисто

Единственное что не выводит окружение это псевдонимы, но их можно посмотреть командой alias

Когда мы входим в систему, запускается программа bash и читает содержимое серии конфигурационных сценариев,
где определяется окружение по умолчанию, общее для всех пользователей, затем запускается личное окружние,
когда прочитаются файлы в домашнем каталоге. Эти файлы используются для задания
элементов окружения для оболочки пользователя.


--- Файлы личного окружения пользователя
Программа оболочки Bash использует набор скриптов выполняемых при её
запуске для создания рабочего окружения. Каждый последующий выполняемый
скрипт может перезаписать значения, присвоенные предыдущим скриптом.

Важный системный файл, который читается всегда при запуске системы
.bashrc  - существует для задания псевдонимов, команд, функций, используемых
пользователями оболочки bash


--- Login shell / Non login shell
Оболочки:
Интерактивная оболочка - взаимодействие (приглашение к вводу)
Неинтерактивная оболочка - не может взаимодействовать (оболочка запускает скрипт или демон)

Login shell - это командная оболочка (shell), которая запускается при входе пользователя
в систему (при вводе логина и пароля). Она читает и выполняет команды из файла настроек,
например, `.bash_profile` или `.profile`, который содержит переменные среды и другие настройки,
специфичные для пользователя.

Non-login shell - это командная оболочка, которая запускается после входа в систему,
например, при открытии нового терминала или выполнении скрипта. Она не читает файлы настроек
логин-шелла, но обычно читает и выполняет команды из другого файла настроек, например, `.bashrc`.

Основная разница между ними заключается в том, что login shell используется для начальной
инициализации сессии пользователя, устанавливая переменные среды и прочие настройки,
в то время как non-login shell предназначены для последующих интерактивных сессий.

Чтобы распознать: echo $0 если есть '-bash' то вход осуществился
Например вход по SSH на другой сервер производит login shell

login shell:
$ sudo -i
$ su -
$ su - <username>

non-login shell:
$ sudo -s
$ su <username>

Различие заключается в разном порядке скриптов запуска при открытии этих оболочек
и их переменных окружения.

* Файлы окружения по умолчанию для всех пользователей
/etc/bash.bashrc   # является общесистемной версией - для всех пользователей
/etc/profile       # задается для общесистемных переменных окружения
/etc/profile.d/    # здесь находятся переменные окружения для всей системы

Данные файлы окружения запускаются от id пользователя, которым мы производим
вход в оболочку окружения. То есть когда user пользователь открывает оболочку
файлы окружения будут запущены от его имени.


--- Разница между терминалом и консолью
Для работы с консолью GUI не нужен. А терминал это программа, которая эмулирует работу консоли и встроена
в GUI. Все команды терминала - работают в консоли. Терминал был создан для того, чтобы была возможность
использовать консольные утилиты при работе с GUI. Терминал позволяет использовать интерактивную оболочку.
Консоль нужна в тех случаях, когда есть проблемы с драйверами видеокарты или графической оболочкой,
например такие проблемы можно исправить через консоль. Если какая-то программа зависнет и положит весь GUI,
то на помощь приходит консоль.

Терминал возвращает pts/n терминала
Консоль возвращает tty/n консоли

Можно отправить что-либо с ввода в вывод в другой терминал :)
$ echo "Hello" > /dev/pts/0


--- Локаль OC (локализация)
Набор переменных, который определяет язык приложений, консоли и т.д.

Формат:
locale:charset
Язык:Кодировка

Набор символов (charset) - язык пользователя, страна пользователя, часовой пояс пользователя.
Кодировка - означает что ПО должно использовать кодировку такую-то.

Пример: en_GB.UTF-8 - значит, что клиентское ПО должно выводить текст на
британском английском используя кодировку UTF-8

Можно получить командой locale
$ locale -a

Чтобы изменить локаль .bashrc (один из способов)
$ export LANG=en_US.utf8

Если при выводе выдаются ошибки подобные:
Cannot set LC_CTYPE to default locale: No such file or directory

То скорее всего задается локаль, которая не была сгенерирована.
Для этого нужно подправить /etc/locale.gen (должен быть установлен locales)
В этом файле нужно раскомментировать нужную локализацию, например en_US.UTF-8 UTF-8
Затем выполнить $ locale-gen и ошибки пропадают, затем $ locale -a и проверяем,
что в доступных теперь новая локализация.

Можно запустить приложение с другим языком, например LANGUAGE=zh_TW vim

LANG - Локаль, установленная в этой переменной используется в качестве значения
для всех остальных LC_*-переменных.

LANGUAGE - Запасные локали (нужно для вывода сообщений на разных языках)


--- Типы файлов в UNIX
1. Обычный файл (regular file) '-'
2. Каталог (directory) 'd'
3. Именованный канал (named pipe) 'p'
4. Символическая ссылка (soft link) 'l'
5. Специальный файл устройства (device file) 'c' и 'b'
6. Сокет (socket) 's'


--- Виртуализация
Термин "хостовая" обычно используется в контексте сетевых технологий и обозначает
компьютер или устройство, которое предоставляет ресурсы, данные или услуги для других
компьютеров или устройств, известных как клиенты, в сети. Хост может быть сервером,
который управляет веб-сайтами, электронной почтой, базами данных и т.д. В более общем смысле,
хостовая машина - это машина, которая является домом для выполнения определенного
программного обеспечения или сервиса.

Эмулятор виртуальной машины - это ПО, устанавливаемое на хостовую ОС
и состояющее из монитора виртуальных машин. Монитор виртуальных машин
предоставляет собой ПО, обеспечивающее взаимодействие между виртуальными
машинами и реальным оборудованием.

Гостевая ОС - это операционная система, устанавливаемая на созданную
виртуальную машину.


--- Графический интерфейс
Заботы о вводе и выводе на низком уровне берёт на себя графическая
подсистема Linux - X11 (X Windows System), пространством ресурсов является ЭКРАН.
На экране отображатеся команды графического вывода и организуется
обратная связь с устройствами графического ввода. Примером обратной
связи является - указатель мыши. Сама мышь простое устройство ввода,
способное передавать информацию о его перемещении (точка ввода - фокус)
Под управлением X11 (X Windows System) осуществляется работа всех графических приложений.

Состоит эта система из X-сервер и X-клиент.
* X-сервер - это программа, которая организует работу с устройствами ввода/вывода,
производит отрисовку видимых элементов и предоставляет свои ресурсы для X-клиентов,
загружает драйверы устройств (видеокарты, мыши, клавиатуры, управление раскладкой
клавиатуры, шрифты). Процесс запускаемый в фоне.
* X-клиент - программа, осуществляющая ввод / вывод графических данных при помощи
X-запросов к X-серверу браузер, программа, игры, мультиплеер, графические редакторы и т.д
это задачи, которые обращаются к X-серверу с запросами, обычно клиент имеет окно (или несколько)
потом клиент регистрирует события / активность устройств ввода и изменение свойств окна.

Когда пользователь открывает графические приложение, то оно соединяется с X-сервером
по стандартному протоколу X11 и получает от X-сервера информацию о событиях, перемещения
мыши, нажатия кнопок и т.д.

X-сервер не занимается прорисовкой окна программы, не отвечает за внешний вид приложения,
он отрисовывает всё это в точности как ему передал X-клиент, он занимается чтением данных
из устройств ввода и передачей разных событий X-клиенту. Так же X-сервер называется еще xorg

Отрисовкой графического приложения занимаются библиотеки (тулкиты) gtk / qt
Затем они передают информацию библиотеке libX11 (транслятор)
Затем библиотека запрашивает информацию у X-сервера.

Для того чтобы X-клиенты обращались со своими запросами к X-серверу должен быть
какой-то точный адрес. Адрес X-сервера, к которому должны обращаться X-клиенты
хранится в переменной окружения DISPLAY (способ_доступа:номер_сервера.номер_экрана)
Под способом доступа может подразумеваться сеть (тогда используется сетевой адрес машины с X-сервером
Если запустить команду who можно заметить (:0) способ доступа стоит по умолчанию : а 0 это номер сервера.

Можно в shell указать адрес X-сервера в переменной DISPLAY, затем любой запущенный
X-клиент унаследует это значение и будет отправлять запросы X-серверу к которому указано
Например: $ export DISPLAY=:0

Чтобы включить X-сервер при удаленном подключении стоит прописать $ ssh -X
Чтобы приспособить графическую систему к имеющимуся оборудованию, требуется
организовать профиль, который находится в /etc/X11

xterm - это эмулятор терминала системы X Window
а например gnome терминал - стандартный эмулятор терминала проекта GNOME

xdm(x display manager) - дисплейный менеджер, программа, которая позволяет
запуск сессии на X-сервер, позволяет пользователю войти под своей уч.записью.

Важно заметить что оконный менеджер в каждом дистрибуте свой, эта программа
управляет размещением окон и их внешним видом xfwm4 fly-wm

./Xauthority в каждой домашней директории лежит файл
используется для аутентификации X-сессий, если он весит 0 байт
или есть такие же файлы, то наверное стоит их удалить, чтобы при повторном
логине, создался новый такой файл, в переменной окружения XAUTHORITY хранится
путь к этому файлу.

Рабочий стол оформлятеся благодаря графическим средам для X11, такие как: KDE, GNOME, XFCE

Можно из командной строки запустить графическую систему - sudo startx
Можно из командной строки запустить X-сервер - sudo X


--- xfce и lightdm
Xfce - это графическая среда рабочего стола, которая предоставляет пользователю интерфейс
для взаимодействия с операционной системой. Она включает в себя панель задач, менеджер окон,
настройки рабочего стола и другие инструменты для управления рабочим пространством.

LightDM, с другой стороны, является дисплейным менеджером для графической среды X. Он отвечает за
отображение окна входа пользователя при запуске системы и управление процессом аутентификации.
LightDM позволяет выбирать пользователю, какую графическую среду или сеанс запускать при входе в систему.

Таким образом, Xfce - это графическая среда рабочего стола, а LightDM - это дисплейный менеджер,
обеспечивающий отображение окна входа пользователя и управление процессом аутентификации.


--- Сделать загрузочную флешку
Очень важно обратить внимание, где используется конкретный раздел,
а где само устройство, например dd -> /dev/sdb, а mkfs -> /dev/sdb1
dd - не нужно использовать для Windows

Нужна - флешка и сам образ (.iso)
Для начала нужно подготовить флешку, сделать раздел W95 FAT32:
$ fdisk /dev/sdb
$ d # очистить

После удаления смотрим командой p разделы (их быть не должно - пустая)
$ p

Затем создание n, Выбрать primary, Выбрать default
Нажать p и убедиться что раздел создан System - Linux
Затем t -> b (получается W95 FAT32)
Затем перезапись -> w
$ mkfs.vfat /dev/sdb1 # (форматирование раздела)
С помощью mkfs создается новая файловая система

Затем записываем на флешку образ:
$ dd if=full_path.iso of=/dev/sdb bs=4M status=progress oflag=sync

Можно использовать sync, он сбрасывает все данные в кеше на устройство
иногда флешка может недозаписаться и тогда некоторые данные будут отсутствовать
поэтому лучше использовать sync
$ dd bs=4M if=full_path.iso of=/dev/sdb status=progress; sync

Аналог
$ dd bs=4M if=full_path.iso of=/dev/sdb status=progress oflag=sync

Чтобы очистить флешку:
d <n>   удаляем разделы
w       делаем запись
Затем можно отформатировать


--- Создание приватного и публичного ключа
Открыть дополнительный tty в случае неправильных действий.

* На клиенте
SSH подключения без пароля - по ключам, генерация осуществляется с помощью ssh-keygen

$ ssh-keygen              # создает id_rsa и id_rsa.pub
$ ssh-keygen -f id_file   # создает id_file и id_file.pub

При генерации можно добавить пароль к ключу, который будет запрашиваться при входе
на сервер, или оставить поле пустым.

* На сервере
$ mkdir .ssh
$ touch .ssh/authorized_keys # сюда нужно прописать .pub ключ
А приватный ключ хранится у нас на клиенте, его никому нельзя показывать.

Права доступа к .ssh
.ssh   # директория 700
.ssh/* # все файлы без исключеня должны быть 600
Владелец должен быть пользователь от которого происходит подключение.

После можно сделать /etc/ssh/sshd_config:
PubkeyAuthentication yes
PasswordAuthentication no
AuthorizedKeysFile .ssh/authorized_keys
и можно закомментировать PermitRootLogin

Затем $ systemctl restart sshd.service
Теперь при подключении к серверу будет требовать пароль ssh ключа
Или просто входить без пароля, если мы не ввели ключевую фразу при генерации.

Так как название файла отличается от дефолтного id_rsa необходимо прописать
в .ssh/config на клиенте, например:
Host 192.168.50.240
  IdentityFile ~/.ssh/id_pc

Вот еще пример:
Host wb
  Port 33033
  User rrrrrrr
  HostName 95.70.100.200
  IdentityFile ~/.ssh/id_work_builder

Затем можно будет подключаться так:
$ ssh wb

Чтобы оставаться долго в ssh сессии, можно прописать ClientAliveInterval 3600
sshd_config - ssh-сервер
ssh_config - ssh-клиент

Выполнить команду на сервере (перед выходом из SSH сессии)
$ nohup ./script.sh >/dev/null &


--- Что такое fingerprint
При первом подключении по SSH к удаленной машине генерируется fingerprint
и добавляется в файл known_hosts, наш ПК запоминает эту комбинацию и
сверяет ее при каждом входе, если кто-то переустановит SSH сервер или OC,
то мы об этом узнаем, потому что изменится fingerprint.


--- sudoers
User is not in the sudoers file
Можно добавить пользователя в группу sudo
$ usermod -aG sudo user и тогда пользователь может использовать sudo (работает не везде)

Добавление новой записи в /etc/sudoers происходит через visudo
Например, чтобы не запрашивать пароль при получении прав суперпользователя
можно добавить: <user> ALL=(ALL:ALL) NOPASSWD:ALL
Но добавить эту строку нужно уже в конец файла или после записи %sudo

Данное действие нужно проводить только в крайних случаях
Можно еще сделать для конкретной программы, например:
<user> ALL=NOPASSWD: /usr/bin/apt

-> Требование пароля повышает планку для злоумышленника.


--- while (1) - 100% CPU
Процесс с бесконечным циклом использует CPU на 100%
потому что эти ресурсы простаивают, если бы были другие интенсивные
процессы, то 100% бы не было, а было бы 89% например.


--- Значения систем счисления bin dec hex oct
Символический метод записи чисел
bin - двоичное (1/0)
oct - восьмеричная (0,1,2,3,4,5,6,7)
dec - десятичное число (0,1,2,3,4,5,6,7,8,9)
hex - шестнадцатеричное (0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F)

Например, с помощью десятичной системы счисления dec 65 мы получим символ char A
Этот процесс называется кодировкой символа.


--- Обратная совместимость
Наличие в новой версии компьютерной программы или компьютерного оборудования интерфейса,
присутствующего в старой версии, в результате чего другие программы (или человек)
могут продолжать работать с новой версией без значительной переделки (или переучивания).
Полная обратная совместимость означает, что при замене старой версии компонента на
новую, функционирование всей системы в целом не нарушится.


--- GNU (GNU's Not Unix)
ОС типа Unix, программы которой свободны. Свободные программы передают своим
пользователям контроль над их собственными вычислениями. Несвободные программы
отдают своих пользователей во власть разработчика программ.

Свобода программы означает, что у пользователей есть свобода выполнять, копировать,
изучать, править, улучшать. Полный доступ к исходному коду. Можно править программу так,
чтобы она выполняла ваши вычисления, как вы желаете.

Программы GNU распространяются под GNU стандартами, их можно увидеть в секции Copyright
Например: man uname

Есть пакет называемый coreutils - пакет програмного обеспечения GNU, содержащий большое
кол-во утилит (cat, ls и т.д), а исходники этих утилит можно посмотреть coreutils source

Проприетарное программное обеспечение (ПО) - это программное обеспечение, чьи права на использование,
изменение и распространение контролируются владельцем или разработчиком ПО. Пользователи обычно не
имеют права на доступ к исходному коду или на изменение программы без разрешения правообладателя.

GNU/Linux не относится к проприетарному ПО. GNU/Linux - это операционная система с открытым исходным кодом,
построенная на ядре Linux и дистрибутиве GNU. Пользователи имеют право на свободное использование,
изменение и распространение этой операционной системы в соответствии с лицензией
GNU General Public License (GPL). А вот Windows является проприетарной операционной системой.

Ричард Столлман является основателем движения свободного ПО (СПО).
Автор концепции «копилефта», призванной защищать идеалы движения; эту концепцию он с помощью юристов
позже воплотил в лицензии GNU General Public License (GNU GPL) для ПО.
Ранее также известный программист. Из авторских программ можно отметить GNU Emacs,
Коллекция компиляторов GNU (GCC) и Отладчик GNU (GDB). С середины 1990-х годов Столлман стал
программировать значительно меньше, посвятив себя распространению идей свободного ПО.

Столлман не советует пользоваться сотовыми телефонами, потому что он считает, что возможность
определения текущего местоположения телефона может создать различные проблемы для абонента.
Он объясняет, что при обыкновенном (кнопочном) выключении телефона, он на самом деле выключенным
не является, и продолжает обратно отсылать сигналы, так что остаётся возможность с помощью метода
триангуляции определять место нахождения пользователя и отслеживать его перемещения.
Кроме того, микрофон может быть включен без ведома пользователя. В связи с этим Ричард
также рекомендует вынимать батарею из мобильного телефона.

Интересная мысль: кто задает инструкции вашему компьютеру ? Пользователь или корпорации ?
В большинстве случаев CPU обрабатывает огромное кол-во инструкций необходимых именно
корпорациям, а не пользователю. ПК не подчиняется вашим инструкциям. ПК выполняет
пользовательские инструкции в той мере, в которой ему позволяют корпорации.
Либо пользователь контролирует программы, либо программы контролируют пользователя.
Корпорации превращают пользовательские данные в звонкую монеты, они жадные,
и найдут способы как саботировать пользователя и создать из этого прибыль.
Большие компании делают большие деньги контролируя пользователей.
С закрытым ПО программист вряд ли чему-то научится, а с СПО все иначе.
Программисты анализируют и дезасамблируют закрытое ПО чтобы затем написать открытое ПО.
Это ужасно нелогично и затрагивает большое кол-во времени. Это тяжелая работа.
В нашей жизни компьютеры стали настолько важны, что свобода ПО стоит на первом
месте по решению проблем/задач, это необходимость.


--- GNU GPL лицензия
Юридический документ. Эта лицензия дарит свободу ПО.
Никто не имеет право закрывать код проекта/программы.
Ричард Столлман считает, что закрытое ПО приведет мир к тотальной слежке
и бесконтрольной передаче данных 3 лицам. Он считает, что закрытые программы ограничивают
свободу пользователей и подвергают их контролю со стороны разработчиков.

"Программное обеспечение, которое не является свободным, это инструмент контроля над вами.
Это вас унижает и лишает вас свободы." Это война с корпорациями зла Google, Microsoft.
Не стоит закрывать глаза на дыры в своей безопасности. Данные, информация, это очень важно.

Ричард Столлман неоднократно подвергался давлению среди данных корпораций. Он невыгоден системе.
Американское сообщество натравили на него ЛГБТ сообщества, лесбиянок, геев, трансгендеров,
и пытались добиться его ухода из сообщества СПО. Отличный пример того как работает американская система.


--- Deb / Rpm
.deb и .rpm это всего лишь архивы, созданные с помощью утилиты ar
Эти архивы включают в себя файлы программ, исполняемые файлы, библиотеки и т.д.

RPM (Red Hat Package Manager) - менеджер пакетов, используемый в операционных системах,
основанных на Red Hat, это вся ветка дистрибутивов: Fedora, OpenSUSE, Red Hat, CentOS
Red Hat сокращение -> RHEL

Deb (Debian Package Manager) - менеджер пакетов, использует архивы, которые создаются с помощью ar
Для управления .deb пакетами используется dpkg. Debian / Ubuntu / Mint

Их иструменты очень похожи.


--- Floppy / CD / DVD / Blu-Ray / CDROM
Информация может храниться не только на жестком диске компьютера, но и на других альтернативных носителях:
CD, DVD, Blu-ray или USB-накопителях.

Floppy  - дискета для хранения данных небольшого объема (2,5МБ)
CD      - цифровой носитель, стандартный объем 700МБ, пришедший на смену floppy-дисков (использовался для музыки)
DVD     - схож внешне с CD, но хранит в себе больший объем информации (5ГБ) (использовался для фильмов, видео)
Blu-Ray - предназначен для записи видео с высокой четкостью, может хранить в себе еще больше чем DVD (22-33ГБ)
CDROM   - разновидность дисков с записанными на них данными, доступными только для чтения (read-only memory)


--- Дистрибутив
Дистрибутив - это просто согласованный набор программ, который идет с ядром.
А ядро Linux, оно во всех дистрибутивах практически одинаковое.
Поэтому окружение у дистрибутивах разное, например Ubuntu и Debian отличаются, а в чем-то схожи.


--- Этапы разработки
* Сбор и обработка требований

* Получение технических заданий, планы работ

* Разработка
  - Дизайн
  - Кодирование
  - Тестирование
  - Документирование

* Поддержка
  - Внедрение (Установка ПО, обучение пользователей)
  - Сопровождение (Исправление выявленных ошибок, поддержка пользователей)


--- Android & USB
Получить права разработчика в телефоне, разрешить отладку через USB
Подключиться через USB к телефону, выбрать (передача файлов)

Очистка ненужных пакетов:
$ adb shell
$ pm list packages | grep <name>
$ pm uninstall -k --user 0 <name>

Перенести файлы с ПК на телефон:
$ sudo jmtpfs /mnt/


--- Таблица разделов MBR vs GPT
Таблица разделов -> Раздел А (отдельно) -> Раздел Б (отдельно)
В каждом разделе есть: Файловая система -> Данные в файле.

Компьютер обычно имеет как минимум один диск для хранения данных. Но физический диск не может хранить
данные без разбивки на разделы. Один физический диск может содержать один или быть разбит на несколько
разделов. Но как создать несколько разделов? Здесь в дело вступает таблица разделов. Операционная
система обратится к этой таблице для получения данных о разделах.

MBR (Master Boot Record) старый стандарт, BIOS совместимость со старым оборудованием.

GPT (GUID Partition Table) новый стандарт, более надежно, у каждого раздела свой UUID,
на 32 битной ОС, не получится использовать.


--- Как зайти в BIOS
Обычно это клавиши DEL, F11. В редких случаях F2


--- Что такое Subshell
Оболочка, это программа, которая позволяет запускать команды в Linux
Подоболочка, это новая оболочка предназначенная только для запуска желаемой программы.
Подоболочка получает все глобальные переменные оболочки (родителя),
экспортированные, но не локальные. Запустить подоболочку в оболочке можно: $ bash

Например:
bash
 \_ bash script.sh
     \_ sleep 10000000
Сценарий script.sh выполняется в подоболочке (от оболочки bash)


--- CI / CD
Это комбиняция двух методик в процессе разработки

Continuous Integration
Непрерывная интеграция - постоянное слияние рабочих копий в общую основую ветвь разработки
и выполнение частых автоматизированных сборок проекта для скорейшего выявления потенциальных дефектов.

Continuous delivery - частые выпуски RC, такой подход позволяет уменьшить стоимость,
время и риски внесения изменений путем более частных мелких обновлений в продакшн-приложение.
Гарантия того, что ПО стабильно и может быть передано в эксплуатацию в любое время.
Целью является сборка, тестирование и релиз программного обеспечения с большей скоростью и частотой.


--- Хуки (перехват)
Технология перехвата вызовов функций в чужих процессах.
Суть хукинга - заставить программу поверить, что нужная ей функция находится в другом месте,
заменить оригинал на свою (подмена). На какую функцию ставить хук? Написать свою
библиотеку, которая будет заменять исходную, и делать нужные нам вещи, установить хук
(загрузить библиотеку в память процесса). Тот же пример с LD_PRELOAD описывает hooking


--- Рефакторинг
Это переработка исходного кода программы, чтобы он стал более простым и понятным.
Рефакторинг не меняет поведение программы, не исправляет ошибки и не добавляет новую функциональность.
Он делает код более понятным и удобочитаемым.


--- Цвета тем
Для восприятия более удобны спокойные тона: светло-зеленый, голубой, серый.
В темной комнате лучше использовать темную тему или ночной режим.
Когда светло лучше использовать светлую тему (черный текст на белом фоне).


--- Удаление файлов
Удаляя файл посредством rm или через файловый менеджер, сам файл не удаляется,
а затирается лишь его индекс (освобождается) и пространство, которое занимал файл, записывается системой
как свободное для записи. Файл, так и остался на своём месте и восстановить его оттуда не составит
большого труда. Он пролежит там до тех пор, пока на его место не запишут другую информацию.

Чтобы этого избежать можно перезаписать область памяти нулями (например раздел home)
Но восстановить данные все равно можно будет (профессиональные криминалисты знают где копать)
Чтобы запутать, можно поменять файлам метку времени.

Лучше использовать shred, он перезапишет это место случайными числами (занятое файлом)
И если восстановить файл, то его невозможно будет прочитать.

shred эффективен не во всех ФС (AIX, JFS, XFS, Ext3, NFS и подобные)

Важно заметить, что перезапись файлов несколько раз удлиняет интервал удаления файла,
делает этот процесс более медленным.


--- Облачное хранилище
Дает возможность хранить данные в Интернете (на чужих серверах), к которым есть
доступ у клиента 24.7. Поставщик обеспечивает безопасное хранение данных и обслуживание
серверов хранилища, сети и т.д.


--- su vs sudo
su - switch user
Команда su позволяет войти в систему под учетной записью другого пользователя,
предоставляя полный доступ ко всем ресурсам и привилегиям этого пользователя.
При использовании команды su, пользователь должен знать пароль от аккаунта,
на который он хочет переключиться.

sudo - superuser do
Позволяет выполнить определенную команду с правами суперпользователя (root),
не выходя из текущей учетной записи. Команда sudo требует, чтобы пользователь был включен
в файле настроек sudoers и вводил пароль своей учетной записи для подтверждения действия.


--- passwd vs shadow
/etc/passwd хранит информацию о пользователях.
/etc/shadow хранит информацию, необходимую для аутентификации пользователей при входе в систему.
В отличие от /etc/passwd, файл /etc/shadow доступен только для чтения суперпользователю (root),
чтобы обеспечить безопасность хранения паролей.

Когда создаются новые группы и пользователи файлы passwd/group/shadow изменяются.
Обычные пользователи начинаются с 1000, а с UID 1-499 или 1-999 это псевдопользователи и
они выполняют системные службы (от их лица), у них нет оболочки (nologin).
А у обычных пользователей есть (bash).

Если вместо 'x' поставить hash сумму из shadow, это сработает:
user1:$y$j9T$ICRkTA/TqMwVPxvGJUJ9Y1$A4spI3g11fRL0mqUB34tmzILUCCVSMoagET3cFjcQhD:1002:1002:,,,:/home/user1:/bin/bash

Если убрать 'x', то можно убрать пароль у пользователя:
user1::/home/user:/bin/bash

Раньше хеш-пароля был в /etc/passwd, но его решили убрать в отдельный файл /etc/shadow,
потому что /etc/passwd доступен на чтение всем, а /etc/shadow может читать только root.


--- QEMU
QEMU - это эмулятор и виртуализатор с открытым исходным кодом, который позволяет запускать гостевые
операционные системы и программы, написанные для одной архитектуры процессора, на другой архитектуре.

QEMU является CLI интерфейсом, управления командами из терминала. Чтобы не изучать все опции QEMU
можно установить virt-manager, это GUI интерфейс для QEMU.

Часто можно заметить такое сокращение qemu-kvm, KVM это модуль ядра Linux, обеспечивающий доступ
к аппаратной виртуализации на базе Intel. QEMU может работать отдельно от KVM,
или вместе (с более высокой скоростью).

Libvirt - это демон / API, в который входят инструменты virsh и virt-manager,
они нужны для управления QEMU гостевыми. Управляет виртуализацией QEMU.

Все эти инструменты имеют свободное распространение, являются частью open-source.


--- Гипервизор
Механизм, который управляет, распределяет ресурсы под виртуальные машины называется гипервизом.
Создает изолированную среду для виртуальных машин, таким образом виртуальная машина думает,
что она настоящая хостовая.


--- Виртуализация и контейнеризация
Виртуализация позволяет запускать несколько операционных систем на одном физическом
сервере, при этом каждая операционная система работает в своем собственном виртуальном
окружении, которое называется виртуальной машиной (VM). Это достигается за счет использования
гипервизора, который управляет доступом виртуальных машин к физическим ресурсам сервера.
Таким образом, виртуализация обеспечивает полную изоляцию между виртуальными машинами,
каждая из которых имеет свою операционную систему, приложения и настройки.

Контейнеризация, с другой стороны, позволяет запускать приложения в легковесных контейнерах,
которые используют общую операционную систему хоста, но обеспечивают изоляцию процессов
и зависимостей приложения. Контейнеры более эффективны с точки зрения использования ресурсов
и более быстро запускаются, поскольку не требуют загрузки полной операционной системы,
как это делают виртуальные машины. Это делает контейнеры идеальными для микросервисной
архитектуры и непрерывной интеграции/доставки (CI/CD).

Виртуализация обеспечивает полную изоляцию с виртуальными машинами, в то время как
контейнеризация делит изоляцию на уровне операционной системы.

Виртуальные машины требуют больше ресурсов и времени на запуск,
тогда как контейнеры более легковесны и быстрее запускаются.


--- Поддержка
В контексте операционных систем "поддержка" обычно означает, что разработчики продолжают предоставлять
обновления безопасности, исправления ошибок и иногда новые функции для данной версии операционной системы.

Когда говорят, что поддержка для определенной версии операционной системы закончилась, это означает,
что производитель перестал предоставлять обновления для этой версии. Это означает, что безопасность
и стабильность операционной системы могут стать уязвимыми, так как обновления безопасности не будут выпускаться.

Таким образом, если в CentOS 8 закончилась поддержка, это означает, что не будут выпускаться обновления
безопасности и исправления ошибок для этой версии. В то время как поддержка для CentOS 7, возможно,
продолжается, и обновления будут выпускаться.

Например, Debian Bullseye имеет стабильный выпуск и имеет поддержку. Обычно стабильные версии
дистрибутивов длятся около 5 лет. Однако это может измениться в зависимости от решения проекта.
